{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"appJar The easiest way to create GUIs in Python. Written by a teacher, in the classroom, for students. appJar is designed to run on as many versions of Python as possible - so it should work in your school. There are no other dependencies - simply download , unzip, and put it in your code folder. Check out the installation instructions for other ways to get appJar working. Hello appJar GUIs in appJar require three steps. First, import the library & create a GUI variable. (from now on, we do everything to the GUI variable) # import the library from appJar import gui # create a GUI variable called app app = gui() Then, using the gui variable, add and configure an output widget: (if you've tried turtle this will all look very familiar) # add & configure widgets - widgets get a name, to help referencing them later app.addLabel(\"title\", \"Welcome to appJar\") app.setLabelBg(\"title\", \"red\") Finally, start the GUI: ( NB. don't put any code after this line) # start the GUI app.go() And, that's it: Interactivity Of course, the whole point of making a GUI, is to be interactive - this requires events . The idea behind event-driven programming is that each time the user clicks or types (an event) the GUI should respond. So, we add some input widgets ( Entry Boxes ), for the user to type in: app.addLabelEntry(\"Username\") app.addLabelSecretEntry(\"Password\") Then, we need a function - a block of code to call, when an event happens: def press(button): if button == \"Cancel\": app.stop() else: usr = app.getEntry(\"Username\") pwd = app.getEntry(\"Password\") print(\"User:\", usr, \"Pass:\", pwd) Finally, a button to create the event: # link the buttons to the function called press app.addButtons([\"Submit\", \"Cancel\"], press) We now have an interactive GUI: When the user presses a button, the press function is called, passing the name of the button as a parameter. Appearance counts We also want to change the way the GUI looks : For starters, you can specify a name and size for your GUI, when you create it: app = gui(\"Login Window\", \"400x200\") You can change the general appearance of the GUI: app.setBg(\"orange\") app.setFont(18) You can even specify where you want the cursor to be when the GUI starts: app.setFocus(\"Username\") It now looks a bit better: ( NB. We also set the fg/bg colours on the label - see below ) Make your own And, that's all you need to know. Check out: All the different input widgets & output widgets available. Our support for images and sound . How to include toolbars, menubars & statusbars . How to create simple pop-ups . How to use a grid layout . How to use containers for more advanced layouts. Full code-listing Below is the full code-listing for the above GUI: # import the library from appJar import gui # handle button events def press(button): if button == \"Cancel\": app.stop() else: usr = app.getEntry(\"Username\") pwd = app.getEntry(\"Password\") print(\"User:\", usr, \"Pass:\", pwd) # create a GUI variable called app app = gui(\"Login Window\", \"400x200\") app.setBg(\"orange\") app.setFont(18) # add & configure widgets - widgets get a name, to help referencing them later app.addLabel(\"title\", \"Welcome to appJar\") app.setLabelBg(\"title\", \"blue\") app.setLabelFg(\"title\", \"orange\") app.addLabelEntry(\"Username\") app.addLabelSecretEntry(\"Password\") # link the buttons to the function called press app.addButtons([\"Submit\", \"Cancel\"], press) app.setFocus(\"Username\") # start the GUI app.go() Upcoming in v1.0 In the upcoming 1.0 release, we're formally introducing a new set of options for buiding your GUI. These are targetted at our more experienced users: Context Managers allow you to create the GUI and any containers, in a visibly more understandable way. New functions that allow you to add/get/set widgets all with the same command, including passing configuration paramters. New properties for configuring the GUI. Most of these are already live, and can be used, reducing the above GUI code to: from appJar import gui def press(): print(\"User:\", app.entry(\"Username\"), \"Pass:\", app.entry(\"Password\")) with gui(\"Login Window\", \"400x200\", bg='orange', font={'size':18}) as app: app.label(\"Welcome to appJar\", bg='blue', fg='orange') app.entry(\"Username\", label=True, focus=True) app.entry(\"Password\", label=True, secret=True) app.buttons([\"Submit\", \"Cancel\"], [press, app.stop])","title":"appJar"},{"location":"#appjar","text":"The easiest way to create GUIs in Python. Written by a teacher, in the classroom, for students. appJar is designed to run on as many versions of Python as possible - so it should work in your school. There are no other dependencies - simply download , unzip, and put it in your code folder. Check out the installation instructions for other ways to get appJar working.","title":"appJar"},{"location":"#hello-appjar","text":"GUIs in appJar require three steps. First, import the library & create a GUI variable. (from now on, we do everything to the GUI variable) # import the library from appJar import gui # create a GUI variable called app app = gui() Then, using the gui variable, add and configure an output widget: (if you've tried turtle this will all look very familiar) # add & configure widgets - widgets get a name, to help referencing them later app.addLabel(\"title\", \"Welcome to appJar\") app.setLabelBg(\"title\", \"red\") Finally, start the GUI: ( NB. don't put any code after this line) # start the GUI app.go() And, that's it:","title":"Hello appJar"},{"location":"#interactivity","text":"Of course, the whole point of making a GUI, is to be interactive - this requires events . The idea behind event-driven programming is that each time the user clicks or types (an event) the GUI should respond. So, we add some input widgets ( Entry Boxes ), for the user to type in: app.addLabelEntry(\"Username\") app.addLabelSecretEntry(\"Password\") Then, we need a function - a block of code to call, when an event happens: def press(button): if button == \"Cancel\": app.stop() else: usr = app.getEntry(\"Username\") pwd = app.getEntry(\"Password\") print(\"User:\", usr, \"Pass:\", pwd) Finally, a button to create the event: # link the buttons to the function called press app.addButtons([\"Submit\", \"Cancel\"], press) We now have an interactive GUI: When the user presses a button, the press function is called, passing the name of the button as a parameter.","title":"Interactivity"},{"location":"#appearance-counts","text":"We also want to change the way the GUI looks : For starters, you can specify a name and size for your GUI, when you create it: app = gui(\"Login Window\", \"400x200\") You can change the general appearance of the GUI: app.setBg(\"orange\") app.setFont(18) You can even specify where you want the cursor to be when the GUI starts: app.setFocus(\"Username\") It now looks a bit better: ( NB. We also set the fg/bg colours on the label - see below )","title":"Appearance counts"},{"location":"#make-your-own","text":"And, that's all you need to know. Check out: All the different input widgets & output widgets available. Our support for images and sound . How to include toolbars, menubars & statusbars . How to create simple pop-ups . How to use a grid layout . How to use containers for more advanced layouts.","title":"Make your own"},{"location":"#full-code-listing","text":"Below is the full code-listing for the above GUI: # import the library from appJar import gui # handle button events def press(button): if button == \"Cancel\": app.stop() else: usr = app.getEntry(\"Username\") pwd = app.getEntry(\"Password\") print(\"User:\", usr, \"Pass:\", pwd) # create a GUI variable called app app = gui(\"Login Window\", \"400x200\") app.setBg(\"orange\") app.setFont(18) # add & configure widgets - widgets get a name, to help referencing them later app.addLabel(\"title\", \"Welcome to appJar\") app.setLabelBg(\"title\", \"blue\") app.setLabelFg(\"title\", \"orange\") app.addLabelEntry(\"Username\") app.addLabelSecretEntry(\"Password\") # link the buttons to the function called press app.addButtons([\"Submit\", \"Cancel\"], press) app.setFocus(\"Username\") # start the GUI app.go()","title":"Full code-listing"},{"location":"#upcoming-in-v10","text":"In the upcoming 1.0 release, we're formally introducing a new set of options for buiding your GUI. These are targetted at our more experienced users: Context Managers allow you to create the GUI and any containers, in a visibly more understandable way. New functions that allow you to add/get/set widgets all with the same command, including passing configuration paramters. New properties for configuring the GUI. Most of these are already live, and can be used, reducing the above GUI code to: from appJar import gui def press(): print(\"User:\", app.entry(\"Username\"), \"Pass:\", app.entry(\"Password\")) with gui(\"Login Window\", \"400x200\", bg='orange', font={'size':18}) as app: app.label(\"Welcome to appJar\", bg='blue', fg='orange') app.entry(\"Username\", label=True, focus=True) app.entry(\"Password\", label=True, secret=True) app.buttons([\"Submit\", \"Cancel\"], [press, app.stop])","title":"Upcoming in v1.0"},{"location":"404/","text":"Page not found","title":"404"},{"location":"Empty/","text":"Some data will go here... And here!","title":"Empty"},{"location":"Empty/#some-data-will-go-here","text":"","title":"Some data will go here..."},{"location":"Empty/#and-here","text":"","title":"And here!"},{"location":"Grouping_old/","text":"Grouping Widgets Once you have got to grips with laying out your widgets, it is possible to group them together. Each of these groups is treated like an individual widget. When you START the group, you place it in a cell in your layout. Then, when you place widgets inside the group, you start a new grid. After you STOP the group, you go back to your previous grid layout. Three main styles are currently supported: LabelFrame Will put a border around the widgets, with a title .startLabelFrame(title) .stopLabelFrame() .setLabelFrameAnchor(title, anchor) NoteBook Will create a tabbed interface, with a number of pages .startNoteBook(note) .startNoteTab(tab) .stopNoteTab() .stopNoteBook() .setNoteTab(note, tab) .setNoteBookBg(note, active, inactive) .setNoteBookFg(note, active, inactive) .setNoteTabBg(note, tab, bg) PanedWindow Will create a split view, with draggable panes .startPanedWindow(title) .stopPanedFrame() .setPanedWindowVertical(title) SubWindow Allows the creation of additional windows. The window is hidden until .showSubWindow(title) is called. .startSubWindow(name, title=None) .stopSubWindow() .showSubWindow(title) .hideSubWindow(title) .destroySubWindow(title)","title":"Grouping old"},{"location":"Grouping_old/#grouping-widgets","text":"Once you have got to grips with laying out your widgets, it is possible to group them together. Each of these groups is treated like an individual widget. When you START the group, you place it in a cell in your layout. Then, when you place widgets inside the group, you start a new grid. After you STOP the group, you go back to your previous grid layout. Three main styles are currently supported:","title":"Grouping Widgets"},{"location":"Grouping_old/#labelframe","text":"Will put a border around the widgets, with a title .startLabelFrame(title) .stopLabelFrame() .setLabelFrameAnchor(title, anchor)","title":"LabelFrame"},{"location":"Grouping_old/#notebook","text":"Will create a tabbed interface, with a number of pages .startNoteBook(note) .startNoteTab(tab) .stopNoteTab() .stopNoteBook() .setNoteTab(note, tab) .setNoteBookBg(note, active, inactive) .setNoteBookFg(note, active, inactive) .setNoteTabBg(note, tab, bg)","title":"NoteBook"},{"location":"Grouping_old/#panedwindow","text":"Will create a split view, with draggable panes .startPanedWindow(title) .stopPanedFrame() .setPanedWindowVertical(title)","title":"PanedWindow"},{"location":"Grouping_old/#subwindow","text":"Allows the creation of additional windows. The window is hidden until .showSubWindow(title) is called. .startSubWindow(name, title=None) .stopSubWindow() .showSubWindow(title) .hideSubWindow(title) .destroySubWindow(title)","title":"SubWindow"},{"location":"Install/","text":"Set-up Instructions appJar was designed for use in schools - it therefore doesn't require any kind of special installation . Instead, just DOWNLOAD the ZIP file, unzip, and go - just put the folder in the right place . Pip Installation However, if you can install python packages - we support that too! pip3 install appjar - this will download & install appJar ready for python 3. pip3 install appjar --upgrade - this will upgrade appJar to the latest version. NB. If you're on linux/Mac you might need to use sudo: sudo pip3 install appjar # import the appJar library from appJar import gui Single-user Set-up If you can't/don't want to install using pip, simply: DOWNLOAD appjar and unzip it. Put the appJar folder in your code folder , and you're done! # import the appJar library from appJar import gui (As long as it's in the same folder as your code, it'll work...) Linux If you're on Linux you might be able to make this even simpler. You might have a site-packages folder, that is already in your path. In this case, put the appJar folder in ~/.local/lib/python3.x/site-packages/ where 3.x is the version of python that you use. Multi-user Set-up If you're trying to install appJar in a school, everyone can download their own copy ( see above ), or: Put the appJar folder in a shared location (eg. a folder on a network drive): E:\\PYLIB Then have pupils include the following 2-lines at the start of their code: # add the appJar folder to your PATH import sys sys.path.append(\"E:\\PYLIB\") # import the appJar library from appJar import gui Advanced Set-up If you've got friendly technicians, you can even avoid having to always add appJar to your path... Windows Create an environment variable, which will mean E:\\PYLIB is always in your path . Open Control Panel Navigate to System -> Advanced System Settings Click the Advanced tab Under System variables , click the New.. button Set the Variable name: to be PYTHONPATH Set the Variable value: as the folder you put appJar in (eg. \"E:\\PYLIB\") Press OK , and you're done! Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Linux (Raspberry Pi) /MacOS If you're running python from a terminal: Type the following: echo 'export PYTHONPATH=\"${PYTHONPATH}:~/Documents/PYLIB\"' >> ~/.bashrc Reopen the terminal (or type source ~/.bashrc ), and you're done! NB. Change ~/Documents/PYLIB to the folder where the appJar folder is located. IDLE on Linux (raspberry Pi)/MacOS If you're running python in IDLE, you'll need to add appJar to your site-packages Launch a Terminal Type the following: mkdir -p ~/Library/Python/3.4/lib/python/site-packages cd ~/Library/Python/3.4/lib/python/site-packages echo '~/Documents/PYLIB' > appJar.pth Close the terminal, and you're done! NB. you'll need to make sure the version number (3.4) is correct. To check your version, run this in Python: import sys print(sys.version) PyScripter If you're using PyScripter then follow the installation instructions above. If you're having problems appending to the path, you can try escaping the path: sys.path.append(\"E:\\\\PYLIB\") - putting double slashes might fix the issue. Alternatively, you can use the PyScripter menus: Put appJar in a folder - in this case it's on the Desktop Click Tools -> Python Path... Either type or navigate to the folder containing appJar Press Add , followed by OK NB. You will have to do this every time you run PyScripter, so it's better to get appJar installed properly if you can. PortablePython If you are using PortablePython then you simply need to drop the appJar folder into the Lib folder of the PortablePython installation.","title":"Installation"},{"location":"Install/#set-up-instructions","text":"appJar was designed for use in schools - it therefore doesn't require any kind of special installation . Instead, just DOWNLOAD the ZIP file, unzip, and go - just put the folder in the right place .","title":"Set-up Instructions"},{"location":"Install/#pip-installation","text":"However, if you can install python packages - we support that too! pip3 install appjar - this will download & install appJar ready for python 3. pip3 install appjar --upgrade - this will upgrade appJar to the latest version. NB. If you're on linux/Mac you might need to use sudo: sudo pip3 install appjar # import the appJar library from appJar import gui","title":"Pip Installation"},{"location":"Install/#single-user-set-up","text":"If you can't/don't want to install using pip, simply: DOWNLOAD appjar and unzip it. Put the appJar folder in your code folder , and you're done! # import the appJar library from appJar import gui (As long as it's in the same folder as your code, it'll work...)","title":"Single-user Set-up"},{"location":"Install/#linux","text":"If you're on Linux you might be able to make this even simpler. You might have a site-packages folder, that is already in your path. In this case, put the appJar folder in ~/.local/lib/python3.x/site-packages/ where 3.x is the version of python that you use.","title":"Linux"},{"location":"Install/#multi-user-set-up","text":"If you're trying to install appJar in a school, everyone can download their own copy ( see above ), or: Put the appJar folder in a shared location (eg. a folder on a network drive): E:\\PYLIB Then have pupils include the following 2-lines at the start of their code: # add the appJar folder to your PATH import sys sys.path.append(\"E:\\PYLIB\") # import the appJar library from appJar import gui","title":"Multi-user Set-up"},{"location":"Install/#advanced-set-up","text":"If you've got friendly technicians, you can even avoid having to always add appJar to your path...","title":"Advanced Set-up"},{"location":"Install/#windows","text":"Create an environment variable, which will mean E:\\PYLIB is always in your path . Open Control Panel Navigate to System -> Advanced System Settings Click the Advanced tab Under System variables , click the New.. button Set the Variable name: to be PYTHONPATH Set the Variable value: as the folder you put appJar in (eg. \"E:\\PYLIB\") Press OK , and you're done! Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Windows"},{"location":"Install/#linux-raspberry-pi-macos","text":"If you're running python from a terminal: Type the following: echo 'export PYTHONPATH=\"${PYTHONPATH}:~/Documents/PYLIB\"' >> ~/.bashrc Reopen the terminal (or type source ~/.bashrc ), and you're done! NB. Change ~/Documents/PYLIB to the folder where the appJar folder is located.","title":"Linux (Raspberry Pi) /MacOS"},{"location":"Install/#idle-on-linux-raspberry-pimacos","text":"If you're running python in IDLE, you'll need to add appJar to your site-packages Launch a Terminal Type the following: mkdir -p ~/Library/Python/3.4/lib/python/site-packages cd ~/Library/Python/3.4/lib/python/site-packages echo '~/Documents/PYLIB' > appJar.pth Close the terminal, and you're done! NB. you'll need to make sure the version number (3.4) is correct. To check your version, run this in Python: import sys print(sys.version)","title":"IDLE on Linux (raspberry Pi)/MacOS"},{"location":"Install/#pyscripter","text":"If you're using PyScripter then follow the installation instructions above. If you're having problems appending to the path, you can try escaping the path: sys.path.append(\"E:\\\\PYLIB\") - putting double slashes might fix the issue. Alternatively, you can use the PyScripter menus: Put appJar in a folder - in this case it's on the Desktop Click Tools -> Python Path... Either type or navigate to the folder containing appJar Press Add , followed by OK NB. You will have to do this every time you run PyScripter, so it's better to get appJar installed properly if you can.","title":"PyScripter"},{"location":"Install/#portablepython","text":"If you are using PortablePython then you simply need to drop the appJar folder into the Lib folder of the PortablePython installation.","title":"PortablePython"},{"location":"License/","text":"License This project has been a labour of love over the last couple of years. When confronted with the difficulty both pupils and teachers were having creating simple GUIs with Python, I started out trying to put together a few helper functions to make life simpler. It's obviously grown a bit since then, and has become fairly functional! appJar is released under the Apache License 2.0 So, you're free to use it, modify it & redistribute it, as long as you acknowledge my copyright, and aren't trying to make money out of it... Copyright 2015-2017 Richard Jarvis Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"License/#license","text":"This project has been a labour of love over the last couple of years. When confronted with the difficulty both pupils and teachers were having creating simple GUIs with Python, I started out trying to put together a few helper functions to make life simpler. It's obviously grown a bit since then, and has become fairly functional! appJar is released under the Apache License 2.0 So, you're free to use it, modify it & redistribute it, as long as you acknowledge my copyright, and aren't trying to make money out of it... Copyright 2015-2017 Richard Jarvis Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"Support/","text":"Support This is an open source project, freely available on GitHub . Click: Issue to raise an issue. The code on GitHub will always be the most up-to-date. If you want the latest fixes & enhancements - try out the development branch . If you want to update your existing code, just replace the appjar.py file Zip files are available to download from the releases folder","title":"Support"},{"location":"Support/#support","text":"This is an open source project, freely available on GitHub . Click: Issue to raise an issue. The code on GitHub will always be the most up-to-date. If you want the latest fixes & enhancements - try out the development branch . If you want to update your existing code, just replace the appjar.py file Zip files are available to download from the releases folder","title":"Support"},{"location":"Thanks/","text":"Thanks to: Helpful Resources http://effbot.org/tkinterbook/ - The GURU of all things tkinter & Python http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html - another great resource http://tkinter.unpythonic.net/wiki/FrontPage - another good resource Incorporated Libraries https://github.com/drj11/pypng - supplies basic PNG support https://bitbucket.org/hokaze/tkinter-png - allows PNGs to be treated as PhotoImages https://github.com/sullerandras/nanojpeg-python - provides BASIC jpeg support http://tkinter.unpythonic.net/wiki/ToolTip - provides ToolTips https://github.com/petasis/tkdnd - provides Drag'n Drop support MicroBit Emulator Widget - Ben Goodwin Icons Credit to www.interactivemania.com for the icons - warning malware... Documentation http://www.mkdocs.org - used to generate this documentation http://lab.hakim.se/reveal-js/ - used to generate the slides Development https://travis-ci.org - used to perform i& monitor unit testing https://coveralls.io - used to monitor how good the testing is https://codeclimate.com - used to check quality of code","title":"Acknowledgements"},{"location":"Thanks/#thanks-to","text":"","title":"Thanks to:"},{"location":"Thanks/#helpful-resources","text":"http://effbot.org/tkinterbook/ - The GURU of all things tkinter & Python http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html - another great resource http://tkinter.unpythonic.net/wiki/FrontPage - another good resource","title":"Helpful Resources"},{"location":"Thanks/#incorporated-libraries","text":"https://github.com/drj11/pypng - supplies basic PNG support https://bitbucket.org/hokaze/tkinter-png - allows PNGs to be treated as PhotoImages https://github.com/sullerandras/nanojpeg-python - provides BASIC jpeg support http://tkinter.unpythonic.net/wiki/ToolTip - provides ToolTips https://github.com/petasis/tkdnd - provides Drag'n Drop support MicroBit Emulator Widget - Ben Goodwin","title":"Incorporated Libraries"},{"location":"Thanks/#icons","text":"Credit to www.interactivemania.com for the icons - warning malware...","title":"Icons"},{"location":"Thanks/#documentation","text":"http://www.mkdocs.org - used to generate this documentation http://lab.hakim.se/reveal-js/ - used to generate the slides","title":"Documentation"},{"location":"Thanks/#development","text":"https://travis-ci.org - used to perform i& monitor unit testing https://coveralls.io - used to monitor how good the testing is https://codeclimate.com - used to check quality of code","title":"Development"},{"location":"advertising/","text":"Advertising The only direct cost incurred through creating/maintaining appJar is the domain name registration. However, hundreds of hours have been invested into coding and documenting the project. So, as of version 0.90, some advertising has been introduced to the documentation site, to help keep the project running. I've worked hard to make this as unobtrusive as possible - an ad in the footer, and one or two inline ads in the longer pages. If you have some kind of ad blocker running, you won't see the ads, although an empty ad block might appear. Supporting appJar If you'd like to help support appJar, please consider adding us to your ad blocker's whitelist. Here's how to do it in the ad blockers I use: AdBlock (Mac/Safari) Click the AdBlock icon -> Options -> Customize. Click Show ads on a webpage or domain , type http://appjar.info , and press OK uBlock (Raspberry Pi/Chromium) Right-click the uBlock icon (top right) -> Options -> Whitelist Type appjar.info , and press Apply changes","title":"Advertising"},{"location":"advertising/#advertising","text":"The only direct cost incurred through creating/maintaining appJar is the domain name registration. However, hundreds of hours have been invested into coding and documenting the project. So, as of version 0.90, some advertising has been introduced to the documentation site, to help keep the project running. I've worked hard to make this as unobtrusive as possible - an ad in the footer, and one or two inline ads in the longer pages. If you have some kind of ad blocker running, you won't see the ads, although an empty ad block might appear.","title":"Advertising"},{"location":"advertising/#supporting-appjar","text":"If you'd like to help support appJar, please consider adding us to your ad blocker's whitelist. Here's how to do it in the ad blockers I use: AdBlock (Mac/Safari) Click the AdBlock icon -> Options -> Customize. Click Show ads on a webpage or domain , type http://appjar.info , and press OK uBlock (Raspberry Pi/Chromium) Right-click the uBlock icon (top right) -> Options -> Whitelist Type appjar.info , and press Apply changes","title":"Supporting appJar"},{"location":"algorithms/","text":"Algorithms Below are some comparisons of how to achieve the same thing in a flowchart, pseudocode & Python. This site was originally written using AQA suggested pseudocode, but will be updated to include OCR recommendations. It will aso be extended, to include a lot more examples. Comparison Topic FlowChart PseudoCode Python Assigning a variable a \u2190 5 a = 5 Input a \u2190 USERINPUT a = input() Output OUTPUT a print(a) Subtraction a \u2190 b - c a = b - c Selection: Greater than IF a > b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a > b: \u2003funcA() else: \u2003funcB() Selection: Less than IF a < b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a < b: \u2003funcA() else: \u2003funcB() Selection: Equal to IF a = b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a == b: \u2003funcA() else: \u2003funcB() Selection: Not equal to IF a \u2260 b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a != b: \u2003funcA() else: \u2003funcB() Iteration: While loop WHILE a \u2260 b \u2003OUTPUT b \u2003a \u2190 USERINPUT ENDWHILE while a != b: \u2003print(b) \u2003a = input() Iteration: For loop (count-up) FOR i \u2190 0 TO 9 \u2003OUTPUT i ENDFOR for i in range(10): \u2003print(i) Iteration: For loop (count-down) FOR i \u2190 10 TO 1 \u2003OUTPUT i ENDFOR for i in range(10, 0, -1): \u2003print(i) Links Some useful Pseudocode links. PseudoCode CheatSheet PseudoWars AQA PseudoCode Guidelines","title":"Algorithms"},{"location":"algorithms/#algorithms","text":"Below are some comparisons of how to achieve the same thing in a flowchart, pseudocode & Python. This site was originally written using AQA suggested pseudocode, but will be updated to include OCR recommendations. It will aso be extended, to include a lot more examples.","title":"Algorithms"},{"location":"algorithms/#comparison","text":"Topic FlowChart PseudoCode Python Assigning a variable a \u2190 5 a = 5 Input a \u2190 USERINPUT a = input() Output OUTPUT a print(a) Subtraction a \u2190 b - c a = b - c Selection: Greater than IF a > b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a > b: \u2003funcA() else: \u2003funcB() Selection: Less than IF a < b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a < b: \u2003funcA() else: \u2003funcB() Selection: Equal to IF a = b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a == b: \u2003funcA() else: \u2003funcB() Selection: Not equal to IF a \u2260 b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a != b: \u2003funcA() else: \u2003funcB() Iteration: While loop WHILE a \u2260 b \u2003OUTPUT b \u2003a \u2190 USERINPUT ENDWHILE while a != b: \u2003print(b) \u2003a = input() Iteration: For loop (count-up) FOR i \u2190 0 TO 9 \u2003OUTPUT i ENDFOR for i in range(10): \u2003print(i) Iteration: For loop (count-down) FOR i \u2190 10 TO 1 \u2003OUTPUT i ENDFOR for i in range(10, 0, -1): \u2003print(i)","title":"Comparison"},{"location":"algorithms/#links","text":"Some useful Pseudocode links. PseudoCode CheatSheet PseudoWars AQA PseudoCode Guidelines","title":"Links"},{"location":"algorithms_lmc/","text":"Algorithms Below are some helpful comparisons between different ways of acheiving the same result, starting from design, move on to high-level language, into low-level language and finally machine code. This guide was originally intended to help with LMC implementation, but is also useful for general python deisgn/coding. Comparison Topic FlowChart PseudoCode Python Assembler Machine Code Assigning a variable a \u2190 5 a=5 a DAT 5 Input a \u2190 USERINPUT a=input() INP STA a 901 3xx Output a \u2190 5 a=5 LDA a OUT 5xx 902 Subtraction a \u2190 b - c a=b-c LDA b SUB c STA a 5xx 2xx 3xx Selection: Greater than IF a > b THEN \u2003funcA() ELSE \u2003funcB() ENDIF a > b: \u2003funcA() else: \u2003funcB() LDA b SUB a BRP funcA BRA funB 5xx 2xx 8xx 6xx Selection: Less than IF a < b THEN \u2003funcA() ELSE \u2003funcB() ENDIF a < b: \u2003funcA() else: \u2003funcB() LDA a SUB b BRP funcB BRA funcA 5xx 2xx 8xx 6xx Selection: Equal to IF a = b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a == b: \u2003funcA() else: \u2003funcB() LDA a SUB b BRZ funcA BRA funcB 5xx 2xx 7xx 6xx Selection: Not equal to IF a \u2260 b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a \u2260 b: \u2003funcA() else: \u2003funcB() LDA a SUB b BRZ funcB BRA funcA 5xx 2xx 7xx 6xx Iteration: While loop WHILE a \u2260 b \u2003OUTPUT b \u2003a \u2190 USERINPUT ENDWHILE while a != b: \u2003print(b) \u2003a = input() while LDA a \u2003\u2003SUB b \u2003\u2003BRZ endwhile \u2003\u2003LDA b \u2003\u2003OUT \u2003\u2003INPU \u2003\u2003STA a \u2003\u2003BRA while endwhile HLT a DAT 0 b DAT 5 5xx 2xx 7xx 5xx 902 901 3xx 6xx 000 Iteration: For loop (count-up) FOR i \u2190 0 TO 9 \u2003OUTPUT i ENDFOR for i in range(10): \u2003print(i) for LDA i \u2003\u2003OUT \u2003\u2003ADD one \u2003\u2003STA i \u2003\u2003SUB ten \u2003\u2003BRZ endfor \u2003\u2003BRA for endfor HLT i DAT 0 one DAT 1 ten DAT 10 5xx 902 1xx 3xx 2xx 7xx 6xx 000 Iteration: For loop (count-down) FOR 1 \u2190 10 TO 1 \u2003OUTPUT i ENDFOR for i in range(10, 0, -1): \u2003print(i) for LDA i \u2003\u2003OUT \u2003\u2003SUB one \u2003\u2003STA i \u2003\u2003BRZ endfor \u2003\u2003BRA for endfor HLT 1 DAT 10 one DAT 1 5xx 902 2xx 3xx 7xx 6xx 000 Links Some useful links for both LMC & Pseudocode. Online LMC LMC Explanation PseudoCode CheatSheet PseudoWars AQA PseudoCode Guidelines LMC Instructions Simple explanations for the various LMC commands. Instructions Mneumonic Machine Code Explanation Add ADD 1xx Adds the contents of memory xx to the ACCUMULATOR . Subtract SUB 2xx Subtracts the contents of memory xx from the ACCUMULATOR . Store STA 3xx Copies the contents of the ACCUMULATOR to memory xx. Load LDA 5xx Copies the contents of memory xx to the ACCUMULATOR . Branch ALWAYS BRA 6xx Always set the program counter to xx. The program continues from the instruction at memory xx. Branch if ZERO BRZ 7xx Set the program counter to xx only of the ACCUMULATOR is zero. Branch if POSITIVE BRP 8xx Set the program counter to xx only if the ACCUMULATOR is zero or positive (greater than zero). Input INP 901 Copy the contents of the INBOX to the ACCUMULATOR . Output OUT 902 Copy the contents of the ACCUMULATOR to the OUTBOX . Define Variable DAT Reserves this memory slot as a variable, settinmg its contents to the value specified. Halt HLT 000 Halts execution of the program.","title":"Algorithms lmc"},{"location":"algorithms_lmc/#algorithms","text":"Below are some helpful comparisons between different ways of acheiving the same result, starting from design, move on to high-level language, into low-level language and finally machine code. This guide was originally intended to help with LMC implementation, but is also useful for general python deisgn/coding.","title":"Algorithms"},{"location":"algorithms_lmc/#comparison","text":"Topic FlowChart PseudoCode Python Assembler Machine Code Assigning a variable a \u2190 5 a=5 a DAT 5 Input a \u2190 USERINPUT a=input() INP STA a 901 3xx Output a \u2190 5 a=5 LDA a OUT 5xx 902 Subtraction a \u2190 b - c a=b-c LDA b SUB c STA a 5xx 2xx 3xx Selection: Greater than IF a > b THEN \u2003funcA() ELSE \u2003funcB() ENDIF a > b: \u2003funcA() else: \u2003funcB() LDA b SUB a BRP funcA BRA funB 5xx 2xx 8xx 6xx Selection: Less than IF a < b THEN \u2003funcA() ELSE \u2003funcB() ENDIF a < b: \u2003funcA() else: \u2003funcB() LDA a SUB b BRP funcB BRA funcA 5xx 2xx 8xx 6xx Selection: Equal to IF a = b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a == b: \u2003funcA() else: \u2003funcB() LDA a SUB b BRZ funcA BRA funcB 5xx 2xx 7xx 6xx Selection: Not equal to IF a \u2260 b THEN \u2003funcA() ELSE \u2003funcB() ENDIF if a \u2260 b: \u2003funcA() else: \u2003funcB() LDA a SUB b BRZ funcB BRA funcA 5xx 2xx 7xx 6xx Iteration: While loop WHILE a \u2260 b \u2003OUTPUT b \u2003a \u2190 USERINPUT ENDWHILE while a != b: \u2003print(b) \u2003a = input() while LDA a \u2003\u2003SUB b \u2003\u2003BRZ endwhile \u2003\u2003LDA b \u2003\u2003OUT \u2003\u2003INPU \u2003\u2003STA a \u2003\u2003BRA while endwhile HLT a DAT 0 b DAT 5 5xx 2xx 7xx 5xx 902 901 3xx 6xx 000 Iteration: For loop (count-up) FOR i \u2190 0 TO 9 \u2003OUTPUT i ENDFOR for i in range(10): \u2003print(i) for LDA i \u2003\u2003OUT \u2003\u2003ADD one \u2003\u2003STA i \u2003\u2003SUB ten \u2003\u2003BRZ endfor \u2003\u2003BRA for endfor HLT i DAT 0 one DAT 1 ten DAT 10 5xx 902 1xx 3xx 2xx 7xx 6xx 000 Iteration: For loop (count-down) FOR 1 \u2190 10 TO 1 \u2003OUTPUT i ENDFOR for i in range(10, 0, -1): \u2003print(i) for LDA i \u2003\u2003OUT \u2003\u2003SUB one \u2003\u2003STA i \u2003\u2003BRZ endfor \u2003\u2003BRA for endfor HLT 1 DAT 10 one DAT 1 5xx 902 2xx 3xx 7xx 6xx 000","title":"Comparison"},{"location":"algorithms_lmc/#links","text":"Some useful links for both LMC & Pseudocode. Online LMC LMC Explanation PseudoCode CheatSheet PseudoWars AQA PseudoCode Guidelines","title":"Links"},{"location":"algorithms_lmc/#lmc-instructions","text":"Simple explanations for the various LMC commands. Instructions Mneumonic Machine Code Explanation Add ADD 1xx Adds the contents of memory xx to the ACCUMULATOR . Subtract SUB 2xx Subtracts the contents of memory xx from the ACCUMULATOR . Store STA 3xx Copies the contents of the ACCUMULATOR to memory xx. Load LDA 5xx Copies the contents of memory xx to the ACCUMULATOR . Branch ALWAYS BRA 6xx Always set the program counter to xx. The program continues from the instruction at memory xx. Branch if ZERO BRZ 7xx Set the program counter to xx only of the ACCUMULATOR is zero. Branch if POSITIVE BRP 8xx Set the program counter to xx only if the ACCUMULATOR is zero or positive (greater than zero). Input INP 901 Copy the contents of the INBOX to the ACCUMULATOR . Output OUT 902 Copy the contents of the ACCUMULATOR to the OUTBOX . Define Variable DAT Reserves this memory slot as a variable, settinmg its contents to the value specified. Halt HLT 000 Halts execution of the program.","title":"LMC Instructions"},{"location":"appJarLimitations/","text":"Limitations There are some things that we don't do well, or that just don't work. These are usually caused by limitations in the underlying tkinter, and may be specific to a particular platform. General Limitations: Animated GIFs - appJar has its own way of animating GIFs, if animated GIFs don't have complete frames, the animation will break. Image Backgrounds - setting an image as a background doesn't work well - most widgets don't have their own transparency. ttk - appJar was never intended to work with ttk, but due to popular demand, we've tried to build it in, but there are still issues. Platform Limitations: appJar has been designed to work the same on the three major platforms: Windows, Mac & Linux. However, not all features are available on all platforms. Linux: Transparency isn't supported app Icons aren't supported Audio doesn't work - relies on WinSound Mac: app Icons aren't supported Audio doesn't work - relies on WinSound Buttons don't support background colours and changing the height Tickable OptionBoxes don't work Pasting some special characters can crash appJar Inertial scrolling can crash appJar Windows: n/a Third Party Limitations MatPlotLib does work with appJar, but can be fiddly. If you want to use 3rd party libraries with MatPlotLib, you should import them after the appJar GUI has been created: from numpy import sin, pi, arange import random from appJar import gui with gui() as app: x = arange(0.0, 3.0, 0.01) y = sin(random.randint(1,10) * pi * x) axes = app.addPlot(\"p1\", x, y) axes.set_title(\"Click somewhere on a line.\\nRight-click to deselect.\") axes.legend(['The curve']) axes.set_xlabel(\"X Axes\") axes.set_ylabel(\"Y Axes\") # only import this library once the GUI has been created import mplcursors mplcursors.cursor(axes)","title":"Limitations"},{"location":"appJarLimitations/#limitations","text":"There are some things that we don't do well, or that just don't work. These are usually caused by limitations in the underlying tkinter, and may be specific to a particular platform.","title":"Limitations"},{"location":"appJarLimitations/#general-limitations","text":"Animated GIFs - appJar has its own way of animating GIFs, if animated GIFs don't have complete frames, the animation will break. Image Backgrounds - setting an image as a background doesn't work well - most widgets don't have their own transparency. ttk - appJar was never intended to work with ttk, but due to popular demand, we've tried to build it in, but there are still issues.","title":"General Limitations:"},{"location":"appJarLimitations/#platform-limitations","text":"appJar has been designed to work the same on the three major platforms: Windows, Mac & Linux. However, not all features are available on all platforms.","title":"Platform Limitations:"},{"location":"appJarLimitations/#linux","text":"Transparency isn't supported app Icons aren't supported Audio doesn't work - relies on WinSound","title":"Linux:"},{"location":"appJarLimitations/#mac","text":"app Icons aren't supported Audio doesn't work - relies on WinSound Buttons don't support background colours and changing the height Tickable OptionBoxes don't work Pasting some special characters can crash appJar Inertial scrolling can crash appJar","title":"Mac:"},{"location":"appJarLimitations/#windows","text":"n/a","title":"Windows:"},{"location":"appJarLimitations/#third-party-limitations","text":"MatPlotLib does work with appJar, but can be fiddly. If you want to use 3rd party libraries with MatPlotLib, you should import them after the appJar GUI has been created: from numpy import sin, pi, arange import random from appJar import gui with gui() as app: x = arange(0.0, 3.0, 0.01) y = sin(random.randint(1,10) * pi * x) axes = app.addPlot(\"p1\", x, y) axes.set_title(\"Click somewhere on a line.\\nRight-click to deselect.\") axes.legend(['The curve']) axes.set_xlabel(\"X Axes\") axes.set_ylabel(\"Y Axes\") # only import this library once the GUI has been created import mplcursors mplcursors.cursor(axes)","title":"Third Party Limitations"},{"location":"clipboard/","text":"Clipboard If you need to access the system clipboard, the following commands are available: .topLevel.clipboard_get() This will return the contents of the clipboard as a string. .topLevel.clipboard_append(\"hello world\") This will append the specified text to the clipboard. .topLevel.clipboard_clear() This will clear all text form the clipboard.","title":"Clipboard"},{"location":"clipboard/#clipboard","text":"If you need to access the system clipboard, the following commands are available: .topLevel.clipboard_get() This will return the contents of the clipboard as a string. .topLevel.clipboard_append(\"hello world\") This will append the specified text to the clipboard. .topLevel.clipboard_clear() This will clear all text form the clipboard.","title":"Clipboard"},{"location":"contributing/","text":"Contributing We are always happy to receive additions/updates/fixes to the library - simply submit a Pull Request. The key focusses of the project are that we have good, up-to-date documentation and reliable code. Therefore, in order to add new features, you should be looking to include them in both the documentation and the test suite. Testing We use Travis and Coveralls to ensure the code works. In order to ensure coverage, every new function that is added should be included in /tests/widget_test.py There are lots of functions in there that simply add widgets to the test GUI, at a minimum this ensures they are free of basic syntax errors. If the widget is interactive or has setters & getters, then it's useful to include a set followed by a get with an assert: app.addLabel(\"l1\", \"Message\") assert app.getLabel(\"l1\") == \"Message\" app.setLabel(\"l1\", \"New Message\") assert app.getLabel(\"l1\") == \"New Message\" app.clearLabel(\"l1\") assert app.getLabel(\"l1\") == \"\" If a function call (add/set/clear) were to fail, the test would fail. And if the assert doesn't match, the test will fail. Documentation We've used MkDocs hosted on GitHub Pages to build this site. The pages are written in Markdown - there are lots of sites out there giving advice... The process is fairly straightforward: Identify the page you need to modify - look at the URL, the folder will be the file name Find the .md file in /docs/mkdocs/docs Add the relevant information","title":"Contributing"},{"location":"contributing/#contributing","text":"We are always happy to receive additions/updates/fixes to the library - simply submit a Pull Request. The key focusses of the project are that we have good, up-to-date documentation and reliable code. Therefore, in order to add new features, you should be looking to include them in both the documentation and the test suite.","title":"Contributing"},{"location":"contributing/#testing","text":"We use Travis and Coveralls to ensure the code works. In order to ensure coverage, every new function that is added should be included in /tests/widget_test.py There are lots of functions in there that simply add widgets to the test GUI, at a minimum this ensures they are free of basic syntax errors. If the widget is interactive or has setters & getters, then it's useful to include a set followed by a get with an assert: app.addLabel(\"l1\", \"Message\") assert app.getLabel(\"l1\") == \"Message\" app.setLabel(\"l1\", \"New Message\") assert app.getLabel(\"l1\") == \"New Message\" app.clearLabel(\"l1\") assert app.getLabel(\"l1\") == \"\" If a function call (add/set/clear) were to fail, the test would fail. And if the assert doesn't match, the test will fail.","title":"Testing"},{"location":"contributing/#documentation","text":"We've used MkDocs hosted on GitHub Pages to build this site. The pages are written in Markdown - there are lots of sites out there giving advice... The process is fairly straightforward: Identify the page you need to modify - look at the URL, the folder will be the file name Find the .md file in /docs/mkdocs/docs Add the relevant information","title":"Documentation"},{"location":"gitGuide/","text":"Git Guide Below are some useful commands for using git, GitHub & PyPI from the command line. Simple Set-up Git provides local version control - allowing you to keep backups of previous versions of your code. It's really easy to get started: git init - will initialise Git for your current project, git add [filename] - will queue a new file or changes to an existing file to be saved git commit - will save the new versions of the files you've added - with a message describing the changes. That's it, you now have full version control over your code. It works in Windows, OSX or Linux and is supported by most popular IDEs (including Visual Studio). You can even take it a step further, by sharing your code on the Web. GitHub provides a free place to sink & share your code. It will also allow other people to view & contribute to your code. You first need to create an account on GitHub, and then a new repo : Then copy your repo's address, and add it to your local git account: git remote add origin [web_address] - link your local Git repo to a GitHub repo. Then, once you've committed local changes, you can push them to GitHub: git push - send your local changes to your online GitHub repository. Setting Up git init Creates a new local git repository, in the current directory git remote add origin [URI] This will link your newly created, local repository, with the one specified on GitHub git clone [URI] This will copy a git repository, from GitHub, to the current directory Updating git remote update This will update your log of remote changes git pull This will get any changes from GitHub, and update your local copy Checking git status This will compare your local copy, with the copy on GitHub, and tell you any differences. Adding git add [file] Add a new file to your local repository git add . Add any changes you've made to your local repository git commit -m \"message here\" Commit anything you've added to your local repository git commit -a -m \"message here\" Combines add and commit Syncing all changes to your local repository Undoing git checkout XXX This will restore a file to the latest version in Git. Pushing git push Pushes all changes you've added & committed locally, to GitHub Branching & Merging Branching is useful to allow you to develop a new feature, without affecting the main branch. That way, your main branch remains untouched, until you are ready to add in your new feature. This is useful, as it means the main branch always matches what is currently released, and it also lets you release emergency fixes on the main branch, without having to include whatever new feature is currently being worked on. git branch List all the branches in your repo git checkout <branch> Switch to the named <branch> git branch <branch> Create a new branch called <branch> git checkout -b <new-branch> Create and switch to a <new-branch> git branch -d <branch> Delete the branch called <branch> Once your branch is complete, ie. you finished your new feature and are ready to add it to your main branch for a new release. You simply merge your feature branch back into the main branch. First you have to checkout the master branch: git checkout master followed by a git pull to get any missing fixes. Then, there are two options: Merge in your feature branch: git merge <branch> Or pull down your feature branch: git pull origin <branch> Once you have added your feature branch into the main branch, you then push it all back again: git push You now have a new version - so you should tag it with a version number Tagging git tag -a vXXX -m \"Tag description git push origin vXXX This tags the current build in git Then pushes it to GitHub PyPI python setup.py register -r pypitest This will register the package with PyPI Test python setup.py sdist upload -r pypitest This will upload the stuff to PyPI Test pip install --verbose --index-url https://testpypi.python.org/pypi appJar This will attempt to install from the PyPI test server Egg Files Egg files allow appJar to be distributed and used as a single file. The following setup.py file should be put into a folder, along with an appjar folder: from setuptools import setup, find_packages setup( name = \"appJar\", version = \"0.93\", packages = find_packages() ) It should then be run with: python3 setup.py bdist_egg The egg file will be placed in the dist folder. This can then be used with the following code: import sys sys.path.append(\"appJar-0.93-py3.6.egg\") Egg files with Mu Using egg files makes it easy to use appJar with Mu. Put the egg file in your mu_code folder, click the configuration cog (bottom left), and under Python3 Environment , set a variable PYTHONPATH=appJar-0.93-py3.6.egg .","title":"Git & PyPi"},{"location":"gitGuide/#git-guide","text":"Below are some useful commands for using git, GitHub & PyPI from the command line.","title":"Git Guide"},{"location":"gitGuide/#simple-set-up","text":"Git provides local version control - allowing you to keep backups of previous versions of your code. It's really easy to get started: git init - will initialise Git for your current project, git add [filename] - will queue a new file or changes to an existing file to be saved git commit - will save the new versions of the files you've added - with a message describing the changes. That's it, you now have full version control over your code. It works in Windows, OSX or Linux and is supported by most popular IDEs (including Visual Studio). You can even take it a step further, by sharing your code on the Web. GitHub provides a free place to sink & share your code. It will also allow other people to view & contribute to your code. You first need to create an account on GitHub, and then a new repo : Then copy your repo's address, and add it to your local git account: git remote add origin [web_address] - link your local Git repo to a GitHub repo. Then, once you've committed local changes, you can push them to GitHub: git push - send your local changes to your online GitHub repository.","title":"Simple Set-up"},{"location":"gitGuide/#setting-up","text":"git init Creates a new local git repository, in the current directory git remote add origin [URI] This will link your newly created, local repository, with the one specified on GitHub git clone [URI] This will copy a git repository, from GitHub, to the current directory","title":"Setting Up"},{"location":"gitGuide/#updating","text":"git remote update This will update your log of remote changes git pull This will get any changes from GitHub, and update your local copy","title":"Updating"},{"location":"gitGuide/#checking","text":"git status This will compare your local copy, with the copy on GitHub, and tell you any differences.","title":"Checking"},{"location":"gitGuide/#adding","text":"git add [file] Add a new file to your local repository git add . Add any changes you've made to your local repository git commit -m \"message here\" Commit anything you've added to your local repository git commit -a -m \"message here\" Combines add and commit Syncing all changes to your local repository","title":"Adding"},{"location":"gitGuide/#undoing","text":"git checkout XXX This will restore a file to the latest version in Git.","title":"Undoing"},{"location":"gitGuide/#pushing","text":"git push Pushes all changes you've added & committed locally, to GitHub","title":"Pushing"},{"location":"gitGuide/#branching-merging","text":"Branching is useful to allow you to develop a new feature, without affecting the main branch. That way, your main branch remains untouched, until you are ready to add in your new feature. This is useful, as it means the main branch always matches what is currently released, and it also lets you release emergency fixes on the main branch, without having to include whatever new feature is currently being worked on. git branch List all the branches in your repo git checkout <branch> Switch to the named <branch> git branch <branch> Create a new branch called <branch> git checkout -b <new-branch> Create and switch to a <new-branch> git branch -d <branch> Delete the branch called <branch> Once your branch is complete, ie. you finished your new feature and are ready to add it to your main branch for a new release. You simply merge your feature branch back into the main branch. First you have to checkout the master branch: git checkout master followed by a git pull to get any missing fixes. Then, there are two options: Merge in your feature branch: git merge <branch> Or pull down your feature branch: git pull origin <branch> Once you have added your feature branch into the main branch, you then push it all back again: git push You now have a new version - so you should tag it with a version number","title":"Branching &amp; Merging"},{"location":"gitGuide/#tagging","text":"git tag -a vXXX -m \"Tag description git push origin vXXX This tags the current build in git Then pushes it to GitHub","title":"Tagging"},{"location":"gitGuide/#pypi","text":"python setup.py register -r pypitest This will register the package with PyPI Test python setup.py sdist upload -r pypitest This will upload the stuff to PyPI Test pip install --verbose --index-url https://testpypi.python.org/pypi appJar This will attempt to install from the PyPI test server","title":"PyPI"},{"location":"gitGuide/#egg-files","text":"Egg files allow appJar to be distributed and used as a single file. The following setup.py file should be put into a folder, along with an appjar folder: from setuptools import setup, find_packages setup( name = \"appJar\", version = \"0.93\", packages = find_packages() ) It should then be run with: python3 setup.py bdist_egg The egg file will be placed in the dist folder. This can then be used with the following code: import sys sys.path.append(\"appJar-0.93-py3.6.egg\")","title":"Egg Files"},{"location":"gitGuide/#egg-files-with-mu","text":"Using egg files makes it easy to use appJar with Mu. Put the egg file in your mu_code folder, click the configuration cog (bottom left), and under Python3 Environment , set a variable PYTHONPATH=appJar-0.93-py3.6.egg .","title":"Egg files with Mu"},{"location":"gpio/","text":"","title":"Gpio"},{"location":"guiProgramming/","text":"The 4 basic precepts of GUI programming: Specify how you want the UI to look Decide what you want the UI to do Link the looking with the doing Write code that waits for user input Looks - positioning widgets on the screen Actions - code event handlers that deal with any user actions (clicking buttons, etc) Linkning - bind event handlers with widgets, requires 3 things: type of event a widget event-handler routine Waiting code - lives in the event loop*, this sees every event that happens in a GUI and ignores most of them. However, if an event is bound to a handler, then the event is passed on Containers vs. Widgets Creaintg GUI objects & associating them with a parent Packing","title":"guiProgramming"},{"location":"guidance/","text":"General Guidance Navigating the Docs The online documentation aims to be as consistant as possible. There are two main sections: Fillings - these are things you can add to the GUI Configuration - these are ways of changing how the GUI looks or operates Fillings These are things you can add to the GUI: Widgets - the various interface elements that can be included in a GUI Images - a specific section on how to manage images in a GUI Sounds - a section on how to get your GUI to make some noise Bars - menubars, statusbars & toolbars that can be added to your GUI Pop-ups - the different pop-ups that can be shown Multiple Windows - information on creating separate windows Splashscreen - a splashscreen to show at loadtime Special Characters - guidance on how to include special characters Beta widgets - some other available widgets, just not quite finished Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Configuration These are ways of changing how the GUI looks or operates: GUI Options - options for configuring general GUI settings Widgets - options for configuring the layout and look & feel of widgets Events - options for delaying actions, making them repeat or run in the background Internationalisation - how to support multiple languages in your GUI Logging - how to turn on/off appJar's logging capabilities Command Line Arguments - hw t use various command line arguments ttk - how to enable ttk support Understanding the Docs When I first started appJar, I didn't really know any Python. I grew up on Pascal & Java, followed by JavaScript & PHP - appjar is therefore all in CamelCase . Also, because of this, the concept of named parameters is also not really used (except in the more recent parts). Again, I learnt programming without this concept, and generally teach programming without this concept. You'll therefore find that sometimes you have to make two-or-three function calls, to achieve something that could be done with one - if I had more named parameters. I've tried to keep function names standardised: .add XXX() - to add something to the GUI .set XXX() - to change something in the GUI .set XXX YYY() - to change some property of something in the GUI .get XXX() - to get something from the GUI When the docs list the parameters available on a function, any with an = means they are optional, with the default being shown. For example: setProperty(title, prop, value=False, callFunction=True) This has two required parameters title & prop - must be set (the title of the Properties group and a specific property ) And two optional parameters value & callFunction - if you don't pass value it will be set to False So, you could simply call: .setProperty(\"Toppings\", \"cheese\") to get rid of cheese. Or, if you want cheese: .setProperty(\"Toppings\", \"cheese\", True) . You don't need to name the parameters, as they are always listed in the required order. However, if you do want to name your parameters, feel free: .setProperty(\"Toppings\", \"cheese\", callFunction=False) In fact, it can make your life much easier: .addLabel(\"l1\", \"Main Title\", colspan=5) - saves you having to type in the row or column values. Deprecation appjar has been going so long, that some of the early decisions have turned out to be bad ones... Some functions have now been deprecated - you can still use them, but appJar will warn you that you should be using something else. Beta Code Some elements of appjar are in beta . This means you can use them, and they generally work - but you may come across issues or they may change in the future. Generally, the beta code works pretty well - it wouldn't be included if it didn't. But, equally, we know its not perfect - drag'n drop will keep growing & improving, and the table needs some work. So, please use them, and let us know any issues or improvements you'd like...","title":"Guidance"},{"location":"guidance/#general-guidance","text":"","title":"General Guidance"},{"location":"guidance/#navigating-the-docs","text":"The online documentation aims to be as consistant as possible. There are two main sections: Fillings - these are things you can add to the GUI Configuration - these are ways of changing how the GUI looks or operates","title":"Navigating the Docs"},{"location":"guidance/#fillings","text":"These are things you can add to the GUI: Widgets - the various interface elements that can be included in a GUI Images - a specific section on how to manage images in a GUI Sounds - a section on how to get your GUI to make some noise Bars - menubars, statusbars & toolbars that can be added to your GUI Pop-ups - the different pop-ups that can be shown Multiple Windows - information on creating separate windows Splashscreen - a splashscreen to show at loadtime Special Characters - guidance on how to include special characters Beta widgets - some other available widgets, just not quite finished Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Fillings"},{"location":"guidance/#configuration","text":"These are ways of changing how the GUI looks or operates: GUI Options - options for configuring general GUI settings Widgets - options for configuring the layout and look & feel of widgets Events - options for delaying actions, making them repeat or run in the background Internationalisation - how to support multiple languages in your GUI Logging - how to turn on/off appJar's logging capabilities Command Line Arguments - hw t use various command line arguments ttk - how to enable ttk support","title":"Configuration"},{"location":"guidance/#understanding-the-docs","text":"When I first started appJar, I didn't really know any Python. I grew up on Pascal & Java, followed by JavaScript & PHP - appjar is therefore all in CamelCase . Also, because of this, the concept of named parameters is also not really used (except in the more recent parts). Again, I learnt programming without this concept, and generally teach programming without this concept. You'll therefore find that sometimes you have to make two-or-three function calls, to achieve something that could be done with one - if I had more named parameters. I've tried to keep function names standardised: .add XXX() - to add something to the GUI .set XXX() - to change something in the GUI .set XXX YYY() - to change some property of something in the GUI .get XXX() - to get something from the GUI When the docs list the parameters available on a function, any with an = means they are optional, with the default being shown. For example: setProperty(title, prop, value=False, callFunction=True) This has two required parameters title & prop - must be set (the title of the Properties group and a specific property ) And two optional parameters value & callFunction - if you don't pass value it will be set to False So, you could simply call: .setProperty(\"Toppings\", \"cheese\") to get rid of cheese. Or, if you want cheese: .setProperty(\"Toppings\", \"cheese\", True) . You don't need to name the parameters, as they are always listed in the required order. However, if you do want to name your parameters, feel free: .setProperty(\"Toppings\", \"cheese\", callFunction=False) In fact, it can make your life much easier: .addLabel(\"l1\", \"Main Title\", colspan=5) - saves you having to type in the row or column values.","title":"Understanding the Docs"},{"location":"guidance/#deprecation","text":"appjar has been going so long, that some of the early decisions have turned out to be bad ones... Some functions have now been deprecated - you can still use them, but appJar will warn you that you should be using something else.","title":"Deprecation"},{"location":"guidance/#beta-code","text":"Some elements of appjar are in beta . This means you can use them, and they generally work - but you may come across issues or they may change in the future. Generally, the beta code works pretty well - it wouldn't be included if it didn't. But, equally, we know its not perfect - drag'n drop will keep growing & improving, and the table needs some work. So, please use them, and let us know any issues or improvements you'd like...","title":"Beta Code"},{"location":"inputWidgets/","text":"Input Widgets Input widgets are used for capturing user interactions, either by cicking, typing or dragging. They usually provide three functions: ADD - this creates the widget GET - this gets the contents/state of the widget SET - this changes what's in the widget As well as options to change the way they look/act . For each of the above to work, we need to know which widget you are referring to - so every widget gets a unique title . If you want your input widget to have a label, there are some auto-label functions If you wnat to get the contents of all widgets in the GUI as a single dictionary, use: * .getAllInputs(includeEmptyInputs=False) This will return the contents of all input fields as a dictionary. Set includeEmptyInputs to True, if you want to include any empty input fields. Entry Entries are used to capture typed input from the user. They take a single parameter - a title. There are five special-case Entries: NumericEntry - this only allows numbers to be typed in - always returns a float (None if empty). SecretEntry - this will show stars, instead of the letters typed - useful for capturing passwords. AutoEntry - this takes a list of words to provide auto-completion. ValidationEntry - can be set to valid/invalid/waiting - will colour the border green/red/black and show a \u2714/\u2716/\u2605 OpenEntry/SaveEntry/DirectoryEntry - provides a button to select a file/directory and auto-populates the Entry from appJar import gui app=gui() app.addEntry(\"e1\") app.addEntry(\"e2\") app.addEntry(\"e3\") app.addLabelEntry(\"Name\") app.addValidationEntry(\"v1\") app.addFileEntry(\"f1\") app.setEntryDefault(\"e2\", \"Age here\") app.setEntryValid(\"v1\") app.go() Add Entries .addEntry(title) .addNumericEntry(title) .addSecretEntry(title) .addValidationEntry(title) .addOpenEntry(title) .addSaveEntry(title) .addDirectoryEntry(title) .addAutoEntry(title, words) This also takes a words parameter, which must be a list, and is used to populate he drop-down. Each of these will add the specified type of Entry, using the title provided. Set Entries .setEntry(title, text, callFunction=True) This sets the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .setEntryDefault(title, text) This sets a default value to display in an Entry. Once the user starts typing, it will disappear. The text is centered, shown in a light gray font, and will not be returned by .getEntry(title) .setEntryUpperCase(title) & .setEntryLowerCase(title) This will force all text typed into the Entry to be uppercase/lowercase. .setEntryMaxLength(title, maxLength) This will set a maximum length for the specified Entry. Any additional characters typed will be discarded. .setEntryValid(title) & .setEntryInvalid(title) & .setEntryWaitingValidation(title) These will set the relevant status of a Validation Entry (how it looks). (Have a look here for help displaying special characters) .setValidationEntry(title, state=\"valid\") Same as above, set flag to one of valid , invalid or wait . .setValidationEntryLabelBg(title, bg) This allows you to change the colour of the validation label, in a validation entry. .setAutoEntryNumRows(title, rows) This will set the number of rows to display in an AutoEntry. NB. this is limited to the depth of the GUI - if there is no space, then no rows will be displayed. .appendAutoEntry(title, value) This will add the value/list of values to the specified AutoEntry. .removeAutoEntry(title, value) This will remove the value from the specified AutoEntry. .changeAutoEntry(title, value) This will replace all items in the specified AutoEntry with a new list of values. .clearEntry(title, callFunction=True) This will clear the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .clearAllEntries(callFunction=False) This will clear all Entries in the GUI. Set callFunction to be True, if you want to call any associated functions. .setFocus(title) This will put the cursor in the specified Entry, so that the user can start typing without needing to click. Get Entries .getEntry(title) This will return the contents of the specified Entry. NB. numericEntries always return a float. .getAllEntries() This will return the contents of all Entries in the app, as a dictionary. NB. numericEntries always return a float. TextArea Similar to an Entry, but allows you to type text over multiple lines. from appJar import gui app=gui() app.addTextArea(\"t1\") app.go() Add TextAreas .addTextArea(title, text=None) Adds an empty TextArea, with the specified title. .addScrolledTextArea(title, text=None) Adds a scrollable TextArea with the specified title. Set TextAreas .setTextArea(title, text, end=True, callFunction=True) Adds the supplied text to the specified TextArea. By default, the text is added to the end. Set end to be False if you want to add at the beginning. Set callFunction to be False, if you don't want to call any associated functions. .clearTextArea(title, callFunction=True) Clears the contents of the specified TextArea. Set callFunction to be False, if you don't want to call any associated functions. .clearAllTextAreas(callFunction=False) This will clear the contents of all TextAreas in the app. Set callFunction to be True, if you want to call any associated functions. .highlightTextArea(title, start, end=END) Highlights all text from start position, to the end position (defaults to the end of the text area). NB. positions should be a string in the format LINE.CHAR , eg. 1.4 wil start on the 1st line at the 4th character. Get TextAreas .getTextArea(title) Gets the contents of the specified TextArea. .getAllTextAreas() This will return the contents of all TextAreas in the app, as a dictionary. Search TextAreas .searchTextArea(title, pattern, start=None, stop=None, nocase=True, backwards=False) Will find, highlight and return the position of the specified pattern. If no start position is provided, appJar will start searching form the cursor's position. Set nocase to False, if you want the search to be case sensitive. Set backwards to True, if you want to search backwards. TextArea Fonts Fonts are tricky on TextAreas, it's currently not possible to have different font sizes & families on different parts of a TextArea. However, it is possible to make parts of the TextArea bold , italic or underlined . .setTextAreaFont(title, **kwargs) Used to change the family and size of the named TextArea's font. Pass font with a number to change the size of all text in the TextArea. Pass family with a strinf to change the font-family of all text in the TextArea. .textAreaApplyFontRange(title, tag, start, end=END) Apply the specified font styling to the specified range. The tag should be one of BOLD , ITALIC or BOLD_ITALIC - it will replace the previous font tag. Additionally, the UNDERLINE tag can be used alongside the above. .textAreaApplyFontSelected(title, tag) Apply the specified font styling to the currently selected text. .textAreaToggleFontRange(title, tag, start, end=END) Invert the named tag on the specified range. .textAreaToggleFontSelected(title, tag) Invert the named tag on the selected text. Tag TextAreas A simple syntax highlighter: from appJar import gui redWords = (\"string\", \"integer\", \"boolean\", \"real\") greenWords = (\"print\", \"input\") def highlightSyntax(param): for w in redWords: app.tagTextAreaPattern(\"ta\", \"red\", w) for w in greenWords: app.tagTextAreaPattern(\"ta\", \"green\", w) with gui(\"Text Editor\", \"300x400\") as app: app.text(\"ta\", focus=True, change=highlightSyntax) app.tagTextArea(\"ta\", \"red\", background=\"red\", foreground=\"white\") app.tagTextArea(\"ta\", \"green\", background=\"green\", foreground=\"white\") .textAreaCreateTag(title, **kwargs) Create the named tag, with the specified arguments. .textAreaChangeTag(title, **kwargs) Change the named tag, with the specified arguments. .textAreaDeleteTag(title, *tags) Delete the named tags. .textAreaTagPattern(title, tag, pattern, regexp=False) Apply a previously made tag to the specified pattern. Set regexp to True if you want to use a regular expression. .textAreaTagRange(title, tag, start, end) Apply a previously made tag to the specified range. .textAreaTagSelected(title, tag) Apply a previously made tag to the currently selected text. .textAreaUntagRange(title, tag, start, end) Remove the named tag from the specified range. .textAreaUntagSelected(title, tag) Remove the named tag from the selected text. .textAreaToggleTagRange(title, tag, start, end) Invert the named tag on the specified range. .textAreaToggleTagSelected(title, tag) Invert the named tag on the selected text. .getTextAreaTags(title) Gets a list of all tags on the text area. .getTextAreaTag(title) Gets all details about the specified tag. Button A clickable button, that will call a function. These are the key to starting an interactive application. The GUI is looping, waiting for something to happen. A button click is the classic way to start interacting with a GUI. Whenever any function is called by the GUI, the title of the widget that called it is passed as a parameter. That way, multiple widgets can use the same function, but different actions can be performed, depending on the name passed as a parameter. from appJar import gui # the title of the button will be received as a parameter def press(btn): print(btn) app=gui() # 3 buttons, each calling the same function app.addButton(\"One\", press) app.addButton(\"Two\", press) app.addButton(\"Three\", press) app.go() Add Buttons .addButton(title, function) Add a single button to the GUI, the text on the button will be the same as the button's title. A function should be specified, which will be called when the button is clicked, where the title is passed as a parameter to the function. Alternatively, the function can have no parameter, and appJar will not supply an argument. .addButtons(titles, functions) It's possible to add a list of buttons to the GUI. Pass a 1-dimensional or 2-dimensional list, and they will be rendered accordingly. A single function can be passed, to use for all buttons. Or a list of functions can be passed, which MUST correspond to the buttons. .addImageButton(title, function, imgFile, align=None) This creates the named button, as above, using the specified image. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addIconButton(title, function, iconName, align=None) This creates the named button, as above, using the specified icon. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addNamedButton(name, title, function) By default, it's not possible to have two buttons with the same text. If that's required, a named button should be used. This allows a name and title to be set for a button. The name will be displayed on the button, and the title passed to the function. Set Buttons .setButton(name, text) This will change the text displayed on a button, but NOT the value passed as a parameter to the function. .setButtonImage(title, image, align=None) This allows an image to be placed on a button, instead of the usual text. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. Link/WebLink Clickable text to call a function or launch a URL from appJar import gui def press(link): app.infoBox(\"Info\", \"You clicked the link!\") app=gui() app.setFont(20) app.addLink(\"Click me\", press) app.addWebLink(\"appJar.info\", \"http://appJar.info\") app.go() Add Links .addLink(title, func) Adds a hyperlink , that when clicked, will call the specified function. .addWebLink(title, page) Adds a hyperlink , that when clicked, will launch the default browser, and load the specified page. It must be a fully formed link, including http:// Get Links .getLink(title) Returns the text displayed in the link. Set Links .setLink(title, func) Changes the function/webpage the link calls. RadioButton A group of round boxes, only one of which can be selected. These are great for getting a single value, for a multiple choice question. from appJar import gui app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.addRadioButton(\"song\", \"Parklife\") app.go() Add RadioButtons .addRadioButton(title, name) This will create a RadioButton grouped by the specified title. This button will have the value of name. Radio buttons are usually used in groups. Set RadioButtons .setRadioButton(title, value, callFunction=True) This will tick the specified RadioButton. Set callFunction to be False, if you don't want to call any associated functions. .setRadioSquare(title, square=True) It is possible to use square buttons instead of the classic circular radio-button. Setting square to True will convert all the radio-buttons for this title to square boxes. Not supported in ttk or on Mac. .clearAllRadioButtons(callFunction=False) This will reset all RadioButtons in the app to their first value. Set callFunction to be True, if you want to call any associated functions. Get RadioButtons .getRadioButton(title) Gets the value of the selected RadioButton, for the specified title. from appJar import gui def press(rb): print(app.getRadioButton(\"song\")) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") # call this function, when the RadioButton changes app.setRadioButtonChangeFunction(\"song\", press) app.addButton(\"PLAY\", press) app.go() .getAllRadioButtons() This will return the contents of all RadioButtons in the app, as a dictionary. CheckBox A simple tick-box, with a label, that can be either ON or OFF. from appJar import gui app=gui() app.setFont(20) app.addCheckBox(\"Apples\") app.addCheckBox(\"Pears\") app.addCheckBox(\"Oranges\") app.addCheckBox(\"Kiwis\") app.setCheckBox(\"Oranges\") app.go() Add CheckBoxes .addCheckBox(title) This creates a CheckBox, with the specified title. .addNamedCheckBox(name, title) By default, it's not possible to have two CheckBoxes with the same text. If that's required, a named CheckBox should be used. This creates a CheckBox, with the specified title. The name will be displayed next to the CheckBox, and the title passed to the function as a unique ID. Set CheckBoxes .setCheckBox(title, ticked=True, callFunction=True) This will tick the CheckBox, or untick it if ticked is set to False. Set callFunction to be False, if you don't want to call any associated functions. .clearAllCheckBoxes(callFunction=False) This will clear (untick) all CheckBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .setCheckBoxText(title, text) This changes the text shown alongside the specified CheckBox. Get CheckBoxes .getCheckBox(title) This will return True or False, depending on the state of the CheckBox. .getAllCheckBoxes() This will return the contents of all CheckBoxes in the app, as a dictionary. OptionBox Creates a simple drop-down box. It is only possible to select one option from this drop-down. Pass in a list of values to show in the drop-down box. They will be added in the same order, with the first item shown. If the first item is empty, a simple title - options - will be created. Any other empty items will be removed. If an item starts with a dash (-), it will be treated as a separator, and can't be selected. from appJar import gui app=gui() app.setFont(20) app.addLabelOptionBox(\"Options\", [\"- Fruits -\", \"Apple\", \"Orange\", \"Pear\", \"kiwi\", \"- Pets -\", \"Dogs\", \"Cats\", \"Fish\", \"Hamsters\"]) app.go() Add OptionBoxes .addOptionBox(title, values) This will create an OptionBox, adding the contents of the values list, in the order specified. .addTickOptionBox(title, values) This will create an OptionBox made up of check boxes. The title will always be displayed as the selected entry in the OptionBox, event though it can't be selected/ticked. Instead of selecting a single item, you tick the ones you want. Calling .getOptionBox(title) will return a dictionary of the options along with a True/False value. from appJar import gui def get(btn): print(app.getOptionBox(\"Favourite Pets\")) app=gui() app.setFont(20) app.addTickOptionBox(\"Favourite Pets\", [\"Dogs\", \"Cats\", \"Hamsters\", \"Fish\"]) app.addButton(\"GET\", get) app.go() Set OptionBoxes .changeOptionBox(title, newOptions, index, callFunction=False) This will replace the contents of the OptionBox, with the new list provided. If specified, the indexed item will be selected - this can be a position or an item name. If setting a TickOptionBox, the old list will be replaced with the new list. None will be ticked. index will be ignored. Set callFunction to be True, if you want to call any associated change functions. .setOptionBox(title, position, value=True, callFunction=True, override=False) This will select the item in the list, at the position specified. Alternatively, the name of an item can be specified. If changing a TickOptionBox, the specified item will be set to the specified value. Set callFunction to be False, if you don't want to call any associated functions. By default, you can't select a disabled item. You can change this by setting override to be True. .setOptionBoxDisabledChar(title, disabled=\"-\") Set the character used to indicate disabled options. .renameOptionBoxItem(title, item, newName, callFunction=False) This will rename the specified item in the named OptionBox. Set callFunction to be True, if you want to call any associated change functions. .clearOptionBox(title, callFunction=True) This will set the named OptionBox back to its first value (even if it's disabled). Set callFunction to be False, if you don't want to call any associated functions. .clearAllOptionBoxes(callFunction=False) This will set all OptionBoxes in the app back to their first value (even if it's disabled). Set callFunction to be True, if you want to call any associated functions. .deleteOptionBox(title, position) This will delete the item in the list, at the position specified. Alternatively, the name of an item can be specified. Not available on TickOptionBoxes. Get OptionBoxes .getOptionBox(title) This will return the currently displayed value in an OptionBox. Or a dictionary of names, and their boolean value if a TickOptionBox. Will return None, if an invalid option is currently selected. .getAllOptionBoxes() This will return the contents of all OptionBoxes in the app, as a dictionary. SpinBox A scrollable list of options. Up and down buttons are provided to scroll from one item to the next. Unlike the OptionBox, you do not get a drop-down of choices, instead it spins to the next/previous option. from appJar import gui app=gui() app.setFont(20) app.addLabelSpinBox(\"options\", [\"Apple\", \"Orange\", \"Pear\", \"kiwi\"]) app.go() Add SpinBoxes .addSpinBox(title, values) This will create a SpinBox, adding the contents of the values list, in the order specified. .addSpinBoxRange(title, from, to) This will create a SpinBox, with a numeric range of items. from appJar import gui app=gui() app.setFont(20) app.addSpinBoxRange(\"Numbers\", 1, 12) app.go() Set SpinBoxes .setSpinBox(title, value, callFunction=True) This will select the specified value in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .setSpinBoxPos(title, pos, callFunction=True) This will select the value at the specified position in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .changeSpinBox(title, vals, reverse=True) Replaces the contents of the specified SpinBox with the new vals . Set reverse to False if you don;t ant to reverse the values. .clearSpinBox(callFunction=False) This will set the specified SpinBox back to its initial value. Set callFunction to be True, if you want to call any associated functions. .clearAllSpinBoxes(callFunction=False) This will set all SpinBoxes in the app to their first value. Set callFunction to be True, if you want to call any associated functions. Get SpinBoxes .getSpinBox(title) This will get the selected value from the specified SpinBox. .getAllSpinBoxes() This will return the contents of all SpinBoxes in the app, as a dictionary. ListBox A box containing a list of items, single or multi-select from appJar import gui app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.go() Add ListBoxes .addListBox(title, values) Creates a ListBox with the specified values. .addListItem(title, item) Adds a single item to the the end of the ListBox, and selects it. .addListItems(title, items) Adds a list of items to the end of the List Box, selecting the last one. Set ListBoxes .setListItem(title, item, newVal, first=False) .setListItemAtPos(title, pos, newVal) Changes the specified list item to the new value. If first is set to True, only the first item found will be changed. Otherwise, all occurrences of the specified value will be changed. .removeListItem(title, item) .removeListItemAtPos(title, pos) Remove the specified item from the specified ListBox. Will only remove the first item that matches the parameter. .clearListBox(title, callFunction=True) Removes all items from the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllListBoxes(callFunction=False) This will remove all items from all ListBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .updateListBox(title, items, select=False, callFunction=True) Replace the contents of the specified ListBox with the new values. If you set select to be True, the last item in the list will be selected. Set callFunction to be False, if you don't want to call any associated functions. from appJar import gui def press(btn): items = app.getListItems(\"list\") if len(items)> 0: app.removeListItem(\"list\", items[0]) app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.addButton(\"press\", press) app.go() .selectListItem(title, item, callFunction=True) .selectListItemAtPos(title, pos, callFunction=False) Selects the specified item in the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .deselectListItemAtPos(title, pos, callFunction=False) Seselects the item at the specified position. Set callFunction to be True, if you want to call any associated functions. .deselectAllListItems(title, callFunction=False) Deselects all items in the specified listbox. Set callFunction to be True, if you want to call any associated functions. .setListBoxRows(title, rows) Sets how many rows to display in the specified ListBox. .setListBoxMulti(list, multi=True) Configures whether the specified ListBox is single or multi select. .setListBoxGroup(list, group=True) Adds the named ListBox to a group of selectable ListBoxes. All ListBoxes in the group can have items selected at the same time. .setListItemBg(title, item, colour) & .setListItemFg(title, item, colour) .setListItemAtPosBg(title, item, colour) & .setListItemAtPosFg(title, item, colour) Sets the background or foreground colours the specified ListBox item. Can either specify a named item (will update all with that name) or the position of an item. Get ListBoxes .getListBox(title) Gets all of the selected items from the specified ListBox. .getAllListBoxes() This will return the contents of all ListBoxes in the app, as a dictionary. .getAllListItems(title) Gets all of the items from the specified ListBox. Scale A slider, that has a minimum & maximum value. from appJar import gui app=gui() app.setFont(20) app.addLabelScale(\"scale\") app.go() Add Scales .addScale(title) Adds a horizontal scale, with a default range between 0 and 100. Set Scales .setScale(title, pos, callFunction=True) Sets the selected pos for the specified Scale. Set callFunction to be False, if you don't want to call any associated functions. .setScaleRange(title from, to, curr=None) Allows you to change the range available in the Scale. If curr is provided, then the Scale will be set to that value. .setScaleIncrement(title, increment) Configures how much the scale jumps, when the trough is clicked. It defaults to 10%. .showScaleIntervals(title, intervals) Configures the Scale to show interval labels along its length. intervals should be how often to show a value, eg. 25 would show 0, 25, 50, and so on... .showScaleValue(title, show=True) Configures the Scale to show the currently selected value. .setScaleHorizontal(title) & .setScaleVertical(title) Changes the Scale's orientation to the specified value. .setScaleWidth(title, width) & .setScaleLength(title, length) Sets a width/length for the scale's slider. .setScaleChangeFunction(title, func) Sets a function to call, each time the scale is changed. The function must take one parameter, which will be populated with the scale's title. .clearAllScales(callFunction=False) This will set all Scales in the app to their minimum value. Set callFunction to be True, if you want to call any associated functions. Get Scales .getScale(title) Gets the currently selected value from the scale. .getAllScales() This will return the contents of all Scales in the app, as a dictionary. Properties A compound widget that shows multiple CheckButtons linked to a dictionary. Note, dictionaries have no order, so when added as a dictionary, the items will be automatically sorted. from appJar import gui toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.addProperties(\"Toppings\", toppings) app.setProperty(\"Toppings\", \"Pepper\") app.go() Add Properties .addProperties(title, values) Creates a new Properties widget, with the specified title. If values is populated, then the dictionary items will be added to the widget. Set Properties .setPropertyText(title, prop, newText=None) Change the displayed text for the named property. If no value is provided, the original value will be used. .setProperties(title, props, callFunction=True) Adds the dictionary of properties to the widget. If any of them already exist, they will be updated. Set callFunction to be False, if you don't want to call any associated functions. .setProperty(title, prop, value=False, callFunction=True) Sets the named property to the specified value. If it doesn't exist, it will be added first, at the end of the widget. Set callFunction to be False, if you don't want to call any associated functions. .deleteProperty(title, prop) Deletes the named property from the widget. .resetProperties(title, callFunction=True) This will reset the specified Properties back to its original values. Set callFunction to be False, if you don't want to call any associated functions. .clearProperties(title, callFunction=True) This will set all values in the specified Properties to False. Set callFunction to be False, if you don't want to call any associated functions. .resetAllProperties(callFunction=False) This will reset all Properties in the app back to their original values. Set callFunction to be True, if you want to call any associated functions. .clearAllProperties(callFunction=False) This will set all values in all Properties in the app to False. Set callFunction to be True, if you want to call any associated functions. .setPropertiesBoxBg(title, newCol) This will change the background colour of all tick boxes in the properties widget. Get Properties .getProperties(title) Gets a dictionary of the all items in the Properties widget. .getAllProperties() This will return the contents of all Properties in the app, as a dictionary. .getProperty(title, prop) Gets the value of the named property. Examples It's possible to put Properties into ToggleFrames, and also set a Function to listen for any changes. from appJar import gui def changed(props): print(\"Changed\", props) toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.startToggleFrame(\"Toppings\") app.addProperties(\"Toppings\", toppings) app.setPropertiesChangeFunction(\"Toppings\", changed) app.stopToggleFrame() app.go() DatePicker A widget to capture a date - will handle presenting accurate drop-downs, and return a date. from appJar import gui def showDate(btn): print(app.getDatePicker(\"dp\")) app=gui() app.addDatePicker(\"dp\") app.addButton(\"GET\", showDate) app.setDatePickerRange(\"dp\", 1900, 2100) app.setDatePicker(\"dp\") app.go() Add DatePickers .addDatePicker(title) Create a DatePicker, with a range from 1/1/1970 to 31/12/2020 Set DatePickers .setDatePicker(title, date=None) Will set the specified DatePicker to the specified date, or current date if no date is supplied. .setDatePickerRange(title, startYear, endYear=None) Set the range for the named DatePicker. If endYear is None, the current Year will be used. .setDatePickerChangeFunction(title, function) Set a function to call when the DatePicker is changed. .clearDatePicker(title, callFunction=True) This will reset the specified DatePicker to the earliest available date. Set callFunction to be False, if you don't want to call any associated functions. .clearAllDatePickers(callFunction=False) This will reset all DatePickers in the app to their earliest available date. Set callFunction to be True, if you want to call any associated functions. Get DatePickers .getDatePicker(title) Will return the currently selected date. .getAllDatePickers() This will return the contents of all DatePickers in the app, as a dictionary. Auto-Labelled Widgets It's possible to automatically include a label alongside some of widgets below. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to)","title":"Input Widgets"},{"location":"inputWidgets/#input-widgets","text":"Input widgets are used for capturing user interactions, either by cicking, typing or dragging. They usually provide three functions: ADD - this creates the widget GET - this gets the contents/state of the widget SET - this changes what's in the widget As well as options to change the way they look/act . For each of the above to work, we need to know which widget you are referring to - so every widget gets a unique title . If you want your input widget to have a label, there are some auto-label functions If you wnat to get the contents of all widgets in the GUI as a single dictionary, use: * .getAllInputs(includeEmptyInputs=False) This will return the contents of all input fields as a dictionary. Set includeEmptyInputs to True, if you want to include any empty input fields.","title":"Input Widgets"},{"location":"inputWidgets/#entry","text":"Entries are used to capture typed input from the user. They take a single parameter - a title. There are five special-case Entries: NumericEntry - this only allows numbers to be typed in - always returns a float (None if empty). SecretEntry - this will show stars, instead of the letters typed - useful for capturing passwords. AutoEntry - this takes a list of words to provide auto-completion. ValidationEntry - can be set to valid/invalid/waiting - will colour the border green/red/black and show a \u2714/\u2716/\u2605 OpenEntry/SaveEntry/DirectoryEntry - provides a button to select a file/directory and auto-populates the Entry from appJar import gui app=gui() app.addEntry(\"e1\") app.addEntry(\"e2\") app.addEntry(\"e3\") app.addLabelEntry(\"Name\") app.addValidationEntry(\"v1\") app.addFileEntry(\"f1\") app.setEntryDefault(\"e2\", \"Age here\") app.setEntryValid(\"v1\") app.go()","title":"Entry"},{"location":"inputWidgets/#add-entries","text":".addEntry(title) .addNumericEntry(title) .addSecretEntry(title) .addValidationEntry(title) .addOpenEntry(title) .addSaveEntry(title) .addDirectoryEntry(title) .addAutoEntry(title, words) This also takes a words parameter, which must be a list, and is used to populate he drop-down. Each of these will add the specified type of Entry, using the title provided.","title":"Add Entries"},{"location":"inputWidgets/#set-entries","text":".setEntry(title, text, callFunction=True) This sets the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .setEntryDefault(title, text) This sets a default value to display in an Entry. Once the user starts typing, it will disappear. The text is centered, shown in a light gray font, and will not be returned by .getEntry(title) .setEntryUpperCase(title) & .setEntryLowerCase(title) This will force all text typed into the Entry to be uppercase/lowercase. .setEntryMaxLength(title, maxLength) This will set a maximum length for the specified Entry. Any additional characters typed will be discarded. .setEntryValid(title) & .setEntryInvalid(title) & .setEntryWaitingValidation(title) These will set the relevant status of a Validation Entry (how it looks). (Have a look here for help displaying special characters) .setValidationEntry(title, state=\"valid\") Same as above, set flag to one of valid , invalid or wait . .setValidationEntryLabelBg(title, bg) This allows you to change the colour of the validation label, in a validation entry. .setAutoEntryNumRows(title, rows) This will set the number of rows to display in an AutoEntry. NB. this is limited to the depth of the GUI - if there is no space, then no rows will be displayed. .appendAutoEntry(title, value) This will add the value/list of values to the specified AutoEntry. .removeAutoEntry(title, value) This will remove the value from the specified AutoEntry. .changeAutoEntry(title, value) This will replace all items in the specified AutoEntry with a new list of values. .clearEntry(title, callFunction=True) This will clear the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .clearAllEntries(callFunction=False) This will clear all Entries in the GUI. Set callFunction to be True, if you want to call any associated functions. .setFocus(title) This will put the cursor in the specified Entry, so that the user can start typing without needing to click.","title":"Set Entries"},{"location":"inputWidgets/#get-entries","text":".getEntry(title) This will return the contents of the specified Entry. NB. numericEntries always return a float. .getAllEntries() This will return the contents of all Entries in the app, as a dictionary. NB. numericEntries always return a float.","title":"Get Entries"},{"location":"inputWidgets/#textarea","text":"Similar to an Entry, but allows you to type text over multiple lines. from appJar import gui app=gui() app.addTextArea(\"t1\") app.go()","title":"TextArea"},{"location":"inputWidgets/#add-textareas","text":".addTextArea(title, text=None) Adds an empty TextArea, with the specified title. .addScrolledTextArea(title, text=None) Adds a scrollable TextArea with the specified title.","title":"Add TextAreas"},{"location":"inputWidgets/#set-textareas","text":".setTextArea(title, text, end=True, callFunction=True) Adds the supplied text to the specified TextArea. By default, the text is added to the end. Set end to be False if you want to add at the beginning. Set callFunction to be False, if you don't want to call any associated functions. .clearTextArea(title, callFunction=True) Clears the contents of the specified TextArea. Set callFunction to be False, if you don't want to call any associated functions. .clearAllTextAreas(callFunction=False) This will clear the contents of all TextAreas in the app. Set callFunction to be True, if you want to call any associated functions. .highlightTextArea(title, start, end=END) Highlights all text from start position, to the end position (defaults to the end of the text area). NB. positions should be a string in the format LINE.CHAR , eg. 1.4 wil start on the 1st line at the 4th character.","title":"Set TextAreas"},{"location":"inputWidgets/#get-textareas","text":".getTextArea(title) Gets the contents of the specified TextArea. .getAllTextAreas() This will return the contents of all TextAreas in the app, as a dictionary.","title":"Get TextAreas"},{"location":"inputWidgets/#search-textareas","text":".searchTextArea(title, pattern, start=None, stop=None, nocase=True, backwards=False) Will find, highlight and return the position of the specified pattern. If no start position is provided, appJar will start searching form the cursor's position. Set nocase to False, if you want the search to be case sensitive. Set backwards to True, if you want to search backwards.","title":"Search TextAreas"},{"location":"inputWidgets/#textarea-fonts","text":"Fonts are tricky on TextAreas, it's currently not possible to have different font sizes & families on different parts of a TextArea. However, it is possible to make parts of the TextArea bold , italic or underlined . .setTextAreaFont(title, **kwargs) Used to change the family and size of the named TextArea's font. Pass font with a number to change the size of all text in the TextArea. Pass family with a strinf to change the font-family of all text in the TextArea. .textAreaApplyFontRange(title, tag, start, end=END) Apply the specified font styling to the specified range. The tag should be one of BOLD , ITALIC or BOLD_ITALIC - it will replace the previous font tag. Additionally, the UNDERLINE tag can be used alongside the above. .textAreaApplyFontSelected(title, tag) Apply the specified font styling to the currently selected text. .textAreaToggleFontRange(title, tag, start, end=END) Invert the named tag on the specified range. .textAreaToggleFontSelected(title, tag) Invert the named tag on the selected text.","title":"TextArea Fonts"},{"location":"inputWidgets/#tag-textareas","text":"A simple syntax highlighter: from appJar import gui redWords = (\"string\", \"integer\", \"boolean\", \"real\") greenWords = (\"print\", \"input\") def highlightSyntax(param): for w in redWords: app.tagTextAreaPattern(\"ta\", \"red\", w) for w in greenWords: app.tagTextAreaPattern(\"ta\", \"green\", w) with gui(\"Text Editor\", \"300x400\") as app: app.text(\"ta\", focus=True, change=highlightSyntax) app.tagTextArea(\"ta\", \"red\", background=\"red\", foreground=\"white\") app.tagTextArea(\"ta\", \"green\", background=\"green\", foreground=\"white\") .textAreaCreateTag(title, **kwargs) Create the named tag, with the specified arguments. .textAreaChangeTag(title, **kwargs) Change the named tag, with the specified arguments. .textAreaDeleteTag(title, *tags) Delete the named tags. .textAreaTagPattern(title, tag, pattern, regexp=False) Apply a previously made tag to the specified pattern. Set regexp to True if you want to use a regular expression. .textAreaTagRange(title, tag, start, end) Apply a previously made tag to the specified range. .textAreaTagSelected(title, tag) Apply a previously made tag to the currently selected text. .textAreaUntagRange(title, tag, start, end) Remove the named tag from the specified range. .textAreaUntagSelected(title, tag) Remove the named tag from the selected text. .textAreaToggleTagRange(title, tag, start, end) Invert the named tag on the specified range. .textAreaToggleTagSelected(title, tag) Invert the named tag on the selected text. .getTextAreaTags(title) Gets a list of all tags on the text area. .getTextAreaTag(title) Gets all details about the specified tag.","title":"Tag TextAreas"},{"location":"inputWidgets/#button","text":"A clickable button, that will call a function. These are the key to starting an interactive application. The GUI is looping, waiting for something to happen. A button click is the classic way to start interacting with a GUI. Whenever any function is called by the GUI, the title of the widget that called it is passed as a parameter. That way, multiple widgets can use the same function, but different actions can be performed, depending on the name passed as a parameter. from appJar import gui # the title of the button will be received as a parameter def press(btn): print(btn) app=gui() # 3 buttons, each calling the same function app.addButton(\"One\", press) app.addButton(\"Two\", press) app.addButton(\"Three\", press) app.go()","title":"Button"},{"location":"inputWidgets/#add-buttons","text":".addButton(title, function) Add a single button to the GUI, the text on the button will be the same as the button's title. A function should be specified, which will be called when the button is clicked, where the title is passed as a parameter to the function. Alternatively, the function can have no parameter, and appJar will not supply an argument. .addButtons(titles, functions) It's possible to add a list of buttons to the GUI. Pass a 1-dimensional or 2-dimensional list, and they will be rendered accordingly. A single function can be passed, to use for all buttons. Or a list of functions can be passed, which MUST correspond to the buttons. .addImageButton(title, function, imgFile, align=None) This creates the named button, as above, using the specified image. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addIconButton(title, function, iconName, align=None) This creates the named button, as above, using the specified icon. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addNamedButton(name, title, function) By default, it's not possible to have two buttons with the same text. If that's required, a named button should be used. This allows a name and title to be set for a button. The name will be displayed on the button, and the title passed to the function.","title":"Add Buttons"},{"location":"inputWidgets/#set-buttons","text":".setButton(name, text) This will change the text displayed on a button, but NOT the value passed as a parameter to the function. .setButtonImage(title, image, align=None) This allows an image to be placed on a button, instead of the usual text. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text.","title":"Set Buttons"},{"location":"inputWidgets/#linkweblink","text":"Clickable text to call a function or launch a URL from appJar import gui def press(link): app.infoBox(\"Info\", \"You clicked the link!\") app=gui() app.setFont(20) app.addLink(\"Click me\", press) app.addWebLink(\"appJar.info\", \"http://appJar.info\") app.go()","title":"Link/WebLink"},{"location":"inputWidgets/#add-links","text":".addLink(title, func) Adds a hyperlink , that when clicked, will call the specified function. .addWebLink(title, page) Adds a hyperlink , that when clicked, will launch the default browser, and load the specified page. It must be a fully formed link, including http://","title":"Add Links"},{"location":"inputWidgets/#get-links","text":".getLink(title) Returns the text displayed in the link.","title":"Get Links"},{"location":"inputWidgets/#set-links","text":".setLink(title, func) Changes the function/webpage the link calls.","title":"Set Links"},{"location":"inputWidgets/#radiobutton","text":"A group of round boxes, only one of which can be selected. These are great for getting a single value, for a multiple choice question. from appJar import gui app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.addRadioButton(\"song\", \"Parklife\") app.go()","title":"RadioButton"},{"location":"inputWidgets/#add-radiobuttons","text":".addRadioButton(title, name) This will create a RadioButton grouped by the specified title. This button will have the value of name. Radio buttons are usually used in groups.","title":"Add RadioButtons"},{"location":"inputWidgets/#set-radiobuttons","text":".setRadioButton(title, value, callFunction=True) This will tick the specified RadioButton. Set callFunction to be False, if you don't want to call any associated functions. .setRadioSquare(title, square=True) It is possible to use square buttons instead of the classic circular radio-button. Setting square to True will convert all the radio-buttons for this title to square boxes. Not supported in ttk or on Mac. .clearAllRadioButtons(callFunction=False) This will reset all RadioButtons in the app to their first value. Set callFunction to be True, if you want to call any associated functions.","title":"Set RadioButtons"},{"location":"inputWidgets/#get-radiobuttons","text":".getRadioButton(title) Gets the value of the selected RadioButton, for the specified title. from appJar import gui def press(rb): print(app.getRadioButton(\"song\")) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") # call this function, when the RadioButton changes app.setRadioButtonChangeFunction(\"song\", press) app.addButton(\"PLAY\", press) app.go() .getAllRadioButtons() This will return the contents of all RadioButtons in the app, as a dictionary.","title":"Get RadioButtons"},{"location":"inputWidgets/#checkbox","text":"A simple tick-box, with a label, that can be either ON or OFF. from appJar import gui app=gui() app.setFont(20) app.addCheckBox(\"Apples\") app.addCheckBox(\"Pears\") app.addCheckBox(\"Oranges\") app.addCheckBox(\"Kiwis\") app.setCheckBox(\"Oranges\") app.go()","title":"CheckBox"},{"location":"inputWidgets/#add-checkboxes","text":".addCheckBox(title) This creates a CheckBox, with the specified title. .addNamedCheckBox(name, title) By default, it's not possible to have two CheckBoxes with the same text. If that's required, a named CheckBox should be used. This creates a CheckBox, with the specified title. The name will be displayed next to the CheckBox, and the title passed to the function as a unique ID.","title":"Add CheckBoxes"},{"location":"inputWidgets/#set-checkboxes","text":".setCheckBox(title, ticked=True, callFunction=True) This will tick the CheckBox, or untick it if ticked is set to False. Set callFunction to be False, if you don't want to call any associated functions. .clearAllCheckBoxes(callFunction=False) This will clear (untick) all CheckBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .setCheckBoxText(title, text) This changes the text shown alongside the specified CheckBox.","title":"Set CheckBoxes"},{"location":"inputWidgets/#get-checkboxes","text":".getCheckBox(title) This will return True or False, depending on the state of the CheckBox. .getAllCheckBoxes() This will return the contents of all CheckBoxes in the app, as a dictionary.","title":"Get CheckBoxes"},{"location":"inputWidgets/#optionbox","text":"Creates a simple drop-down box. It is only possible to select one option from this drop-down. Pass in a list of values to show in the drop-down box. They will be added in the same order, with the first item shown. If the first item is empty, a simple title - options - will be created. Any other empty items will be removed. If an item starts with a dash (-), it will be treated as a separator, and can't be selected. from appJar import gui app=gui() app.setFont(20) app.addLabelOptionBox(\"Options\", [\"- Fruits -\", \"Apple\", \"Orange\", \"Pear\", \"kiwi\", \"- Pets -\", \"Dogs\", \"Cats\", \"Fish\", \"Hamsters\"]) app.go()","title":"OptionBox"},{"location":"inputWidgets/#add-optionboxes","text":".addOptionBox(title, values) This will create an OptionBox, adding the contents of the values list, in the order specified. .addTickOptionBox(title, values) This will create an OptionBox made up of check boxes. The title will always be displayed as the selected entry in the OptionBox, event though it can't be selected/ticked. Instead of selecting a single item, you tick the ones you want. Calling .getOptionBox(title) will return a dictionary of the options along with a True/False value. from appJar import gui def get(btn): print(app.getOptionBox(\"Favourite Pets\")) app=gui() app.setFont(20) app.addTickOptionBox(\"Favourite Pets\", [\"Dogs\", \"Cats\", \"Hamsters\", \"Fish\"]) app.addButton(\"GET\", get) app.go()","title":"Add OptionBoxes"},{"location":"inputWidgets/#set-optionboxes","text":".changeOptionBox(title, newOptions, index, callFunction=False) This will replace the contents of the OptionBox, with the new list provided. If specified, the indexed item will be selected - this can be a position or an item name. If setting a TickOptionBox, the old list will be replaced with the new list. None will be ticked. index will be ignored. Set callFunction to be True, if you want to call any associated change functions. .setOptionBox(title, position, value=True, callFunction=True, override=False) This will select the item in the list, at the position specified. Alternatively, the name of an item can be specified. If changing a TickOptionBox, the specified item will be set to the specified value. Set callFunction to be False, if you don't want to call any associated functions. By default, you can't select a disabled item. You can change this by setting override to be True. .setOptionBoxDisabledChar(title, disabled=\"-\") Set the character used to indicate disabled options. .renameOptionBoxItem(title, item, newName, callFunction=False) This will rename the specified item in the named OptionBox. Set callFunction to be True, if you want to call any associated change functions. .clearOptionBox(title, callFunction=True) This will set the named OptionBox back to its first value (even if it's disabled). Set callFunction to be False, if you don't want to call any associated functions. .clearAllOptionBoxes(callFunction=False) This will set all OptionBoxes in the app back to their first value (even if it's disabled). Set callFunction to be True, if you want to call any associated functions. .deleteOptionBox(title, position) This will delete the item in the list, at the position specified. Alternatively, the name of an item can be specified. Not available on TickOptionBoxes.","title":"Set OptionBoxes"},{"location":"inputWidgets/#get-optionboxes","text":".getOptionBox(title) This will return the currently displayed value in an OptionBox. Or a dictionary of names, and their boolean value if a TickOptionBox. Will return None, if an invalid option is currently selected. .getAllOptionBoxes() This will return the contents of all OptionBoxes in the app, as a dictionary.","title":"Get OptionBoxes"},{"location":"inputWidgets/#spinbox","text":"A scrollable list of options. Up and down buttons are provided to scroll from one item to the next. Unlike the OptionBox, you do not get a drop-down of choices, instead it spins to the next/previous option. from appJar import gui app=gui() app.setFont(20) app.addLabelSpinBox(\"options\", [\"Apple\", \"Orange\", \"Pear\", \"kiwi\"]) app.go()","title":"SpinBox"},{"location":"inputWidgets/#add-spinboxes","text":".addSpinBox(title, values) This will create a SpinBox, adding the contents of the values list, in the order specified. .addSpinBoxRange(title, from, to) This will create a SpinBox, with a numeric range of items. from appJar import gui app=gui() app.setFont(20) app.addSpinBoxRange(\"Numbers\", 1, 12) app.go()","title":"Add SpinBoxes"},{"location":"inputWidgets/#set-spinboxes","text":".setSpinBox(title, value, callFunction=True) This will select the specified value in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .setSpinBoxPos(title, pos, callFunction=True) This will select the value at the specified position in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .changeSpinBox(title, vals, reverse=True) Replaces the contents of the specified SpinBox with the new vals . Set reverse to False if you don;t ant to reverse the values. .clearSpinBox(callFunction=False) This will set the specified SpinBox back to its initial value. Set callFunction to be True, if you want to call any associated functions. .clearAllSpinBoxes(callFunction=False) This will set all SpinBoxes in the app to their first value. Set callFunction to be True, if you want to call any associated functions.","title":"Set SpinBoxes"},{"location":"inputWidgets/#get-spinboxes","text":".getSpinBox(title) This will get the selected value from the specified SpinBox. .getAllSpinBoxes() This will return the contents of all SpinBoxes in the app, as a dictionary.","title":"Get SpinBoxes"},{"location":"inputWidgets/#listbox","text":"A box containing a list of items, single or multi-select from appJar import gui app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.go()","title":"ListBox"},{"location":"inputWidgets/#add-listboxes","text":".addListBox(title, values) Creates a ListBox with the specified values. .addListItem(title, item) Adds a single item to the the end of the ListBox, and selects it. .addListItems(title, items) Adds a list of items to the end of the List Box, selecting the last one.","title":"Add ListBoxes"},{"location":"inputWidgets/#set-listboxes","text":".setListItem(title, item, newVal, first=False) .setListItemAtPos(title, pos, newVal) Changes the specified list item to the new value. If first is set to True, only the first item found will be changed. Otherwise, all occurrences of the specified value will be changed. .removeListItem(title, item) .removeListItemAtPos(title, pos) Remove the specified item from the specified ListBox. Will only remove the first item that matches the parameter. .clearListBox(title, callFunction=True) Removes all items from the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllListBoxes(callFunction=False) This will remove all items from all ListBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .updateListBox(title, items, select=False, callFunction=True) Replace the contents of the specified ListBox with the new values. If you set select to be True, the last item in the list will be selected. Set callFunction to be False, if you don't want to call any associated functions. from appJar import gui def press(btn): items = app.getListItems(\"list\") if len(items)> 0: app.removeListItem(\"list\", items[0]) app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.addButton(\"press\", press) app.go() .selectListItem(title, item, callFunction=True) .selectListItemAtPos(title, pos, callFunction=False) Selects the specified item in the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .deselectListItemAtPos(title, pos, callFunction=False) Seselects the item at the specified position. Set callFunction to be True, if you want to call any associated functions. .deselectAllListItems(title, callFunction=False) Deselects all items in the specified listbox. Set callFunction to be True, if you want to call any associated functions. .setListBoxRows(title, rows) Sets how many rows to display in the specified ListBox. .setListBoxMulti(list, multi=True) Configures whether the specified ListBox is single or multi select. .setListBoxGroup(list, group=True) Adds the named ListBox to a group of selectable ListBoxes. All ListBoxes in the group can have items selected at the same time. .setListItemBg(title, item, colour) & .setListItemFg(title, item, colour) .setListItemAtPosBg(title, item, colour) & .setListItemAtPosFg(title, item, colour) Sets the background or foreground colours the specified ListBox item. Can either specify a named item (will update all with that name) or the position of an item.","title":"Set ListBoxes"},{"location":"inputWidgets/#get-listboxes","text":".getListBox(title) Gets all of the selected items from the specified ListBox. .getAllListBoxes() This will return the contents of all ListBoxes in the app, as a dictionary. .getAllListItems(title) Gets all of the items from the specified ListBox.","title":"Get ListBoxes"},{"location":"inputWidgets/#scale","text":"A slider, that has a minimum & maximum value. from appJar import gui app=gui() app.setFont(20) app.addLabelScale(\"scale\") app.go()","title":"Scale"},{"location":"inputWidgets/#add-scales","text":".addScale(title) Adds a horizontal scale, with a default range between 0 and 100.","title":"Add Scales"},{"location":"inputWidgets/#set-scales","text":".setScale(title, pos, callFunction=True) Sets the selected pos for the specified Scale. Set callFunction to be False, if you don't want to call any associated functions. .setScaleRange(title from, to, curr=None) Allows you to change the range available in the Scale. If curr is provided, then the Scale will be set to that value. .setScaleIncrement(title, increment) Configures how much the scale jumps, when the trough is clicked. It defaults to 10%. .showScaleIntervals(title, intervals) Configures the Scale to show interval labels along its length. intervals should be how often to show a value, eg. 25 would show 0, 25, 50, and so on... .showScaleValue(title, show=True) Configures the Scale to show the currently selected value. .setScaleHorizontal(title) & .setScaleVertical(title) Changes the Scale's orientation to the specified value. .setScaleWidth(title, width) & .setScaleLength(title, length) Sets a width/length for the scale's slider. .setScaleChangeFunction(title, func) Sets a function to call, each time the scale is changed. The function must take one parameter, which will be populated with the scale's title. .clearAllScales(callFunction=False) This will set all Scales in the app to their minimum value. Set callFunction to be True, if you want to call any associated functions.","title":"Set Scales"},{"location":"inputWidgets/#get-scales","text":".getScale(title) Gets the currently selected value from the scale. .getAllScales() This will return the contents of all Scales in the app, as a dictionary.","title":"Get Scales"},{"location":"inputWidgets/#properties","text":"A compound widget that shows multiple CheckButtons linked to a dictionary. Note, dictionaries have no order, so when added as a dictionary, the items will be automatically sorted. from appJar import gui toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.addProperties(\"Toppings\", toppings) app.setProperty(\"Toppings\", \"Pepper\") app.go()","title":"Properties"},{"location":"inputWidgets/#add-properties","text":".addProperties(title, values) Creates a new Properties widget, with the specified title. If values is populated, then the dictionary items will be added to the widget.","title":"Add Properties"},{"location":"inputWidgets/#set-properties","text":".setPropertyText(title, prop, newText=None) Change the displayed text for the named property. If no value is provided, the original value will be used. .setProperties(title, props, callFunction=True) Adds the dictionary of properties to the widget. If any of them already exist, they will be updated. Set callFunction to be False, if you don't want to call any associated functions. .setProperty(title, prop, value=False, callFunction=True) Sets the named property to the specified value. If it doesn't exist, it will be added first, at the end of the widget. Set callFunction to be False, if you don't want to call any associated functions. .deleteProperty(title, prop) Deletes the named property from the widget. .resetProperties(title, callFunction=True) This will reset the specified Properties back to its original values. Set callFunction to be False, if you don't want to call any associated functions. .clearProperties(title, callFunction=True) This will set all values in the specified Properties to False. Set callFunction to be False, if you don't want to call any associated functions. .resetAllProperties(callFunction=False) This will reset all Properties in the app back to their original values. Set callFunction to be True, if you want to call any associated functions. .clearAllProperties(callFunction=False) This will set all values in all Properties in the app to False. Set callFunction to be True, if you want to call any associated functions. .setPropertiesBoxBg(title, newCol) This will change the background colour of all tick boxes in the properties widget.","title":"Set Properties"},{"location":"inputWidgets/#get-properties","text":".getProperties(title) Gets a dictionary of the all items in the Properties widget. .getAllProperties() This will return the contents of all Properties in the app, as a dictionary. .getProperty(title, prop) Gets the value of the named property.","title":"Get Properties"},{"location":"inputWidgets/#examples","text":"It's possible to put Properties into ToggleFrames, and also set a Function to listen for any changes. from appJar import gui def changed(props): print(\"Changed\", props) toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.startToggleFrame(\"Toppings\") app.addProperties(\"Toppings\", toppings) app.setPropertiesChangeFunction(\"Toppings\", changed) app.stopToggleFrame() app.go()","title":"Examples"},{"location":"inputWidgets/#datepicker","text":"A widget to capture a date - will handle presenting accurate drop-downs, and return a date. from appJar import gui def showDate(btn): print(app.getDatePicker(\"dp\")) app=gui() app.addDatePicker(\"dp\") app.addButton(\"GET\", showDate) app.setDatePickerRange(\"dp\", 1900, 2100) app.setDatePicker(\"dp\") app.go()","title":"DatePicker"},{"location":"inputWidgets/#add-datepickers","text":".addDatePicker(title) Create a DatePicker, with a range from 1/1/1970 to 31/12/2020","title":"Add DatePickers"},{"location":"inputWidgets/#set-datepickers","text":".setDatePicker(title, date=None) Will set the specified DatePicker to the specified date, or current date if no date is supplied. .setDatePickerRange(title, startYear, endYear=None) Set the range for the named DatePicker. If endYear is None, the current Year will be used. .setDatePickerChangeFunction(title, function) Set a function to call when the DatePicker is changed. .clearDatePicker(title, callFunction=True) This will reset the specified DatePicker to the earliest available date. Set callFunction to be False, if you don't want to call any associated functions. .clearAllDatePickers(callFunction=False) This will reset all DatePickers in the app to their earliest available date. Set callFunction to be True, if you want to call any associated functions.","title":"Set DatePickers"},{"location":"inputWidgets/#get-datepickers","text":".getDatePicker(title) Will return the currently selected date. .getAllDatePickers() This will return the contents of all DatePickers in the app, as a dictionary.","title":"Get DatePickers"},{"location":"inputWidgets/#auto-labelled-widgets","text":"It's possible to automatically include a label alongside some of widgets below. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to)","title":"Auto-Labelled Widgets"},{"location":"multiplePages/","text":"Multiple Pages A common question is how to have different pages of widgets in the same GUI. There are lots of ways to acheive this. All of the below are using a 2D list of data: data = [[\"Homer\", \"Simpson\", \"America\", 40], [\"Marge\", \"Simpson\", \"America\", 38], [\"Lisa\", \"Simpson\", \"America\", 12], [\"Maggie\", \"Simpson\", \"America\", 4], [\"Bart\", \"Simpson\", \"America\", 14]] Updating Labels One option is to reuse the existing widgets, and change their contents. This involves creating a single set of widgets, and then calling a function to change their contents: pos = -1 def changeCharacter(btn): global pos if btn == \"Next\": pos += 1 elif btn == \"Previous\": pos -= 1 if pos == 0: app.disableButton(\"Previous\") elif pos == len(data)-1: app.disableButton(\"Next\") else: app.enableButton(\"Previous\") app.enableButton(\"Next\") app.entry(\"First Name\", data[pos][0]) app.entry(\"Last Name\", data[pos][1]) app.entry(\"Country\", data[pos][2]) app.entry(\"Age\", data[pos][3]) with gui(\"Updating Labels\") as app: app.entry(\"First Name\", label=True) app.entry(\"Last Name\", label=True) app.entry(\"Country\", label=True) app.entry(\"Age\", kind='numeric', label=True) app.buttons([\"Previous\", \"Next\"], changeCharacter) changeCharacter(\"Next\") PagedWindow PagedWindows were introduced to allow easy navigation through multiple pages of similar data - think address books or music collections. They provide navigation buttons, a title and a page number: with gui(\"Updating Labels\") as app: with app.pagedWindow(\"Address Book\"): for pos in range(len(data)): with app.page(): app.entry(str(pos)+\"fName\", data[pos][0], label=\"First Name\") app.entry(str(pos)+\"lName\", data[pos][1], label=\"Last Name\") app.entry(str(pos)+\"country\", data[pos][2], label=\"Country\") app.entry(str(pos)+\"age\", data[pos][3], kind='numeric', label=\"Age\") TabbedFrames TabbedFrames are another common way of presenting multiple pages of data in a single widget: with gui(\"Updating Labels\") as app: with app.tabbedFrame(\"Address Book\"): for pos in range(len(data)): with app.tab(data[pos][0]): app.entry(str(pos)+\"fName\", data[pos][0], label=\"First Name\") app.entry(str(pos)+\"lName\", data[pos][1], label=\"Last Name\") app.entry(str(pos)+\"country\", data[pos][2], label=\"Country\") app.entry(str(pos)+\"age\", data[pos][3], kind='numeric', label=\"Age\") Overlayed Frames A clever trick for solving this problem is to group your widgets in a Frame , and then have multiple frames in the same place. Frames are not transparent, so only the last added frame will be visible. It's possible to then raise another frame to the top. This works well, but requires keeping track of the frame: pos = -1 def changeCharacter(btn): global pos if btn == \"Next\": pos += 1 elif btn == \"Previous\": pos -= 1 if pos == 0: app.disableButton(\"Previous\") elif pos == len(data)-1: app.disableButton(\"Next\") else: app.enableButton(\"Previous\") app.enableButton(\"Next\") app.raiseFrame(str(pos)) with gui(\"Updating Labels\") as app: for loop in range(len(data)): with app.frame(str(loop), 0, 0): # put all the frames in grid pos 0,0 app.entry(str(loop)+\"fName\", data[loop][0], label=\"First Name\") app.entry(str(loop)+\"lName\", data[loop][1], label=\"Last Name\") app.entry(str(loop)+\"country\", data[loop][2], label=\"Country\") app.entry(str(loop)+\"age\", data[loop][3], kind='numeric', label=\"Age\") app.buttons([\"Previous\", \"Next\"], changeCharacter) changeCharacter(\"Next\") FrameStacks To take away some of the work from the above option, we created FrameStacks . They provide extra functions for navigating, and checking which Frame is being displayed: def changeCharacter(btn): if btn == \"Next\": app.nextFrame(\"address book\") elif btn == \"Previous\": app.prevFrame(\"address book\") if app.frameStackAtStart(\"address book\"): app.disableButton(\"Previous\") elif app.frameStackAtEnd(\"address book\"): app.disableButton(\"Next\") else: app.enableButton(\"Previous\") app.enableButton(\"Next\") with gui(\"Updating Labels\") as app: with app.frameStack(\"address book\", start=0): for loop in range(len(data)): with app.frame(): app.entry(str(loop)+\"fName\", data[loop][0], label=\"First Name\") app.entry(str(loop)+\"lName\", data[loop][1], label=\"Last Name\") app.entry(str(loop)+\"country\", data[loop][2], label=\"Country\") app.entry(str(loop)+\"age\", data[loop][3], kind='numeric', label=\"Age\") app.buttons([\"Previous\", \"Next\"], changeCharacter) app.disableButton(\"Previous\") Hiding/Showing Instead of putting multiple frames in the same grid cell, you can have them in different rows, and hide them : def showCharacter(btn): for pos in range(len(data)): if data[pos][0] == btn: app.showFrame(str(pos)) else: app.hideFrame(str(pos)) with gui(\"Updating Labels\") as app: for loop in range(len(data)): with app.frame(str(loop)): app.entry(str(loop)+\"fName\", data[loop][0], label=\"First Name\") app.entry(str(loop)+\"lName\", data[loop][1], label=\"Last Name\") app.entry(str(loop)+\"country\", data[loop][2], label=\"Country\") app.entry(str(loop)+\"age\", data[loop][3], kind='numeric', label=\"Age\") app.hideFrame(str(loop)) app.buttons([d[0] for d in data], showCharacter) showCharacter(\"Homer\") Emptying Containers It's possible to quickly delete all widgets in a container, and then recreate them: def press(btn): if btn == 'SHOW': app.showSubWindow('Info') elif btn == 'EMPTY': app.emptySubWindow('Info') elif btn == 'POPULATE': makeSub() def makeSub(): with app.subWindow('Info'): app.addLabel('This will crash if not empty') with gui('Emptying Containers') as app: app.label('Try emptying a container') app.buttons(['SHOW', 'EMPTY', 'POPULATE'], press) makeSub() Alternatively, empty the container as it is populated: def reload(): showInfo({'Score':50, 'Name':'Omega', 'Occupation':'Nothing'}) def showInfo(data): with app.labelFrame('Info'): app.emptyCurrentContainer() # delete all widgets for name, value in data.items(): app.entry(name, value, label=True) with gui('Show Dict') as app: showInfo({'Score':100, 'Name':'Vida', 'Occupation':'Other'}) app.button('RELOAD', reload) Destroying/Recreating An alternative to the above is to be a bit more aggresive and destroy & recreate your widgets each time. This can be less efficient in terms of time, but more efficient in terms of memory... def showCharacter(btn): for pos in range(len(data)): if data[pos][0] == btn: app.removeAllWidgets() makeCharacter(pos) def makeCharacter(pos): with app.frame(\"character\", 0, 0): app.entry(\"fName\", data[pos][0], label=\"First Name\") app.entry(\"lName\", data[pos][1], label=\"Last Name\") app.entry(\"country\", data[pos][2], label=\"Country\") app.entry(\"age\", data[pos][3], kind='numeric', label=\"Age\") app.buttons([d[0] for d in data], showCharacter) # just call the function to make the widgets in the main GUI with gui(\"Updating Labels\") as app: makeCharacter(0) SubWindows Finally, you could try creating SubWindows for each set of widgets. with gui(\"Updating Labels\") as app: for pos in range(len(data)): # create the hidden subWindows with app.subWindow(data[pos][0]): app.entry(str(pos)+\"fName\", data[pos][0], label=\"First Name\") app.entry(str(pos)+\"lName\", data[pos][1], label=\"Last Name\") app.entry(str(pos)+\"country\", data[pos][2], label=\"Country\") app.entry(str(pos)+\"age\", data[pos][3], kind='numeric', label=\"Age\") # this is in the main GUI app.label(\"Pick a Character\") app.buttons([d[0] for d in data], app.showSubWindow)","title":"Multiple Pages"},{"location":"multiplePages/#multiple-pages","text":"A common question is how to have different pages of widgets in the same GUI. There are lots of ways to acheive this. All of the below are using a 2D list of data: data = [[\"Homer\", \"Simpson\", \"America\", 40], [\"Marge\", \"Simpson\", \"America\", 38], [\"Lisa\", \"Simpson\", \"America\", 12], [\"Maggie\", \"Simpson\", \"America\", 4], [\"Bart\", \"Simpson\", \"America\", 14]]","title":"Multiple Pages"},{"location":"multiplePages/#updating-labels","text":"One option is to reuse the existing widgets, and change their contents. This involves creating a single set of widgets, and then calling a function to change their contents: pos = -1 def changeCharacter(btn): global pos if btn == \"Next\": pos += 1 elif btn == \"Previous\": pos -= 1 if pos == 0: app.disableButton(\"Previous\") elif pos == len(data)-1: app.disableButton(\"Next\") else: app.enableButton(\"Previous\") app.enableButton(\"Next\") app.entry(\"First Name\", data[pos][0]) app.entry(\"Last Name\", data[pos][1]) app.entry(\"Country\", data[pos][2]) app.entry(\"Age\", data[pos][3]) with gui(\"Updating Labels\") as app: app.entry(\"First Name\", label=True) app.entry(\"Last Name\", label=True) app.entry(\"Country\", label=True) app.entry(\"Age\", kind='numeric', label=True) app.buttons([\"Previous\", \"Next\"], changeCharacter) changeCharacter(\"Next\")","title":"Updating Labels"},{"location":"multiplePages/#pagedwindow","text":"PagedWindows were introduced to allow easy navigation through multiple pages of similar data - think address books or music collections. They provide navigation buttons, a title and a page number: with gui(\"Updating Labels\") as app: with app.pagedWindow(\"Address Book\"): for pos in range(len(data)): with app.page(): app.entry(str(pos)+\"fName\", data[pos][0], label=\"First Name\") app.entry(str(pos)+\"lName\", data[pos][1], label=\"Last Name\") app.entry(str(pos)+\"country\", data[pos][2], label=\"Country\") app.entry(str(pos)+\"age\", data[pos][3], kind='numeric', label=\"Age\")","title":"PagedWindow"},{"location":"multiplePages/#tabbedframes","text":"TabbedFrames are another common way of presenting multiple pages of data in a single widget: with gui(\"Updating Labels\") as app: with app.tabbedFrame(\"Address Book\"): for pos in range(len(data)): with app.tab(data[pos][0]): app.entry(str(pos)+\"fName\", data[pos][0], label=\"First Name\") app.entry(str(pos)+\"lName\", data[pos][1], label=\"Last Name\") app.entry(str(pos)+\"country\", data[pos][2], label=\"Country\") app.entry(str(pos)+\"age\", data[pos][3], kind='numeric', label=\"Age\")","title":"TabbedFrames"},{"location":"multiplePages/#overlayed-frames","text":"A clever trick for solving this problem is to group your widgets in a Frame , and then have multiple frames in the same place. Frames are not transparent, so only the last added frame will be visible. It's possible to then raise another frame to the top. This works well, but requires keeping track of the frame: pos = -1 def changeCharacter(btn): global pos if btn == \"Next\": pos += 1 elif btn == \"Previous\": pos -= 1 if pos == 0: app.disableButton(\"Previous\") elif pos == len(data)-1: app.disableButton(\"Next\") else: app.enableButton(\"Previous\") app.enableButton(\"Next\") app.raiseFrame(str(pos)) with gui(\"Updating Labels\") as app: for loop in range(len(data)): with app.frame(str(loop), 0, 0): # put all the frames in grid pos 0,0 app.entry(str(loop)+\"fName\", data[loop][0], label=\"First Name\") app.entry(str(loop)+\"lName\", data[loop][1], label=\"Last Name\") app.entry(str(loop)+\"country\", data[loop][2], label=\"Country\") app.entry(str(loop)+\"age\", data[loop][3], kind='numeric', label=\"Age\") app.buttons([\"Previous\", \"Next\"], changeCharacter) changeCharacter(\"Next\")","title":"Overlayed Frames"},{"location":"multiplePages/#framestacks","text":"To take away some of the work from the above option, we created FrameStacks . They provide extra functions for navigating, and checking which Frame is being displayed: def changeCharacter(btn): if btn == \"Next\": app.nextFrame(\"address book\") elif btn == \"Previous\": app.prevFrame(\"address book\") if app.frameStackAtStart(\"address book\"): app.disableButton(\"Previous\") elif app.frameStackAtEnd(\"address book\"): app.disableButton(\"Next\") else: app.enableButton(\"Previous\") app.enableButton(\"Next\") with gui(\"Updating Labels\") as app: with app.frameStack(\"address book\", start=0): for loop in range(len(data)): with app.frame(): app.entry(str(loop)+\"fName\", data[loop][0], label=\"First Name\") app.entry(str(loop)+\"lName\", data[loop][1], label=\"Last Name\") app.entry(str(loop)+\"country\", data[loop][2], label=\"Country\") app.entry(str(loop)+\"age\", data[loop][3], kind='numeric', label=\"Age\") app.buttons([\"Previous\", \"Next\"], changeCharacter) app.disableButton(\"Previous\")","title":"FrameStacks"},{"location":"multiplePages/#hidingshowing","text":"Instead of putting multiple frames in the same grid cell, you can have them in different rows, and hide them : def showCharacter(btn): for pos in range(len(data)): if data[pos][0] == btn: app.showFrame(str(pos)) else: app.hideFrame(str(pos)) with gui(\"Updating Labels\") as app: for loop in range(len(data)): with app.frame(str(loop)): app.entry(str(loop)+\"fName\", data[loop][0], label=\"First Name\") app.entry(str(loop)+\"lName\", data[loop][1], label=\"Last Name\") app.entry(str(loop)+\"country\", data[loop][2], label=\"Country\") app.entry(str(loop)+\"age\", data[loop][3], kind='numeric', label=\"Age\") app.hideFrame(str(loop)) app.buttons([d[0] for d in data], showCharacter) showCharacter(\"Homer\")","title":"Hiding/Showing"},{"location":"multiplePages/#emptying-containers","text":"It's possible to quickly delete all widgets in a container, and then recreate them: def press(btn): if btn == 'SHOW': app.showSubWindow('Info') elif btn == 'EMPTY': app.emptySubWindow('Info') elif btn == 'POPULATE': makeSub() def makeSub(): with app.subWindow('Info'): app.addLabel('This will crash if not empty') with gui('Emptying Containers') as app: app.label('Try emptying a container') app.buttons(['SHOW', 'EMPTY', 'POPULATE'], press) makeSub() Alternatively, empty the container as it is populated: def reload(): showInfo({'Score':50, 'Name':'Omega', 'Occupation':'Nothing'}) def showInfo(data): with app.labelFrame('Info'): app.emptyCurrentContainer() # delete all widgets for name, value in data.items(): app.entry(name, value, label=True) with gui('Show Dict') as app: showInfo({'Score':100, 'Name':'Vida', 'Occupation':'Other'}) app.button('RELOAD', reload)","title":"Emptying Containers"},{"location":"multiplePages/#destroyingrecreating","text":"An alternative to the above is to be a bit more aggresive and destroy & recreate your widgets each time. This can be less efficient in terms of time, but more efficient in terms of memory... def showCharacter(btn): for pos in range(len(data)): if data[pos][0] == btn: app.removeAllWidgets() makeCharacter(pos) def makeCharacter(pos): with app.frame(\"character\", 0, 0): app.entry(\"fName\", data[pos][0], label=\"First Name\") app.entry(\"lName\", data[pos][1], label=\"Last Name\") app.entry(\"country\", data[pos][2], label=\"Country\") app.entry(\"age\", data[pos][3], kind='numeric', label=\"Age\") app.buttons([d[0] for d in data], showCharacter) # just call the function to make the widgets in the main GUI with gui(\"Updating Labels\") as app: makeCharacter(0)","title":"Destroying/Recreating"},{"location":"multiplePages/#subwindows","text":"Finally, you could try creating SubWindows for each set of widgets. with gui(\"Updating Labels\") as app: for pos in range(len(data)): # create the hidden subWindows with app.subWindow(data[pos][0]): app.entry(str(pos)+\"fName\", data[pos][0], label=\"First Name\") app.entry(str(pos)+\"lName\", data[pos][1], label=\"Last Name\") app.entry(str(pos)+\"country\", data[pos][2], label=\"Country\") app.entry(str(pos)+\"age\", data[pos][3], kind='numeric', label=\"Age\") # this is in the main GUI app.label(\"Pick a Character\") app.buttons([d[0] for d in data], app.showSubWindow)","title":"SubWindows"},{"location":"notes/","text":".setBg(colour) Calls .config(background=colour) Then loops through .winfo_children() And if not __widgetIsContainer() calls __setWidgetBg() .set XXX Bg(colour) If METER calls setBg If TABBEDFRAME calls setBg Else calls __setWidgetBg() -------------- .__widgetIsContainer() - checks the isContainer field .__setWidgetBg() - the big one! Checks widget type, then calls appropriate setters tabbedFrame rethink: BGs: Container - only visible at end of tab bar Tabs - active/inactive * Panes - each one Therefore: Make tabs/Panes match colour! have active/inactive writing colour * container BG activeforeground activebackground bg fg disabledforeground disabledbackground","title":"Notes"},{"location":"oldDocs/","text":"Previous Documentation appJar 0.90 appJar 0.82.1 appJar 0.07","title":"Old Documentation"},{"location":"oldDocs/#previous-documentation","text":"appJar 0.90 appJar 0.82.1 appJar 0.07","title":"Previous Documentation"},{"location":"outputWidgets/","text":"Output Widgets In a GUI, the fillings are known as widgets . There are lots of different widgets to choose from, each suited to a specific task - we've grouped them into output widgets & input widgets . Output widgets are used for displaying information to a user. They usually provide three functions: ADD - this creates the widget GET - this gets the contents of the widget SET - this changes the contents of the widget As well as options to change the way they look/act . For each of the above to work, we need to know which widget you are referring to - so every widget gets a unique title . Label Labels are used for displaying text in the GUI. They are great for titles, at the top of the GUI, usually spanning multiple columns. They are really useful before Entries and Drop-downs to explain their purpose. And, they're very helpful at the bottom of the GUI, to show the results of an action. from appJar import gui app = gui() app.addLabel(\"l1\", \"Label 1\") app.addLabel(\"l2\", \"Label 2\") app.addLabel(\"l3\", \"Label 3\") app.addLabel(\"l4\", \"Label 4\") # common set functions app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"yellow\") app.setLabelBg(\"l3\", \"purple\") app.setLabelBg(\"l4\", \"orange\") app.go() Add Labels .addLabel(title, text=None) This will create a label widget to display text in the GUI. The title is used to uniquely identify the label, in case you want to change it later, and the text is what gets displayed. If text is set to None, or no text is provided, the title will be displayed in the label. .addEmptyLabel(title) Does the same as add a label , except there's no parameter to set any text. .addSelectableLabel(title, text=None) This adds a label whose text can be selected with the mouse. This is really just a read-only Entry, disguised to look like a label. But it seems to do the trick... .addFlashLabel(title, text=None) This adds a flashing label , that will alternate between the foreground and background colours. from appJar import gui app = gui() app.addFlashLabel(\"f1\", \"This is flashing\") app.addLabel(\"f2\", \"This is not flashing\") app.addFlashLabel(\"f3\", \"This is also flashing\") app.go() Set Labels .setLabel(title, text) Change the contents of the label . .clearLabel(title) Clear the contents of the label . .clearAllLabels() Clears the contents of all labels . Get Labels .getLabel(title) Get the contents of the label . Auto-Labelled Widgets It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does. Message Very similar to a Label, except it will wrap the text over multiple lines. By default the text is laid out 50% wider than it is high. This can be changed by setting a specific width or by changing the aspect ratio. from appJar import gui app=gui() app.setFont(12) app.addMessage(\"mess\", \"\"\"You can put a lot of text in this widget. The text will be wrapped over multiple lines. It's not possible to apply different styles to different words.\"\"\") app.go() Add Messages .addMessage(title, text) Adds a Message widget, with the specified text. If not text is provided, the title will be used for the text. .addEmptyMessage(title) Adds an empty Message widget. Set Messages .clearMessage(title) Clears the specified Message widget. .setMessage(title, text) Sets the contents of the specified Message widget, to the specified text. .setMessageAspect(title, aspect) Sets the aspect ratio at which text is wrapped. The default is 150, which means the text will be 50% wider than it is high. Ignored if a width has been set. .setMessageWidth(title, width) Sets the number of characters per line for the widget. If not set, width is calculated using the default aspect ratio. Meter Various styles of progress meter: Meter A simple meter for showing progress from 0% to 100%. SplitMeter A possession style meter, showing percentages on either side. DualMeter Two separate meters, expanding out from the middle. from appJar import gui app=gui() app.addMeter(\"progress\") app.setMeterFill(\"progress\", \"blue\") app.go() Add Meters .addMeter(name) & .addSplitMeter(name) & .addDualMeter(name) Adds a meter with the specified name, of the specified type. Set Meters .setMeter(name, value, text=None) Changes the specified meter to the specified value. For Meter & SplitMeter should be a value between 0 and 100. For DualMeter should be a list of two values, each between 0 and 100. .setMeterFill(name, colour) Changes the fill colour of the specified meter. For SplitMeter & DualMeter should be a list of two colours. Get Meters .getMeter(name) Gets the value of the specified meter. As meters convert their data to a value between 0 and 1, this will return a list of two values: (0.45, '45 %') .getAllMeters() This will return the contents of all Meters in the app, as a dictionary. Background Processing Meters are designed to show progress over time. One common solution is to register a function that is constantly updating a meter. This should then be monitoring/updating a global variable: def updateMeter(): app.setMeter(\"progress\", percentComplete) # schedule function to be called regularly app.registerEvent(updateMeter) Separator Useful for indicating separation between widgets. Will draw a horizontal/vertical line spanning the cell. from appJar import gui app=gui() app.setBg(\"lightBlue\") app.addHorizontalSeparator(0,0,4, colour=\"red\") app.addVerticalSeparator(1,0, colour=\"red\") app.addVerticalSeparator(1,1, colour=\"red\") app.addVerticalSeparator(1,2, colour=\"red\") app.addVerticalSeparator(1,3, colour=\"red\") app.addHorizontalSeparator(2,0,4, colour=\"red\") app.go() Add Seperators .addHorizontalSeparator(colour=None) & .addVerticalSeparator(colour=None) Adds a separator (a horizontal or vertical line) spanning the cell. An optional colour can be passed in, to set a colour for the separator. Grip Clickable icon to drag the window around. from appJar import gui app=gui() app.setFont(20) app.setBg(\"lightBlue\") app.addLabel(\"l1\", \"Move me around...\", 0, 0) app.addGrip(0,1) app.addSeparator(1,0,2, colour=\"red\") app.go() Add Grips .addGrip() Adds a simple grip icon. The mouse pointer changes over the grip, and a ToolTip will be shown. The size and image can't be changed. Canvas This lets you embed a canvas in appJar. Canvases are very powerful, appJar will never provide wrappers for all their functions. So, if you're looking to truly harness a canvas, add it and save the widget as a variable: canvas = app.addCanvas(\"c1\") . Then, you can call all the canvas functions as you would a tKinter canvas. from appJar import gui app=gui() app.addCanvas(\"c1\") app.addCanvasOval(\"c1\", 10, 10, 100, 100, fill=\"red\", outline=\"blue\", width=3) app.addCanvasLine(\"c1\", 0, 0, 255, 255, width=5) app.addCanvasLine(\"c1\", 0, 255, 255, 0, dash=123) app.go() Or, as mentioned above, you can work directly with the canvas object: from appJar import gui app=gui() canvas = app.addCanvas(\"c1\") canvas.create_oval(10, 10, 100, 100, fill=\"red\", outline=\"blue\", width=3) canvas.create_line(0, 0, 255, 255, width=5) canvas.create_line(0, 255, 255, 0, dash=123) app.go() .addCanvas(title) Creates a canvas widget. .getCanvas(title) Gets the specified canvas widget. Setting a Canvas .setCanvasMap(title, func, coords) It is possible to set up a simple CanvasMap - a clickable canvas, with names linked to different areas. When one of those areas is clicked, a function will be called, passing the name of the area as a parameter. coords must contain a dictionary of areas on the map. When a position on the canavs is clicked, in one of the areas, the named function will be called, passing in the area's name. When an unknown position on the canavs is clicked, UNKNOWN will be passed to the function, along with the coordinates. Drawing on a Canvas NB. each of these functions returns the object being created, so you can later change it: canvas = app.addCanvas(\"c1\") rect = app.addCanvasRectangle(\"c1\", x=40, y=80, w=100, h=100, fill='green') canvas.itemconfig(rect, fill='pink') .addCanvasCircle(title, x, y, diameter, **kwargs) Draws a circle on the canvas. .addCanvasOval(title, x, y, xDiam, yDiam, **kwargs) Draws an oval on the canvas. .addCanvasRectangle(title, x, y, w, h, **kwargs) Draws a rectangle on the canvas. .addCanvasLine(title, x, y, x2, y2, **kwargs) Draws a line on the canvas. .addCanvasText(title, x, y, text, **kwargs) Draws text on the canvas. .addCanvasImage(title, x, y, image, **kwargs) Draws the specified image on the canvas. .clearCanvas(title) Removes all items from the canvas. Turtle This lets you embed a turtle widget in appJar. from appJar import gui def press(b): s = app.getTurtleScreen(\"t1\") t = app.getTurtle(\"t1\") s.bgcolor(\"blue\") t.pencolor(\"white\") for i in range(20): t.forward(i * 10) t.right(144) app=gui() app.addTurtle(\"t1\") app.addButton(\"DRAW\", press) app.go() .addTurtle(title) Creates a turtle widget. .getTurtle(title) Gets the specified turtle widget. .getTurtleScreen(title) Gets the screen behind the turtle widget. MicroBit Emulator Widget to emulate a MicroBit from appJar import gui app = gui() app.addMicroBit(\"mb1\") app.setMicroBitImage(\"mb1\", \"09090:90909:90009:09090:00900\") app.go() Add MicroBits .addMicroBit(title) Will create a 5x5 grid emulating the MicroBit LEDs. Set MicroBits .setMicroBitImage(title, image) This sets each pixel to the specified brightness (0 to 9). Each set of 5 digits represents a row of pixels, from top to bottom. .setMicroBitPixel(title, x, y, brightness) Will set the brightness of the specified pixel. x & y should be between 0 & 4. brightness should be a value between 0 & 9 to represent how bright to make the pixel. .clearMicroBit(title) Will turn off all of the pixels - setting their brightness to 0. GoogleMaps A self-contained GoogleMaps widget. It provides useful functionality for finding somewhere on Earth. All requests for map data are performed in the background, so the UI shouldn't become unresponsive. from appjar import gui app = gui() app.addGoogleMap(\"m1\") app.setGoogleMapSize(\"m1\", \"300x500\") app.go() Add GoogleMaps .addGoogleMap(title) Creates a GoogleMap widget. Displays a map image, and provides functionality to search, zoom, and change terrain, as well as a link to the original image. Set GoogleMaps .searchGoogleMap(title, location) Update the named GoogleMap widget to show the specified location. .zoomGoogleMap(title, mod) Change the zoom level of the named GoogleMap. Providing a + or - will cause the map to zoom in or out one level. Otherwise, a digit between 0 and 22 should be provided, to set the zoom level. .setGoogleMapTerrain(title, terrain) .setGoogleMapSize(title, size) Set the size of the GoogleMap. Should be in the format \"300x300\" . Note, if you set it too small, the control widgets won't look good... .setGoogleMapMarker(title, location, size=None, colour=None, label=None, replace=False) Will drop a marker on the specified location. The marker will only be visible if the current location & zoom level permit. If an empty location is provided, all markers will be removed. colour can be set to any of (black, brown, green, purple, yellow, blue, gray, orange, red, white) or a hex value (starting '0x'). size can be set to any of (tiny, mid, small). label can be set to a single letter or digit. If replace is True this marker will replace the last one added. .removeGoogleMapMarker(title, label) Will remove the specified marker, if found. Get GoogleMaps .getGoogleMapLocation(title) Returns the current displayed location. Will return an empty String, if the user clicked the H button. .getGoogleMapZoom(title) Returns the current zoom level of the map tile. .getGoogleMapTerrain(title) Returns the current terrain setting for the map tile. .getGoogleMapSize(title) Returns the current size of the map tile. Save GoogleMaps .saveGoogleMap(title, fileName) Saves the currently displayed map to the named location. By default, all map tiles are GIFs. PieChart Widget to depict a Pie Chart. It will automatically calculate percentages, and draw a pie chart, given a dictionary of items and their amount. The PieChart is purely for display purposes, and is not interactive, other than a simple mouse-over effect with a tooltip. from appJar import gui app = gui() app.addPieChart(\"p1\", {\"apples\":50, \"oranges\":200, \"grapes\":75, \"beef\":300, \"turkey\":150}) app.go() Add PieCharts .addPieChart(title, values) Takes a dictionary of names and values, which will be converted to percentages, and plotted on the chart. The names will be used as part of tooltips that appear over each wedge of the PieChart. Set PieCharts .setPieChart(title, name, value) Will update the PieChart, by either changing an existing value, adding a new value, or removing a value if it's set to 0. MatPlotLib Support for embedding very basic MatPlotLib plots. from numpy import sin, pi, arange from appJar import gui import random def getXY(): x = arange(0.0, 3.0, 0.01) y = sin(random.randint(1,10) * pi * x) return x,y def generate(btn): # *getXY() will unpack the two return values # and pass them as separate parameters app.updatePlot(\"p1\", *getXY()) showLabels() def showLabels(): axes.legend(['The curve']) axes.set_xlabel(\"X Axes\") axes.set_ylabel(\"Y Axes\") app.refreshPlot(\"p1\") app = gui() axes = app.addPlot(\"p1\", *getXY()) showLabels() app.addButton(\"Generate\", generate) app.go() .addPlot(title, x, y) Create a plot with the specified x and y values. Returns the plot object, to allow further customisation. Set showNav to True, to include a navigation bar .addPlotFig(title) Create an empty Figure, so that you can add your own plots. Returns the figure object, to allow further customisation. Set showNav to True, to include a navigation bar from appJar import gui from mpl_toolkits.mplot3d import Axes3D with gui() as app: fig = app.addPlotFig(\"p1\") ax = fig.add_subplot(111, projection='3d') ax.scatter([1,2],[1,2],[1,2]) .updatePlot(title, x, y, keepLabels=False) Update the specified plot with the specified x and y values. NB. if you do this you will lose any customisations applied to the axes. If you set keepLabels to True, then the axis labels & title will be retained. Also, your app will crash, if you call this after .addPlotFig() .refreshPlot(title) Call this any time you modify the axes.","title":"Output Widgets"},{"location":"outputWidgets/#output-widgets","text":"In a GUI, the fillings are known as widgets . There are lots of different widgets to choose from, each suited to a specific task - we've grouped them into output widgets & input widgets . Output widgets are used for displaying information to a user. They usually provide three functions: ADD - this creates the widget GET - this gets the contents of the widget SET - this changes the contents of the widget As well as options to change the way they look/act . For each of the above to work, we need to know which widget you are referring to - so every widget gets a unique title .","title":"Output Widgets"},{"location":"outputWidgets/#label","text":"Labels are used for displaying text in the GUI. They are great for titles, at the top of the GUI, usually spanning multiple columns. They are really useful before Entries and Drop-downs to explain their purpose. And, they're very helpful at the bottom of the GUI, to show the results of an action. from appJar import gui app = gui() app.addLabel(\"l1\", \"Label 1\") app.addLabel(\"l2\", \"Label 2\") app.addLabel(\"l3\", \"Label 3\") app.addLabel(\"l4\", \"Label 4\") # common set functions app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"yellow\") app.setLabelBg(\"l3\", \"purple\") app.setLabelBg(\"l4\", \"orange\") app.go()","title":"Label"},{"location":"outputWidgets/#add-labels","text":".addLabel(title, text=None) This will create a label widget to display text in the GUI. The title is used to uniquely identify the label, in case you want to change it later, and the text is what gets displayed. If text is set to None, or no text is provided, the title will be displayed in the label. .addEmptyLabel(title) Does the same as add a label , except there's no parameter to set any text. .addSelectableLabel(title, text=None) This adds a label whose text can be selected with the mouse. This is really just a read-only Entry, disguised to look like a label. But it seems to do the trick... .addFlashLabel(title, text=None) This adds a flashing label , that will alternate between the foreground and background colours. from appJar import gui app = gui() app.addFlashLabel(\"f1\", \"This is flashing\") app.addLabel(\"f2\", \"This is not flashing\") app.addFlashLabel(\"f3\", \"This is also flashing\") app.go()","title":"Add Labels"},{"location":"outputWidgets/#set-labels","text":".setLabel(title, text) Change the contents of the label . .clearLabel(title) Clear the contents of the label . .clearAllLabels() Clears the contents of all labels .","title":"Set Labels"},{"location":"outputWidgets/#get-labels","text":".getLabel(title) Get the contents of the label .","title":"Get Labels"},{"location":"outputWidgets/#auto-labelled-widgets","text":"It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does.","title":"Auto-Labelled Widgets"},{"location":"outputWidgets/#message","text":"Very similar to a Label, except it will wrap the text over multiple lines. By default the text is laid out 50% wider than it is high. This can be changed by setting a specific width or by changing the aspect ratio. from appJar import gui app=gui() app.setFont(12) app.addMessage(\"mess\", \"\"\"You can put a lot of text in this widget. The text will be wrapped over multiple lines. It's not possible to apply different styles to different words.\"\"\") app.go()","title":"Message"},{"location":"outputWidgets/#add-messages","text":".addMessage(title, text) Adds a Message widget, with the specified text. If not text is provided, the title will be used for the text. .addEmptyMessage(title) Adds an empty Message widget.","title":"Add Messages"},{"location":"outputWidgets/#set-messages","text":".clearMessage(title) Clears the specified Message widget. .setMessage(title, text) Sets the contents of the specified Message widget, to the specified text. .setMessageAspect(title, aspect) Sets the aspect ratio at which text is wrapped. The default is 150, which means the text will be 50% wider than it is high. Ignored if a width has been set. .setMessageWidth(title, width) Sets the number of characters per line for the widget. If not set, width is calculated using the default aspect ratio.","title":"Set Messages"},{"location":"outputWidgets/#meter","text":"Various styles of progress meter:","title":"Meter"},{"location":"outputWidgets/#meter_1","text":"A simple meter for showing progress from 0% to 100%.","title":"Meter"},{"location":"outputWidgets/#splitmeter","text":"A possession style meter, showing percentages on either side.","title":"SplitMeter"},{"location":"outputWidgets/#dualmeter","text":"Two separate meters, expanding out from the middle. from appJar import gui app=gui() app.addMeter(\"progress\") app.setMeterFill(\"progress\", \"blue\") app.go()","title":"DualMeter"},{"location":"outputWidgets/#add-meters","text":".addMeter(name) & .addSplitMeter(name) & .addDualMeter(name) Adds a meter with the specified name, of the specified type.","title":"Add Meters"},{"location":"outputWidgets/#set-meters","text":".setMeter(name, value, text=None) Changes the specified meter to the specified value. For Meter & SplitMeter should be a value between 0 and 100. For DualMeter should be a list of two values, each between 0 and 100. .setMeterFill(name, colour) Changes the fill colour of the specified meter. For SplitMeter & DualMeter should be a list of two colours.","title":"Set Meters"},{"location":"outputWidgets/#get-meters","text":".getMeter(name) Gets the value of the specified meter. As meters convert their data to a value between 0 and 1, this will return a list of two values: (0.45, '45 %') .getAllMeters() This will return the contents of all Meters in the app, as a dictionary.","title":"Get Meters"},{"location":"outputWidgets/#background-processing","text":"Meters are designed to show progress over time. One common solution is to register a function that is constantly updating a meter. This should then be monitoring/updating a global variable: def updateMeter(): app.setMeter(\"progress\", percentComplete) # schedule function to be called regularly app.registerEvent(updateMeter)","title":"Background Processing"},{"location":"outputWidgets/#separator","text":"Useful for indicating separation between widgets. Will draw a horizontal/vertical line spanning the cell. from appJar import gui app=gui() app.setBg(\"lightBlue\") app.addHorizontalSeparator(0,0,4, colour=\"red\") app.addVerticalSeparator(1,0, colour=\"red\") app.addVerticalSeparator(1,1, colour=\"red\") app.addVerticalSeparator(1,2, colour=\"red\") app.addVerticalSeparator(1,3, colour=\"red\") app.addHorizontalSeparator(2,0,4, colour=\"red\") app.go()","title":"Separator"},{"location":"outputWidgets/#add-seperators","text":".addHorizontalSeparator(colour=None) & .addVerticalSeparator(colour=None) Adds a separator (a horizontal or vertical line) spanning the cell. An optional colour can be passed in, to set a colour for the separator.","title":"Add Seperators"},{"location":"outputWidgets/#grip","text":"Clickable icon to drag the window around. from appJar import gui app=gui() app.setFont(20) app.setBg(\"lightBlue\") app.addLabel(\"l1\", \"Move me around...\", 0, 0) app.addGrip(0,1) app.addSeparator(1,0,2, colour=\"red\") app.go()","title":"Grip"},{"location":"outputWidgets/#add-grips","text":".addGrip() Adds a simple grip icon. The mouse pointer changes over the grip, and a ToolTip will be shown. The size and image can't be changed.","title":"Add Grips"},{"location":"outputWidgets/#canvas","text":"This lets you embed a canvas in appJar. Canvases are very powerful, appJar will never provide wrappers for all their functions. So, if you're looking to truly harness a canvas, add it and save the widget as a variable: canvas = app.addCanvas(\"c1\") . Then, you can call all the canvas functions as you would a tKinter canvas. from appJar import gui app=gui() app.addCanvas(\"c1\") app.addCanvasOval(\"c1\", 10, 10, 100, 100, fill=\"red\", outline=\"blue\", width=3) app.addCanvasLine(\"c1\", 0, 0, 255, 255, width=5) app.addCanvasLine(\"c1\", 0, 255, 255, 0, dash=123) app.go() Or, as mentioned above, you can work directly with the canvas object: from appJar import gui app=gui() canvas = app.addCanvas(\"c1\") canvas.create_oval(10, 10, 100, 100, fill=\"red\", outline=\"blue\", width=3) canvas.create_line(0, 0, 255, 255, width=5) canvas.create_line(0, 255, 255, 0, dash=123) app.go() .addCanvas(title) Creates a canvas widget. .getCanvas(title) Gets the specified canvas widget.","title":"Canvas"},{"location":"outputWidgets/#setting-a-canvas","text":".setCanvasMap(title, func, coords) It is possible to set up a simple CanvasMap - a clickable canvas, with names linked to different areas. When one of those areas is clicked, a function will be called, passing the name of the area as a parameter. coords must contain a dictionary of areas on the map. When a position on the canavs is clicked, in one of the areas, the named function will be called, passing in the area's name. When an unknown position on the canavs is clicked, UNKNOWN will be passed to the function, along with the coordinates.","title":"Setting a Canvas"},{"location":"outputWidgets/#drawing-on-a-canvas","text":"NB. each of these functions returns the object being created, so you can later change it: canvas = app.addCanvas(\"c1\") rect = app.addCanvasRectangle(\"c1\", x=40, y=80, w=100, h=100, fill='green') canvas.itemconfig(rect, fill='pink') .addCanvasCircle(title, x, y, diameter, **kwargs) Draws a circle on the canvas. .addCanvasOval(title, x, y, xDiam, yDiam, **kwargs) Draws an oval on the canvas. .addCanvasRectangle(title, x, y, w, h, **kwargs) Draws a rectangle on the canvas. .addCanvasLine(title, x, y, x2, y2, **kwargs) Draws a line on the canvas. .addCanvasText(title, x, y, text, **kwargs) Draws text on the canvas. .addCanvasImage(title, x, y, image, **kwargs) Draws the specified image on the canvas. .clearCanvas(title) Removes all items from the canvas.","title":"Drawing on a Canvas"},{"location":"outputWidgets/#turtle","text":"This lets you embed a turtle widget in appJar. from appJar import gui def press(b): s = app.getTurtleScreen(\"t1\") t = app.getTurtle(\"t1\") s.bgcolor(\"blue\") t.pencolor(\"white\") for i in range(20): t.forward(i * 10) t.right(144) app=gui() app.addTurtle(\"t1\") app.addButton(\"DRAW\", press) app.go() .addTurtle(title) Creates a turtle widget. .getTurtle(title) Gets the specified turtle widget. .getTurtleScreen(title) Gets the screen behind the turtle widget.","title":"Turtle"},{"location":"outputWidgets/#microbit-emulator","text":"Widget to emulate a MicroBit from appJar import gui app = gui() app.addMicroBit(\"mb1\") app.setMicroBitImage(\"mb1\", \"09090:90909:90009:09090:00900\") app.go()","title":"MicroBit Emulator"},{"location":"outputWidgets/#add-microbits","text":".addMicroBit(title) Will create a 5x5 grid emulating the MicroBit LEDs.","title":"Add MicroBits"},{"location":"outputWidgets/#set-microbits","text":".setMicroBitImage(title, image) This sets each pixel to the specified brightness (0 to 9). Each set of 5 digits represents a row of pixels, from top to bottom. .setMicroBitPixel(title, x, y, brightness) Will set the brightness of the specified pixel. x & y should be between 0 & 4. brightness should be a value between 0 & 9 to represent how bright to make the pixel. .clearMicroBit(title) Will turn off all of the pixels - setting their brightness to 0.","title":"Set MicroBits"},{"location":"outputWidgets/#googlemaps","text":"A self-contained GoogleMaps widget. It provides useful functionality for finding somewhere on Earth. All requests for map data are performed in the background, so the UI shouldn't become unresponsive. from appjar import gui app = gui() app.addGoogleMap(\"m1\") app.setGoogleMapSize(\"m1\", \"300x500\") app.go()","title":"GoogleMaps"},{"location":"outputWidgets/#add-googlemaps","text":".addGoogleMap(title) Creates a GoogleMap widget. Displays a map image, and provides functionality to search, zoom, and change terrain, as well as a link to the original image.","title":"Add GoogleMaps"},{"location":"outputWidgets/#set-googlemaps","text":".searchGoogleMap(title, location) Update the named GoogleMap widget to show the specified location. .zoomGoogleMap(title, mod) Change the zoom level of the named GoogleMap. Providing a + or - will cause the map to zoom in or out one level. Otherwise, a digit between 0 and 22 should be provided, to set the zoom level. .setGoogleMapTerrain(title, terrain) .setGoogleMapSize(title, size) Set the size of the GoogleMap. Should be in the format \"300x300\" . Note, if you set it too small, the control widgets won't look good... .setGoogleMapMarker(title, location, size=None, colour=None, label=None, replace=False) Will drop a marker on the specified location. The marker will only be visible if the current location & zoom level permit. If an empty location is provided, all markers will be removed. colour can be set to any of (black, brown, green, purple, yellow, blue, gray, orange, red, white) or a hex value (starting '0x'). size can be set to any of (tiny, mid, small). label can be set to a single letter or digit. If replace is True this marker will replace the last one added. .removeGoogleMapMarker(title, label) Will remove the specified marker, if found.","title":"Set GoogleMaps"},{"location":"outputWidgets/#get-googlemaps","text":".getGoogleMapLocation(title) Returns the current displayed location. Will return an empty String, if the user clicked the H button. .getGoogleMapZoom(title) Returns the current zoom level of the map tile. .getGoogleMapTerrain(title) Returns the current terrain setting for the map tile. .getGoogleMapSize(title) Returns the current size of the map tile.","title":"Get GoogleMaps"},{"location":"outputWidgets/#save-googlemaps","text":".saveGoogleMap(title, fileName) Saves the currently displayed map to the named location. By default, all map tiles are GIFs.","title":"Save GoogleMaps"},{"location":"outputWidgets/#piechart","text":"Widget to depict a Pie Chart. It will automatically calculate percentages, and draw a pie chart, given a dictionary of items and their amount. The PieChart is purely for display purposes, and is not interactive, other than a simple mouse-over effect with a tooltip. from appJar import gui app = gui() app.addPieChart(\"p1\", {\"apples\":50, \"oranges\":200, \"grapes\":75, \"beef\":300, \"turkey\":150}) app.go()","title":"PieChart"},{"location":"outputWidgets/#add-piecharts","text":".addPieChart(title, values) Takes a dictionary of names and values, which will be converted to percentages, and plotted on the chart. The names will be used as part of tooltips that appear over each wedge of the PieChart.","title":"Add PieCharts"},{"location":"outputWidgets/#set-piecharts","text":".setPieChart(title, name, value) Will update the PieChart, by either changing an existing value, adding a new value, or removing a value if it's set to 0.","title":"Set PieCharts"},{"location":"outputWidgets/#matplotlib","text":"Support for embedding very basic MatPlotLib plots. from numpy import sin, pi, arange from appJar import gui import random def getXY(): x = arange(0.0, 3.0, 0.01) y = sin(random.randint(1,10) * pi * x) return x,y def generate(btn): # *getXY() will unpack the two return values # and pass them as separate parameters app.updatePlot(\"p1\", *getXY()) showLabels() def showLabels(): axes.legend(['The curve']) axes.set_xlabel(\"X Axes\") axes.set_ylabel(\"Y Axes\") app.refreshPlot(\"p1\") app = gui() axes = app.addPlot(\"p1\", *getXY()) showLabels() app.addButton(\"Generate\", generate) app.go() .addPlot(title, x, y) Create a plot with the specified x and y values. Returns the plot object, to allow further customisation. Set showNav to True, to include a navigation bar .addPlotFig(title) Create an empty Figure, so that you can add your own plots. Returns the figure object, to allow further customisation. Set showNav to True, to include a navigation bar from appJar import gui from mpl_toolkits.mplot3d import Axes3D with gui() as app: fig = app.addPlotFig(\"p1\") ax = fig.add_subplot(111, projection='3d') ax.scatter([1,2],[1,2],[1,2]) .updatePlot(title, x, y, keepLabels=False) Update the specified plot with the specified x and y values. NB. if you do this you will lose any customisations applied to the axes. If you set keepLabels to True, then the axis labels & title will be retained. Also, your app will crash, if you call this after .addPlotFig() .refreshPlot(title) Call this any time you modify the axes.","title":"MatPlotLib"},{"location":"packaging/","text":"Packaging appJar Apps .pyw files on Windows If you're on Windows, there is a clever way to make your python files act like executables. If you change the file extension to be .pyw instead of .py then you will be able to double click the file, and launch it as a GUI application, with no terminal showing up. Packaging with PyInstaller The recommended way to package appJar is to use PyInstaller First, download and install PyInstaller. If everything has been installed via pip, then you should be able to package your application with the following command: pyinstaller -F -w demo.py If not, then you may need to specify the path of certain libraries: pyinstaller -F -w -p <path_to_appJar> demo.py Setting an app Icon To set an icon for the app, include the following option: pyinstaller -i <path_to_icon> -F -w demo.py Including Images To include images, include the following option: appinstaller --add-data image.png:. -F -w demo.py Platform Support This has been tested & works under both Windows & Linux, although no success (yet) on OSX. A lot more detail will be provided here, in a future release, on the exact process to follow to get everything built into your package.","title":"Packaging"},{"location":"packaging/#packaging-appjar-apps","text":"","title":"Packaging appJar Apps"},{"location":"packaging/#pyw-files-on-windows","text":"If you're on Windows, there is a clever way to make your python files act like executables. If you change the file extension to be .pyw instead of .py then you will be able to double click the file, and launch it as a GUI application, with no terminal showing up.","title":".pyw files on Windows"},{"location":"packaging/#packaging-with-pyinstaller","text":"The recommended way to package appJar is to use PyInstaller First, download and install PyInstaller. If everything has been installed via pip, then you should be able to package your application with the following command: pyinstaller -F -w demo.py If not, then you may need to specify the path of certain libraries: pyinstaller -F -w -p <path_to_appJar> demo.py","title":"Packaging with PyInstaller"},{"location":"packaging/#setting-an-app-icon","text":"To set an icon for the app, include the following option: pyinstaller -i <path_to_icon> -F -w demo.py","title":"Setting an app Icon"},{"location":"packaging/#including-images","text":"To include images, include the following option: appinstaller --add-data image.png:. -F -w demo.py","title":"Including Images"},{"location":"packaging/#platform-support","text":"This has been tested & works under both Windows & Linux, although no success (yet) on OSX. A lot more detail will be provided here, in a future release, on the exact process to follow to get everything built into your package.","title":"Platform Support"},{"location":"pythonBars/","text":"Toolbars, Menubars & Statusbars Toolbars and Menubars are features common to most GUIs, you'll be used to seeing them along the top of apps, such as MS Word. Statusbars are also useful features, they allow you to show information about what's going on in a GUI, usually along the bottom of the app. Toolbar Toolbars (sometimes known as ribbons) appear across the top of a GUI. They offer a series of buttons to click, which can be used to change settings/functionality in a GUI. NB. Icons don't work in python 2.7, due to an issue showing PNG images. tools = [\"ABOUT\", \"REFRESH\", \"OPEN\", \"CLOSE\", \"SAVE\", \"NEW\", \"SETTINGS\", \"PRINT\", \"SEARCH\", \"UNDO\", \"REDO\", \"PREFERENCES\", \"HOME\", \"HELP\", \"CALENDAR\", \"WEB\", \"OFF\"] app.addToolbar(tools, tbFunc, findIcon=True) Create Toolbars .addToolbar(names, funcs, findIcon=False) Will add a list of buttons along the top, in a toolbar. Each button will call the corresponding function. If only one function is supplied, they will all call the same function, providing the button's name as a parameter. A set of icons is available, if findIcon is set to True, then appJar will attempt to find an icon for each button. .addToolbarButton(name, func, findIcon=False) Adds a single button to the toolbar - see above. Set Toolbars .setToolbarPinned(pinned=True) Will configure the toolbar to be pinnable When the mouse is not over the toolbar it will minimise. The toolbar will also gain an extra button (a pin) allowing the user to configure it to be pinned or not. .setToolbarIcon(name, icon) Will set an icon for the corresponding button in the toolbar. Use the name of any of the icons in the resource folder (without the folder or file extension). .setToolbarImage(name, image) Will set an image for the corresponding button in the toolbar. .setToolbarEnabled() & .setToolbarDisabled() Will enable/disable all buttons on the toolbar. .setToolbarButtonEnabled(name) & .setToolbarButtonDisabled(name) Will enable/disable the named toolbar button. .showToolbar() & .hideToolbar() Will show/hide the toolbar. .removeToolbarButton(name, hide=True) Will remove the named button from the toolbar. The toolbar will be hidden when there are no buttons on it, unless hide is set to False. .removeToolbar(hide=True) Will remove all buttons from the toolbar. The empty toolbar will be hidden, unless hide is set to False. .setToolbarBg(bg) Will change the toolbar to be the specified colour. The empty toolbar will be hidden, unless hide is set to False. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Menubar Adds a Menubar along the top of the GUI. On Windows/Linux a menubar will only be shown, once the first menu has been added. On Mac, a menubar is always present. Menubars are made up of a series of menus, each containing a list of items: Menu-items - a clickable button, that calls a function Radio-buttons - groups of options, only one of which can be selected Checkboxes - boxes that can be ticked or unticked Separators - lines to help group items together Submenus - another menu, with its own list of items Create Menus fileMenus = [\"Open\", \"Save\", \"Save as...\", \"-\", \"Export\", \"Print\", \"-\", \"Close\"] app.addMenuList(\"File\", fileMenus, menuPress) # create the File menu, with the list of items .addMenuList(menu, names, functions) Will create a new menu, containing the list of names. Provide a single function - all names will call that function, passing their name. Or a list of functions (the same length as names), each menu will call the corresponding function. If a name is a - , then a separator will be added to the menu. .createMenu(menu, tearable=False) Will create a new, empty menu, to add menu-items to. .addMenuItem(menu, name, func=None, shortcut=None, underline=-1) Add a menu-item to the menu, with the specified function. If the named menu does not exist, it will be automatically created. If the name is - , then a separator will be added to the menu. .addMenuSeparator(menu) Add a separator to the menu. .addMenuCheckBox(menu, name, function=None, shortcut=None, underline=-1) Add a check box, to the menu, with the specified name. .addMenuRadioButton(menu, name, value, function=None, shortcut=None, underline=-1) Add a radio button, to the menu, grouped by name, with the specified value. app.createMenu(\"Config\") for i in range(5): app.addMenuRadioButton(\"Config\", \"font\", \"1\" + str(i), menuPress) app.addMenuSeparator(\"Config\") for i in range(5): app.addMenuCheckBox(\"Config\", \"Size 1\" + str(i), menuPress) .addSubMenu(menu, subMenu) Adds a sub-menu to the specified menu. Then add menu-items to this menu (using its name). app.createMenu(\"Config\") app.addSubMenu(\"Config\", \"Font Size\") for i in range(5): app.addMenuRadioButton(\"Font Size\", \"font\", \"1\" + str(i), menuPress) .addMenu(menu, function, shortcut=None, underline=-1) This is a special case, and doesn't work on all platforms. Adds a single menu, with no list of menu-items, that calls the specified function. Set Menus .setMenuCheckBox(menu, name) Inverts the specified check box, in the named menu. .setMenuRadioButton(menu, name, value) Selects the specified value, of the specified radio button, in the named menu. .setMenuImage(menu, name, image, align='text') Will set the specified image for the specified menu-item. .setMenuIcon(menu, name, icon, align='text') Will set the specified icon for the specified menu-item. .disableMenuItem(menu, name) & .enableMenuItem(menu, name) Will enable/disable the specified menu-item. .disableMenu(menu) & .enableMenu(menu) Will disable/enable the specified menu. .disableMenubar() & .enableMenubar() Will disable/enable all menus. NB. currently doesn't disable entries in default Mac menus. .deleteMenuItem(menu, name) Will delete the named item from the specified menu. Get Menus .getMenuCheckBox(menu, name) Get the value of the specified check box, from the named menu. Returns True or False. .getMenuRadioButton(menu, name) Get the value of the specified radio button, from the named menu. Returns the name of the checked radio button, for this group. Extra Features: These options aren't available when you add a list of menu-items, only when you call the specific add function. underline - if set to an Integer, the corresponding character will be underlined. tearable - if set to True, it's possible to undock the menu. shortcut - these are keyboard shortcuts you press, to call a menu-item. They should always be a combination of special keys and a regular key , separated by dashes. e.g. \"Control-s\" or \"Control-Shift-z\" The following special keys are available: Control , Option , Alt , Shift , Command , Meta There are some special cases: If you want to use numbers, you need to use the format: Control-Key-3 If you want some of the special characters, you may need to use their name: Control-slash , Control-Up NB. don't include angle brackets <> around the shortcut. NB. Lookout for clashes with regular key bindings Platform Specific/Custom Menus There are a few special menus available; pop-up menus, that appear when you right-click a widget and platform specific menus. To add items to these menus, use the menu names given below (eg. app.addMenuItem('EDIT', 'Name', func) ) Right-Click Menus Edit Menu (name: EDIT ) - provides a cut & paste style menu linked to all text , entry & option boxes . Call .addMenuEdit(inMenuBar=False) to enable the Edit menu. If showInBar is set to True , the Menu will also appear in the topLevel Menubar. This menu does its best to show the appropriate options, for all situations - but doesn't know when you can't redo an action. Generic Menu Call .createRightClickMenu(menu, showInBar=False) to create an empty right-click menu If showInBar is set to True , the Menu will also appear in the topLevel Menubar. The right-click menu can be populated the same way as regular menus. To link the right-click menu to a widget, call .setXXXRightClick(widgetName, menu) app.createRightClickMenu(\"Information\", False) app.addMenuList(\"Information\", [\"Information\", \"-\", \"Option 1\", \"Option 2\", \"Option 3\"], infoMenu) app.disableMenuItem(\"Information\", \"Information\") # disable the title app.addLabel(\"Press me\") app.setLabelRightClick(\"Press me\", \"Information\") Windows System Menu (name: WIN_SYS ) - accessed by clicking the icon in the top left corner of the GUI. Mac - there are three default menus, each containing platform specific menu-items. There are also a couple of menu-items the user can/should provide. Application Menu (name: MAC_APP ) - after the Apple logo (\uf8ff), usually called Python . This menu is always present, and cannot be renamed - no matter how much I wish it could! Call .addMenuPreferences(function) to enable the Preferences menu-item, within the Application Menu . Window Menu (name: MAC_WIN ) - contains menu-items related to windows. To access this menu, you must first call .addMenuWindow() Help Menu (name: MAC_HELP ) - provides a Search menu-item To access this menu, you must first call .addMenuHelp(function) , passing the function to call for the default Python Help menu-item. Linux - by default, there is no menu, but it's easy enough to include the appJar menus: app.addMenuItem(\"appJar\", \"Help\", app.appJarHelp) app.addMenuItem(\"appJar\", \"About\", app.appJarAbout) Statusbar Adds a statusbar along the bottom of the GUI. This can be used for easy debugging, as info for the user, or to show current settings. app.addStatusbar(fields=3) app.setStatusbar(\"Line: 20\", 0) app.setStatusbar(\"Column: 4\", 1) app.setStatusbar(\"Mode: Edit\", 2) app.addToolbar(tools, tbFunc, True) app.addStatusbar(fields=3, side=\"RIGHT\") # NOTE: 0 is now on the right app.setStatusbarWidth(50, 2) app.setStatusbarBg(\"red\", 2) app.setStatusbarFg(\"white\", 2) Create Statusbars .addStatusbar(header=\"\", fields=1, side=None) This turns the statusbar on, and if a header is supplied, will prepend the header before every status. If fields is populated, it's possible to have multiple status boxes, each addressable by a number. side can be set as LEFT/RIGHT to make the fields appear from the left or right side, otherwise they will stretch equally. Set Statusbars .setStatusbar(text, field=0) This updates the contents of the statusbar. Again, if a header was set when adding the statusbar, it will be prepended to the message. If multiple fields were created, a position should be supplied to populate (starting from 0). .clearStatusbar(field=0) Clear anything displayed in the statusbar, along with any header that might be set. If multiple fields were created, specify which one, otherwise all fields will be cleared. .setStatusbarWidth(width, field=0) Set the width of the specified statusbar field (in characters). .setStatusbarHeader(header) Set a new header value to be used from the next time the statusbar text is updated. .removeStatusbarField(field) Remove the field at the specified position from the the statusbar. .removeStatusbar() Removes the statusbar from the GUI.","title":"Bars"},{"location":"pythonBars/#toolbars-menubars-statusbars","text":"Toolbars and Menubars are features common to most GUIs, you'll be used to seeing them along the top of apps, such as MS Word. Statusbars are also useful features, they allow you to show information about what's going on in a GUI, usually along the bottom of the app.","title":"Toolbars, Menubars &amp; Statusbars"},{"location":"pythonBars/#toolbar","text":"Toolbars (sometimes known as ribbons) appear across the top of a GUI. They offer a series of buttons to click, which can be used to change settings/functionality in a GUI. NB. Icons don't work in python 2.7, due to an issue showing PNG images. tools = [\"ABOUT\", \"REFRESH\", \"OPEN\", \"CLOSE\", \"SAVE\", \"NEW\", \"SETTINGS\", \"PRINT\", \"SEARCH\", \"UNDO\", \"REDO\", \"PREFERENCES\", \"HOME\", \"HELP\", \"CALENDAR\", \"WEB\", \"OFF\"] app.addToolbar(tools, tbFunc, findIcon=True)","title":"Toolbar"},{"location":"pythonBars/#create-toolbars","text":".addToolbar(names, funcs, findIcon=False) Will add a list of buttons along the top, in a toolbar. Each button will call the corresponding function. If only one function is supplied, they will all call the same function, providing the button's name as a parameter. A set of icons is available, if findIcon is set to True, then appJar will attempt to find an icon for each button. .addToolbarButton(name, func, findIcon=False) Adds a single button to the toolbar - see above.","title":"Create Toolbars"},{"location":"pythonBars/#set-toolbars","text":".setToolbarPinned(pinned=True) Will configure the toolbar to be pinnable When the mouse is not over the toolbar it will minimise. The toolbar will also gain an extra button (a pin) allowing the user to configure it to be pinned or not. .setToolbarIcon(name, icon) Will set an icon for the corresponding button in the toolbar. Use the name of any of the icons in the resource folder (without the folder or file extension). .setToolbarImage(name, image) Will set an image for the corresponding button in the toolbar. .setToolbarEnabled() & .setToolbarDisabled() Will enable/disable all buttons on the toolbar. .setToolbarButtonEnabled(name) & .setToolbarButtonDisabled(name) Will enable/disable the named toolbar button. .showToolbar() & .hideToolbar() Will show/hide the toolbar. .removeToolbarButton(name, hide=True) Will remove the named button from the toolbar. The toolbar will be hidden when there are no buttons on it, unless hide is set to False. .removeToolbar(hide=True) Will remove all buttons from the toolbar. The empty toolbar will be hidden, unless hide is set to False. .setToolbarBg(bg) Will change the toolbar to be the specified colour. The empty toolbar will be hidden, unless hide is set to False. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Set Toolbars"},{"location":"pythonBars/#menubar","text":"Adds a Menubar along the top of the GUI. On Windows/Linux a menubar will only be shown, once the first menu has been added. On Mac, a menubar is always present. Menubars are made up of a series of menus, each containing a list of items: Menu-items - a clickable button, that calls a function Radio-buttons - groups of options, only one of which can be selected Checkboxes - boxes that can be ticked or unticked Separators - lines to help group items together Submenus - another menu, with its own list of items","title":"Menubar"},{"location":"pythonBars/#create-menus","text":"fileMenus = [\"Open\", \"Save\", \"Save as...\", \"-\", \"Export\", \"Print\", \"-\", \"Close\"] app.addMenuList(\"File\", fileMenus, menuPress) # create the File menu, with the list of items .addMenuList(menu, names, functions) Will create a new menu, containing the list of names. Provide a single function - all names will call that function, passing their name. Or a list of functions (the same length as names), each menu will call the corresponding function. If a name is a - , then a separator will be added to the menu. .createMenu(menu, tearable=False) Will create a new, empty menu, to add menu-items to. .addMenuItem(menu, name, func=None, shortcut=None, underline=-1) Add a menu-item to the menu, with the specified function. If the named menu does not exist, it will be automatically created. If the name is - , then a separator will be added to the menu. .addMenuSeparator(menu) Add a separator to the menu. .addMenuCheckBox(menu, name, function=None, shortcut=None, underline=-1) Add a check box, to the menu, with the specified name. .addMenuRadioButton(menu, name, value, function=None, shortcut=None, underline=-1) Add a radio button, to the menu, grouped by name, with the specified value. app.createMenu(\"Config\") for i in range(5): app.addMenuRadioButton(\"Config\", \"font\", \"1\" + str(i), menuPress) app.addMenuSeparator(\"Config\") for i in range(5): app.addMenuCheckBox(\"Config\", \"Size 1\" + str(i), menuPress) .addSubMenu(menu, subMenu) Adds a sub-menu to the specified menu. Then add menu-items to this menu (using its name). app.createMenu(\"Config\") app.addSubMenu(\"Config\", \"Font Size\") for i in range(5): app.addMenuRadioButton(\"Font Size\", \"font\", \"1\" + str(i), menuPress) .addMenu(menu, function, shortcut=None, underline=-1) This is a special case, and doesn't work on all platforms. Adds a single menu, with no list of menu-items, that calls the specified function.","title":"Create Menus"},{"location":"pythonBars/#set-menus","text":".setMenuCheckBox(menu, name) Inverts the specified check box, in the named menu. .setMenuRadioButton(menu, name, value) Selects the specified value, of the specified radio button, in the named menu. .setMenuImage(menu, name, image, align='text') Will set the specified image for the specified menu-item. .setMenuIcon(menu, name, icon, align='text') Will set the specified icon for the specified menu-item. .disableMenuItem(menu, name) & .enableMenuItem(menu, name) Will enable/disable the specified menu-item. .disableMenu(menu) & .enableMenu(menu) Will disable/enable the specified menu. .disableMenubar() & .enableMenubar() Will disable/enable all menus. NB. currently doesn't disable entries in default Mac menus. .deleteMenuItem(menu, name) Will delete the named item from the specified menu.","title":"Set Menus"},{"location":"pythonBars/#get-menus","text":".getMenuCheckBox(menu, name) Get the value of the specified check box, from the named menu. Returns True or False. .getMenuRadioButton(menu, name) Get the value of the specified radio button, from the named menu. Returns the name of the checked radio button, for this group.","title":"Get Menus"},{"location":"pythonBars/#extra-features","text":"These options aren't available when you add a list of menu-items, only when you call the specific add function. underline - if set to an Integer, the corresponding character will be underlined. tearable - if set to True, it's possible to undock the menu. shortcut - these are keyboard shortcuts you press, to call a menu-item. They should always be a combination of special keys and a regular key , separated by dashes. e.g. \"Control-s\" or \"Control-Shift-z\" The following special keys are available: Control , Option , Alt , Shift , Command , Meta There are some special cases: If you want to use numbers, you need to use the format: Control-Key-3 If you want some of the special characters, you may need to use their name: Control-slash , Control-Up NB. don't include angle brackets <> around the shortcut. NB. Lookout for clashes with regular key bindings","title":"Extra Features:"},{"location":"pythonBars/#platform-specificcustom-menus","text":"There are a few special menus available; pop-up menus, that appear when you right-click a widget and platform specific menus. To add items to these menus, use the menu names given below (eg. app.addMenuItem('EDIT', 'Name', func) ) Right-Click Menus Edit Menu (name: EDIT ) - provides a cut & paste style menu linked to all text , entry & option boxes . Call .addMenuEdit(inMenuBar=False) to enable the Edit menu. If showInBar is set to True , the Menu will also appear in the topLevel Menubar. This menu does its best to show the appropriate options, for all situations - but doesn't know when you can't redo an action. Generic Menu Call .createRightClickMenu(menu, showInBar=False) to create an empty right-click menu If showInBar is set to True , the Menu will also appear in the topLevel Menubar. The right-click menu can be populated the same way as regular menus. To link the right-click menu to a widget, call .setXXXRightClick(widgetName, menu) app.createRightClickMenu(\"Information\", False) app.addMenuList(\"Information\", [\"Information\", \"-\", \"Option 1\", \"Option 2\", \"Option 3\"], infoMenu) app.disableMenuItem(\"Information\", \"Information\") # disable the title app.addLabel(\"Press me\") app.setLabelRightClick(\"Press me\", \"Information\") Windows System Menu (name: WIN_SYS ) - accessed by clicking the icon in the top left corner of the GUI. Mac - there are three default menus, each containing platform specific menu-items. There are also a couple of menu-items the user can/should provide. Application Menu (name: MAC_APP ) - after the Apple logo (\uf8ff), usually called Python . This menu is always present, and cannot be renamed - no matter how much I wish it could! Call .addMenuPreferences(function) to enable the Preferences menu-item, within the Application Menu . Window Menu (name: MAC_WIN ) - contains menu-items related to windows. To access this menu, you must first call .addMenuWindow() Help Menu (name: MAC_HELP ) - provides a Search menu-item To access this menu, you must first call .addMenuHelp(function) , passing the function to call for the default Python Help menu-item. Linux - by default, there is no menu, but it's easy enough to include the appJar menus: app.addMenuItem(\"appJar\", \"Help\", app.appJarHelp) app.addMenuItem(\"appJar\", \"About\", app.appJarAbout)","title":"Platform Specific/Custom Menus"},{"location":"pythonBars/#statusbar","text":"Adds a statusbar along the bottom of the GUI. This can be used for easy debugging, as info for the user, or to show current settings. app.addStatusbar(fields=3) app.setStatusbar(\"Line: 20\", 0) app.setStatusbar(\"Column: 4\", 1) app.setStatusbar(\"Mode: Edit\", 2) app.addToolbar(tools, tbFunc, True) app.addStatusbar(fields=3, side=\"RIGHT\") # NOTE: 0 is now on the right app.setStatusbarWidth(50, 2) app.setStatusbarBg(\"red\", 2) app.setStatusbarFg(\"white\", 2)","title":"Statusbar"},{"location":"pythonBars/#create-statusbars","text":".addStatusbar(header=\"\", fields=1, side=None) This turns the statusbar on, and if a header is supplied, will prepend the header before every status. If fields is populated, it's possible to have multiple status boxes, each addressable by a number. side can be set as LEFT/RIGHT to make the fields appear from the left or right side, otherwise they will stretch equally.","title":"Create Statusbars"},{"location":"pythonBars/#set-statusbars","text":".setStatusbar(text, field=0) This updates the contents of the statusbar. Again, if a header was set when adding the statusbar, it will be prepended to the message. If multiple fields were created, a position should be supplied to populate (starting from 0). .clearStatusbar(field=0) Clear anything displayed in the statusbar, along with any header that might be set. If multiple fields were created, specify which one, otherwise all fields will be cleared. .setStatusbarWidth(width, field=0) Set the width of the specified statusbar field (in characters). .setStatusbarHeader(header) Set a new header value to be used from the next time the statusbar text is updated. .removeStatusbarField(field) Remove the field at the specified position from the the statusbar. .removeStatusbar() Removes the statusbar from the GUI.","title":"Set Statusbars"},{"location":"pythonBasics/","text":"Python Basics Below is a bunch of stuff explaining the basics of Python... Cheat Sheets Help can be found at: Python Cheat Sheet Turtle Cheat Sheet GUI Cheat Sheet Data Variables Variables are the most important things in programming. They let your program remember information. Variables can store someone's name, their age, or even their favourite food. Variables simply point to a space in memory, where the data is stored. A variable always has three things: An identifier - a name to refer to the variable by A value - the information the variable is storing A data type - the type of information being stored (words, numbers, lists, etc.) # this declares three variables: name, age, male # and initialises each one with a starting value name = \"Alan Shearer\" age = 45 male = True Variables generally go through a three stage process: Create - The variable identifier is declared, and the variable is initialised with a starting value Change - The variable's value is modified Check - The variable's value is checked, in decisions & loops At various points along this route, the variable will be used . Constants Sometimes, you need to store data that doesn't change - these are known as constants . They are created in the same way, but can't be changed . In Python, it is common to write the name of constants in all uppercase . # declare a constant, that we don't want to change WINNING_SCORE = 100 Data Types Data types are very important, as they allow the program to have rules: if you add two numbers together, the program should do some maths, but if you add two words together ( concatenation ) the program will just make a new sentence. There are five main data types: String - words, letter, sentences. Defined using speech marks. Int - whole numbers Real - (floats) numbers with fractions (decimal points) Boolean - True or False (On or Off) List - a collection of things (any of the above, or even a collection of lists) Python tries to work out the data type automatically, but it occasionally needs some help, if you want to tell Python what the data type is, try one of the following: # create 3 new variables by changing the type of var1/var2/var3 name = str(var1) age = int(var2) price = float(var3) Arithmetic Operators Python allows you to easily perform maths on your data | | -|-|- + | Addition | a = b + c - | Subtraction | a = b - c * | Multiplication | a = b * c / | Division | a = b / c // | Modulus division | a = b // c % | Remainder division | a = b % c | Exponent | a b round() | Round | Rounds the number to the nearest place floor() | Round-down | Rounds the number down ceil() | Round-Up | Rounds the number up sum() | Sum | Adds together all the items in the list String Operations Python also lets us perform various actions on Strings. | | -|-|- varName.upper() | Uppercase | Makes the entire string uppercase varName.lower() | Lowercase | Makes the entire string lowercase varName.split(\" \") | Split into a list | Converts the String into a list, using spaces varName.split(\",\") | Split into a list | Converts the String into a list, using commas varName.count(\"a\") | Counts occurrences of the text | Counts how many times a appears in the String varName.index(\"a\") | Finds the first position of the text | Finds the first position of a varName.startswith(\"Mr.\") | Checks what the String starts with | Returns True if the String starts with Mr. varName.endswith(\"Jarvis\") | Checks what the String ends with | Returns True if the String ends with Jarvis String Splicing Remember, Strings are just lists of characters. It's also possible to access parts of a String using array square brackets. | | -|-|- varName[2] | Gets a character | Returns the third character varName[2:5] | Gets a substring | Returns characters from 2 to 4 varName[2:] | Gets a substring | Returns characters from 2 to the end varName[:5] | Gets a substring | Returns characters from the beginning to 4 varName[2:10:2] | Gets a substring | Returns characters from 2 to 9, skipping every other character varName[::-1] | Reverse a String | Returns the String in reverse order Selection & Operators Selection is the ability to make a decision. It allows us to do different things, depending on what information is in a variable. This is done using IF statements: # if they are 18 or over, print \"You can vote\" if age >= 18: print(\"You can vote\") else: print(\"You can't vote\") Making decisions is all about comparing things; is one variable bigger than another, are two other variables the same... # if they are 18 or over, print \"You can vote\" if favArtist == \"Picasso\": print(\"You like cubist paintings.\") elif favArtist == \"Rembrandt\": print(\"You like realistic paintings.\") elif favArtist == \"Monet\": print(\"You like impressionist paintings.\") elif favArtist == \"Rembrandt\": print(\"You like realistic paintings.\") elif favArtist == \"Cezanne\": print(\"You like post-impresionistic paintings.\") else: print(\"Unrecognised artist\") To compare things we use standard operators, just like in maths. Equality Operators These let us test if things are equal or not: | | -|-|- == | Equal to | Check if two items are the same != | Not equal to | Check if two items are not the same Comparison Operators These let us compare things: | | -|-|- | Greater than | Check if the first item is bigger than the second item < | Less than | Check if the first item is smaller than the second item = | Greater than or equal to | Check if the first item is bigger than or the same as the second item <= | Less than or equal to | Check if the first item is smaller than or the same as the second item Logical Operators These let us use logic to combine lots of operators: | -|- and | Both comparisons have to be True or | Either or both comparisons have to be True not | This will change the result from True to False, or vice-versa Iteration Being able to do selection (make decisions) on its own is nearly enough. However, if we want our programs to be really useful, we want them to be able to repeat stuff. We call this iteration . While Loops Let us repeat something until we can make a decision (this may never occur) Infinite While Loops while True: print ( \"Looping!\" ) Conditional While Loops num = -1 # keep looping WHILE they don't guess 21 while num != 21: num = int ( input ( \"Guess a number: \" ) ) print ( \"You guessed:\", num ) print ( \"You finally got it!!!\" ) For Loops Let us repeat something a set number of times For Loop Through an Array # make a list of fruits fruits = ['banana', 'apple', 'mango'] for item in fruits: print ( 'Current fruit :', item) For Loop x Times for index in range ( 10 ): print ( \"Position:\", index ) For Loop from x to y for index in range ( 0, 6 ): print ( \"Position:\", index ) For Loop in Steps for index in range ( 10, 21, 2 ): print ( \"Position:\", index ) Loop Control Pyhton provides two really useful commands to help in loop control: break - Ends the loop immediately continue - Goes back to the start of the loop, skipping anything not yet done while True: guess = int(input(\"Guess a number: \")) if guess = answer: print(\"You got it!\") break else: print(\"Wrong!\") Lists This does exactly what it says on the tin - we can store lots of information all with the same name. If you have 100 books, you don't want to make 100 variables to remember all the names. Instead, you make one variable called books and then give each book a number... # make a list pupils = [\"Edd\", \"Clive\", \"Kim\", \"Kat\", \"Tim\", \"Tam\"] # print the first pupil in the list - item 0 print(pupils[0]) # add a pupil to the list pupils.append(\"Jordan\") # get the number of pupils in the list num_of_pupils = len(pupils) # remove a pupil from the list list.remove(\"Edd\") We can also iterate through a list, make decisions based on a list, and change items in a list: # make a list pupils = [\"Edd\", \"Clive\", \"Kim\", \"Kat\", \"Tim\", \"Tam\"] # print each pupil in the list for item in pupils: print ( item ) # change an item in the list pupils [ 2 ] = \"Kimberly\" # check if an item is in a list if \"Kat\" in pupils: print ( \"Found her\" ) We can also slice up or join lists: # make a list pupils = [\"Edd\", \"Clive\", \"Kim\", \"Kat\", \"Tim\", \"Tam\"] pupils[2:4] # items from 2 until before 4 = Kim & Kat pupils[2:] # items from 2 until the end = Kim, Kat, Tim & Tam pupils[:3] # items from the beginning until before 3 = Edd, Clive & Kim pupils[:] # everything # you can also count backwards pupils[-1] #last item in the array = Tam pupils[-2:] # last two items in the array = Tim & Tam pupils[:-2] # items from the beginning until 2 before the end = Edd, CLive, Kim & Kat pupils[1:-1] # remove first & last = Clive, Kim, Kat & Ti # join an array into a String of items sentence = \", \".join(pupils) # makes the String \"Edd, Clive, Kim, Kat, Tim, Tam\" Modular Development A modular program is made up of lots of separate parts (modules). Each of these should work independently of the others. In Python, we achieve this by writing functions . Python has lots of built-in functions that you might have met already: print() , input() , int() , str() , len() , round() , etc... These work by themselves, without needing to be changed. You simply give them some information to work with, and they (sometimes) give you some information back. Writing a Function So, how do we write a function? Well, it's pretty simple - you give it a name, and then everything that is indented after the name, is in that function: def myFunction(): print(\"This is in the function\") print(\"This is also in the function\") print(\"This is not in the function.\") This function is called myFunction , but it could be called anything (except for the built-in function names or keywords ). Whenever you tell your program to do myFunction it should print the two messages inside. A more detailed example might be for when you want to keep repeating the same things again and again. It is not a good idea (or any fun) to keep typing the same stuff again and again. Sometimes a loop can solve this, but other times it might not be enough. # define a function to draw a square # the size parameter sets the length of the sides def square ( size ): for loop in range ( 4 ) : t.forward ( size ) t.right ( 90 ) # call the function - very important # setting size to 77 square ( 77 ) Libraries Libraries are just other people's code that we want to use. To access them, we simply import them. We have learnt about three libraries so far: random - this lets us generate random numbers turtle - this lets us draw turtle shapes appJar - this lets us create simple GUIs Here is an example of importing and using a library: import random colours = [ \"red\", \"yellow\", \"green\", \"blue\" ] # generate a random number between 1 & 100 num = random.randint ( 1, 100 ) # generate a random colour (using the list above) colour = random.choice ( colours ) File Access Accessing files in Python is easy. You simply open the file, read from or write to it, then close it: outFile = open ( \"myfile.txt\", \"a\" ) outFile.write ( \"hi there\\n\" ) outFile.close ( ) This can be simplified even further, using the with command. The with command will ensure the file is closed once you've finished with it: with open ( \"myfile.txt\", \"a\" ) as outFile : outFile.write ( \"hi there\\n\" ) When you open a file, you pass the name of the file you want, and an access mode. The following access modes are most commonly used: r - opens a file for reading. w - creates a new file for writing (overwrites existing file). a - opens a file to append to (will create a file if needed). When reading from a file, it is most common to read it line-by-line. Again, it is more convenient to use with : with open ( \"myFile.txt\", \"r\") as inFile : # read the file into data data = inFile.read ( ) # make a list of lines myList = data.splitlines ( ) This will create a list called myList , with one entry for each line. Databases in Python Database Recap In order to be able to follow this guide, you will need to understand the basics of a database: Entity - an item in the real world, we want to model (pupils in a school) Table - a container to hold information about an entity, often named after the entity (pupils) Record - a single item/row in the table (an actual pupil) Field - the columns in the table, each storing an attribute about the entity (name, age, etc) Primary Key - something unique to each record in a table (pupil ID) Foreign Key - when another table links to records in a table, you use their primary key Relationships - how tables link to each other Example So, to model pupils in the real world - we would create a table, let's call it pupils Each field in pupils will store a piece of information about a pupil Each record in pupils will hold all the information about a single pupil We can summarise this in a data-dictionary: Field Name Data Type Information Rules PupilID Integer Primary Key First Name String between 1 and 30 characters Last Name String between 1 and 30 characters DOB Date matches format DD/MM/YYYY Gender String one of Male/Female/Unspecified To talk to a database you use SQL ( Structured Query Language ). There are two parts to SQL: DDL (Data Definition Language) - used to build and modify tables CREATE TABLE ... ALTER TABLE ... DROP TABLE ... TRUNCATE TABLE ... DML (Data Manipulation Language) - used to get or modify data in tables SELECT ... FROM ... WHERE ... INSERT INTO ... VALUES ... UPDATE ... SET ... WHERE ... DELETE FROM ... WHERE ... Python comes with a built-in database: SQLite . To gain access to it, you simply import the library: import sqlite3 Having done that, we simply connect to the database, perform some SQL, and disconnect: db = sqlite3.connect('pupils.db') # perform SQL statements db.close() As with file access, this can be wrapped up using with, to ensure we always disconnect: with sqlite3.connect(\"pupils.db\") as db: # perform SQL statements Both of these will either open an existing database called pupils.db or create a new one with that name. This means that the information will always be saved to a file, so every time you run your program, all the old data will still be there. If you don't want to create a file, and would instead like to temporarily create a database in RAM, replace the database name with the String :memory: Defensive Programming Defensive programming is a way of designing your program, so that it will continue to work, even when unexpected things happen. Defensive programming should improve: Quality by reducing the number of bugs Readability making your code more readable, and easier to understand Reliability preventing the program from crashing when it receives unexpected inputs Defensive programming can sometimes go too far - you shouldn't try to prevent errors that can't happen, as this could slow your program down, and make it harder to maintain. It's also important not to be too vague, otherwise you might miss important errors, that need to be found. Styles of Defensive Programming There are two primary styles of dealing with potential errors: EAFP - E asier to A sk for F orgiveness than P ermission LBYL - L ook B efore Y ou L eap Generally, EAFP is preferred in Python. Examples of Defensive Programming A common place programs can crash is when you expect NUMERIC input, but the user types a STRING: choice = int(input( \"Enter your choice: \" )) EAFP Try to do what you wanted to do, then if it breaks, deal with it: try: choice = int(input( \"Enter your choice: \" )) except ValueError: print( \"Invalid number\" ) In this example we simply (try to) convert the input into a number - if it fails, we deal with it. We can then wrap this in a loop , to make it keep repeating until the data is valid: while True: try: choice = int(input( \"Enter your choice: \" )) break except ValueError: print( \"Invalid number\" ) continue LBYL Check you can do something first, then only do it if it's OK. choice = input( \"Enter your choice: \" ) if choice.isdigit(): choice = int(choice) else: print( \"Invalid number\" ) In this example, we get the input, check it's a number, and then convert it. We can then wrap this in a loop , to make it keep repeating until the data is valid: while True: choice = input( \"Enter your choice: \" ) if choice.isdigit(): choice = int(choice) break else: print( \"Invalid number\" ) continue As can be seen, EAFP only catches ValueErrors , it will still crash if some other error occurs. But that complies with what we said earlier, we don't want to miss strange/important errors. And, in LBYL , it doesn't actually deal with any errors, but simply tries to prevent them - less reliable? Turtle Basics To create a turtle, and get it to move, try the following: # get the library import turtle t = turtle.Pen() # draw a square for loop in range(4): t.forward(100) t.right(90) GUI Basics To create a GUI, and show a label, try the following: # import the library from appJar import gui # create the GUI app = gui(\"Hello\") app.addLabel(\"l1\", \"Hello World!\") app.go() Colour Map Below is a useful colour map to use when doing Turtle or GUI programming.","title":"Python"},{"location":"pythonBasics/#python-basics","text":"Below is a bunch of stuff explaining the basics of Python...","title":"Python Basics"},{"location":"pythonBasics/#cheat-sheets","text":"Help can be found at: Python Cheat Sheet Turtle Cheat Sheet GUI Cheat Sheet","title":"Cheat Sheets"},{"location":"pythonBasics/#data","text":"","title":"Data"},{"location":"pythonBasics/#variables","text":"Variables are the most important things in programming. They let your program remember information. Variables can store someone's name, their age, or even their favourite food. Variables simply point to a space in memory, where the data is stored. A variable always has three things: An identifier - a name to refer to the variable by A value - the information the variable is storing A data type - the type of information being stored (words, numbers, lists, etc.) # this declares three variables: name, age, male # and initialises each one with a starting value name = \"Alan Shearer\" age = 45 male = True Variables generally go through a three stage process: Create - The variable identifier is declared, and the variable is initialised with a starting value Change - The variable's value is modified Check - The variable's value is checked, in decisions & loops At various points along this route, the variable will be used .","title":"Variables"},{"location":"pythonBasics/#constants","text":"Sometimes, you need to store data that doesn't change - these are known as constants . They are created in the same way, but can't be changed . In Python, it is common to write the name of constants in all uppercase . # declare a constant, that we don't want to change WINNING_SCORE = 100","title":"Constants"},{"location":"pythonBasics/#data-types","text":"Data types are very important, as they allow the program to have rules: if you add two numbers together, the program should do some maths, but if you add two words together ( concatenation ) the program will just make a new sentence. There are five main data types: String - words, letter, sentences. Defined using speech marks. Int - whole numbers Real - (floats) numbers with fractions (decimal points) Boolean - True or False (On or Off) List - a collection of things (any of the above, or even a collection of lists) Python tries to work out the data type automatically, but it occasionally needs some help, if you want to tell Python what the data type is, try one of the following: # create 3 new variables by changing the type of var1/var2/var3 name = str(var1) age = int(var2) price = float(var3)","title":"Data Types"},{"location":"pythonBasics/#arithmetic-operators","text":"Python allows you to easily perform maths on your data | | -|-|- + | Addition | a = b + c - | Subtraction | a = b - c * | Multiplication | a = b * c / | Division | a = b / c // | Modulus division | a = b // c % | Remainder division | a = b % c | Exponent | a b round() | Round | Rounds the number to the nearest place floor() | Round-down | Rounds the number down ceil() | Round-Up | Rounds the number up sum() | Sum | Adds together all the items in the list","title":"Arithmetic Operators"},{"location":"pythonBasics/#string-operations","text":"Python also lets us perform various actions on Strings. | | -|-|- varName.upper() | Uppercase | Makes the entire string uppercase varName.lower() | Lowercase | Makes the entire string lowercase varName.split(\" \") | Split into a list | Converts the String into a list, using spaces varName.split(\",\") | Split into a list | Converts the String into a list, using commas varName.count(\"a\") | Counts occurrences of the text | Counts how many times a appears in the String varName.index(\"a\") | Finds the first position of the text | Finds the first position of a varName.startswith(\"Mr.\") | Checks what the String starts with | Returns True if the String starts with Mr. varName.endswith(\"Jarvis\") | Checks what the String ends with | Returns True if the String ends with Jarvis","title":"String Operations"},{"location":"pythonBasics/#string-splicing","text":"Remember, Strings are just lists of characters. It's also possible to access parts of a String using array square brackets. | | -|-|- varName[2] | Gets a character | Returns the third character varName[2:5] | Gets a substring | Returns characters from 2 to 4 varName[2:] | Gets a substring | Returns characters from 2 to the end varName[:5] | Gets a substring | Returns characters from the beginning to 4 varName[2:10:2] | Gets a substring | Returns characters from 2 to 9, skipping every other character varName[::-1] | Reverse a String | Returns the String in reverse order","title":"String Splicing"},{"location":"pythonBasics/#selection-operators","text":"Selection is the ability to make a decision. It allows us to do different things, depending on what information is in a variable. This is done using IF statements: # if they are 18 or over, print \"You can vote\" if age >= 18: print(\"You can vote\") else: print(\"You can't vote\") Making decisions is all about comparing things; is one variable bigger than another, are two other variables the same... # if they are 18 or over, print \"You can vote\" if favArtist == \"Picasso\": print(\"You like cubist paintings.\") elif favArtist == \"Rembrandt\": print(\"You like realistic paintings.\") elif favArtist == \"Monet\": print(\"You like impressionist paintings.\") elif favArtist == \"Rembrandt\": print(\"You like realistic paintings.\") elif favArtist == \"Cezanne\": print(\"You like post-impresionistic paintings.\") else: print(\"Unrecognised artist\") To compare things we use standard operators, just like in maths.","title":"Selection &amp; Operators"},{"location":"pythonBasics/#equality-operators","text":"These let us test if things are equal or not: | | -|-|- == | Equal to | Check if two items are the same != | Not equal to | Check if two items are not the same","title":"Equality Operators"},{"location":"pythonBasics/#comparison-operators","text":"These let us compare things: | | -|-|- | Greater than | Check if the first item is bigger than the second item < | Less than | Check if the first item is smaller than the second item = | Greater than or equal to | Check if the first item is bigger than or the same as the second item <= | Less than or equal to | Check if the first item is smaller than or the same as the second item","title":"Comparison Operators"},{"location":"pythonBasics/#logical-operators","text":"These let us use logic to combine lots of operators: | -|- and | Both comparisons have to be True or | Either or both comparisons have to be True not | This will change the result from True to False, or vice-versa","title":"Logical Operators"},{"location":"pythonBasics/#iteration","text":"Being able to do selection (make decisions) on its own is nearly enough. However, if we want our programs to be really useful, we want them to be able to repeat stuff. We call this iteration .","title":"Iteration"},{"location":"pythonBasics/#while-loops","text":"Let us repeat something until we can make a decision (this may never occur)","title":"While Loops"},{"location":"pythonBasics/#infinite-while-loops","text":"while True: print ( \"Looping!\" )","title":"Infinite While Loops"},{"location":"pythonBasics/#conditional-while-loops","text":"num = -1 # keep looping WHILE they don't guess 21 while num != 21: num = int ( input ( \"Guess a number: \" ) ) print ( \"You guessed:\", num ) print ( \"You finally got it!!!\" )","title":"Conditional While Loops"},{"location":"pythonBasics/#for-loops","text":"Let us repeat something a set number of times","title":"For Loops"},{"location":"pythonBasics/#for-loop-through-an-array","text":"# make a list of fruits fruits = ['banana', 'apple', 'mango'] for item in fruits: print ( 'Current fruit :', item)","title":"For Loop Through an Array"},{"location":"pythonBasics/#for-loop-x-times","text":"for index in range ( 10 ): print ( \"Position:\", index )","title":"For Loop x Times"},{"location":"pythonBasics/#for-loop-from-x-to-y","text":"for index in range ( 0, 6 ): print ( \"Position:\", index )","title":"For Loop from x to y"},{"location":"pythonBasics/#for-loop-in-steps","text":"for index in range ( 10, 21, 2 ): print ( \"Position:\", index )","title":"For Loop in Steps"},{"location":"pythonBasics/#loop-control","text":"Pyhton provides two really useful commands to help in loop control: break - Ends the loop immediately continue - Goes back to the start of the loop, skipping anything not yet done while True: guess = int(input(\"Guess a number: \")) if guess = answer: print(\"You got it!\") break else: print(\"Wrong!\")","title":"Loop Control"},{"location":"pythonBasics/#lists","text":"This does exactly what it says on the tin - we can store lots of information all with the same name. If you have 100 books, you don't want to make 100 variables to remember all the names. Instead, you make one variable called books and then give each book a number... # make a list pupils = [\"Edd\", \"Clive\", \"Kim\", \"Kat\", \"Tim\", \"Tam\"] # print the first pupil in the list - item 0 print(pupils[0]) # add a pupil to the list pupils.append(\"Jordan\") # get the number of pupils in the list num_of_pupils = len(pupils) # remove a pupil from the list list.remove(\"Edd\") We can also iterate through a list, make decisions based on a list, and change items in a list: # make a list pupils = [\"Edd\", \"Clive\", \"Kim\", \"Kat\", \"Tim\", \"Tam\"] # print each pupil in the list for item in pupils: print ( item ) # change an item in the list pupils [ 2 ] = \"Kimberly\" # check if an item is in a list if \"Kat\" in pupils: print ( \"Found her\" ) We can also slice up or join lists: # make a list pupils = [\"Edd\", \"Clive\", \"Kim\", \"Kat\", \"Tim\", \"Tam\"] pupils[2:4] # items from 2 until before 4 = Kim & Kat pupils[2:] # items from 2 until the end = Kim, Kat, Tim & Tam pupils[:3] # items from the beginning until before 3 = Edd, Clive & Kim pupils[:] # everything # you can also count backwards pupils[-1] #last item in the array = Tam pupils[-2:] # last two items in the array = Tim & Tam pupils[:-2] # items from the beginning until 2 before the end = Edd, CLive, Kim & Kat pupils[1:-1] # remove first & last = Clive, Kim, Kat & Ti # join an array into a String of items sentence = \", \".join(pupils) # makes the String \"Edd, Clive, Kim, Kat, Tim, Tam\"","title":"Lists"},{"location":"pythonBasics/#modular-development","text":"A modular program is made up of lots of separate parts (modules). Each of these should work independently of the others. In Python, we achieve this by writing functions . Python has lots of built-in functions that you might have met already: print() , input() , int() , str() , len() , round() , etc... These work by themselves, without needing to be changed. You simply give them some information to work with, and they (sometimes) give you some information back.","title":"Modular Development"},{"location":"pythonBasics/#writing-a-function","text":"So, how do we write a function? Well, it's pretty simple - you give it a name, and then everything that is indented after the name, is in that function: def myFunction(): print(\"This is in the function\") print(\"This is also in the function\") print(\"This is not in the function.\") This function is called myFunction , but it could be called anything (except for the built-in function names or keywords ). Whenever you tell your program to do myFunction it should print the two messages inside. A more detailed example might be for when you want to keep repeating the same things again and again. It is not a good idea (or any fun) to keep typing the same stuff again and again. Sometimes a loop can solve this, but other times it might not be enough. # define a function to draw a square # the size parameter sets the length of the sides def square ( size ): for loop in range ( 4 ) : t.forward ( size ) t.right ( 90 ) # call the function - very important # setting size to 77 square ( 77 )","title":"Writing a Function"},{"location":"pythonBasics/#libraries","text":"Libraries are just other people's code that we want to use. To access them, we simply import them. We have learnt about three libraries so far: random - this lets us generate random numbers turtle - this lets us draw turtle shapes appJar - this lets us create simple GUIs Here is an example of importing and using a library: import random colours = [ \"red\", \"yellow\", \"green\", \"blue\" ] # generate a random number between 1 & 100 num = random.randint ( 1, 100 ) # generate a random colour (using the list above) colour = random.choice ( colours )","title":"Libraries"},{"location":"pythonBasics/#file-access","text":"Accessing files in Python is easy. You simply open the file, read from or write to it, then close it: outFile = open ( \"myfile.txt\", \"a\" ) outFile.write ( \"hi there\\n\" ) outFile.close ( ) This can be simplified even further, using the with command. The with command will ensure the file is closed once you've finished with it: with open ( \"myfile.txt\", \"a\" ) as outFile : outFile.write ( \"hi there\\n\" ) When you open a file, you pass the name of the file you want, and an access mode. The following access modes are most commonly used: r - opens a file for reading. w - creates a new file for writing (overwrites existing file). a - opens a file to append to (will create a file if needed). When reading from a file, it is most common to read it line-by-line. Again, it is more convenient to use with : with open ( \"myFile.txt\", \"r\") as inFile : # read the file into data data = inFile.read ( ) # make a list of lines myList = data.splitlines ( ) This will create a list called myList , with one entry for each line.","title":"File Access"},{"location":"pythonBasics/#databases-in-python","text":"","title":"Databases in Python"},{"location":"pythonBasics/#database-recap","text":"In order to be able to follow this guide, you will need to understand the basics of a database: Entity - an item in the real world, we want to model (pupils in a school) Table - a container to hold information about an entity, often named after the entity (pupils) Record - a single item/row in the table (an actual pupil) Field - the columns in the table, each storing an attribute about the entity (name, age, etc) Primary Key - something unique to each record in a table (pupil ID) Foreign Key - when another table links to records in a table, you use their primary key Relationships - how tables link to each other","title":"Database Recap"},{"location":"pythonBasics/#example","text":"So, to model pupils in the real world - we would create a table, let's call it pupils Each field in pupils will store a piece of information about a pupil Each record in pupils will hold all the information about a single pupil We can summarise this in a data-dictionary: Field Name Data Type Information Rules PupilID Integer Primary Key First Name String between 1 and 30 characters Last Name String between 1 and 30 characters DOB Date matches format DD/MM/YYYY Gender String one of Male/Female/Unspecified To talk to a database you use SQL ( Structured Query Language ). There are two parts to SQL: DDL (Data Definition Language) - used to build and modify tables CREATE TABLE ... ALTER TABLE ... DROP TABLE ... TRUNCATE TABLE ... DML (Data Manipulation Language) - used to get or modify data in tables SELECT ... FROM ... WHERE ... INSERT INTO ... VALUES ... UPDATE ... SET ... WHERE ... DELETE FROM ... WHERE ... Python comes with a built-in database: SQLite . To gain access to it, you simply import the library: import sqlite3 Having done that, we simply connect to the database, perform some SQL, and disconnect: db = sqlite3.connect('pupils.db') # perform SQL statements db.close() As with file access, this can be wrapped up using with, to ensure we always disconnect: with sqlite3.connect(\"pupils.db\") as db: # perform SQL statements Both of these will either open an existing database called pupils.db or create a new one with that name. This means that the information will always be saved to a file, so every time you run your program, all the old data will still be there. If you don't want to create a file, and would instead like to temporarily create a database in RAM, replace the database name with the String :memory:","title":"Example"},{"location":"pythonBasics/#defensive-programming","text":"Defensive programming is a way of designing your program, so that it will continue to work, even when unexpected things happen. Defensive programming should improve: Quality by reducing the number of bugs Readability making your code more readable, and easier to understand Reliability preventing the program from crashing when it receives unexpected inputs Defensive programming can sometimes go too far - you shouldn't try to prevent errors that can't happen, as this could slow your program down, and make it harder to maintain. It's also important not to be too vague, otherwise you might miss important errors, that need to be found.","title":"Defensive Programming"},{"location":"pythonBasics/#styles-of-defensive-programming","text":"There are two primary styles of dealing with potential errors: EAFP - E asier to A sk for F orgiveness than P ermission LBYL - L ook B efore Y ou L eap Generally, EAFP is preferred in Python.","title":"Styles of Defensive Programming"},{"location":"pythonBasics/#examples-of-defensive-programming","text":"A common place programs can crash is when you expect NUMERIC input, but the user types a STRING: choice = int(input( \"Enter your choice: \" ))","title":"Examples of Defensive Programming"},{"location":"pythonBasics/#eafp","text":"Try to do what you wanted to do, then if it breaks, deal with it: try: choice = int(input( \"Enter your choice: \" )) except ValueError: print( \"Invalid number\" ) In this example we simply (try to) convert the input into a number - if it fails, we deal with it. We can then wrap this in a loop , to make it keep repeating until the data is valid: while True: try: choice = int(input( \"Enter your choice: \" )) break except ValueError: print( \"Invalid number\" ) continue","title":"EAFP"},{"location":"pythonBasics/#lbyl","text":"Check you can do something first, then only do it if it's OK. choice = input( \"Enter your choice: \" ) if choice.isdigit(): choice = int(choice) else: print( \"Invalid number\" ) In this example, we get the input, check it's a number, and then convert it. We can then wrap this in a loop , to make it keep repeating until the data is valid: while True: choice = input( \"Enter your choice: \" ) if choice.isdigit(): choice = int(choice) break else: print( \"Invalid number\" ) continue As can be seen, EAFP only catches ValueErrors , it will still crash if some other error occurs. But that complies with what we said earlier, we don't want to miss strange/important errors. And, in LBYL , it doesn't actually deal with any errors, but simply tries to prevent them - less reliable?","title":"LBYL"},{"location":"pythonBasics/#turtle-basics","text":"To create a turtle, and get it to move, try the following: # get the library import turtle t = turtle.Pen() # draw a square for loop in range(4): t.forward(100) t.right(90)","title":"Turtle Basics"},{"location":"pythonBasics/#gui-basics","text":"To create a GUI, and show a label, try the following: # import the library from appJar import gui # create the GUI app = gui(\"Hello\") app.addLabel(\"l1\", \"Hello World!\") app.go()","title":"GUI Basics"},{"location":"pythonBasics/#colour-map","text":"Below is a useful colour map to use when doing Turtle or GUI programming.","title":"Colour Map"},{"location":"pythonCommandLine/","text":"Command Line Arguments appJar supports a number of command line arguments . These are values that can be set when appJar is initially run. Options --help -h This will display a help message, then exit. --version -v This will display the version of appJar, then exit. -l [filename.ini] This allows you to set the starting language, only useful if using internationalisation . It will override any language configured in the .go() function call. -c , -e , -w , -i , -d , t This sets the logging level : -c only log CRITICAL messages -e log ERROR messages and above -w log WARNING messages and above -i log INFO messages and above -d log DEBUG messages and above -t log TRACE messages and above -f [filename.log] This allows you to specify a file to log messages to. -s [appJar.ini] This allows you to specify a settings file to load/save settings to. --ttk [theme name] This allows you to request appJar uses ttk widgets where possible. It can followed by an optional theme name, to declare which style to use for ttk widgets. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Example The following example will start the app logging DEBUG messages, and using an ENGLISH language file: python3 demoApp.py -d -l ENGLISH Disabling If you want to provide your own command line argument handling, then you will need to disable it in appJar, as appJar will show an error message if invalid arguments are found. To do this, you can set the handleArgs flag to False in the appJar constructor: from appJar import gui app = gui(handleArgs=False) # disable argument handling app.addLabel(\"l1\", \"No argument handling\") app.go()","title":"Command Line Arguments"},{"location":"pythonCommandLine/#command-line-arguments","text":"appJar supports a number of command line arguments . These are values that can be set when appJar is initially run.","title":"Command Line Arguments"},{"location":"pythonCommandLine/#options","text":"--help -h This will display a help message, then exit. --version -v This will display the version of appJar, then exit. -l [filename.ini] This allows you to set the starting language, only useful if using internationalisation . It will override any language configured in the .go() function call. -c , -e , -w , -i , -d , t This sets the logging level : -c only log CRITICAL messages -e log ERROR messages and above -w log WARNING messages and above -i log INFO messages and above -d log DEBUG messages and above -t log TRACE messages and above -f [filename.log] This allows you to specify a file to log messages to. -s [appJar.ini] This allows you to specify a settings file to load/save settings to. --ttk [theme name] This allows you to request appJar uses ttk widgets where possible. It can followed by an optional theme name, to declare which style to use for ttk widgets. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Options"},{"location":"pythonCommandLine/#example","text":"The following example will start the app logging DEBUG messages, and using an ENGLISH language file: python3 demoApp.py -d -l ENGLISH","title":"Example"},{"location":"pythonCommandLine/#disabling","text":"If you want to provide your own command line argument handling, then you will need to disable it in appJar, as appJar will show an error message if invalid arguments are found. To do this, you can set the handleArgs flag to False in the appJar constructor: from appJar import gui app = gui(handleArgs=False) # disable argument handling app.addLabel(\"l1\", \"No argument handling\") app.go()","title":"Disabling"},{"location":"pythonContextManager/","text":"The power of WITH Using ContextManagers to make GUIs even easier. One thing I really wanted to get into appJar, was some indentation - I wanted the code for the GUI to look more like the actual GUI. I also wanted to simplify the creation of containers, and even the GUI itself. with gui(\"My first GUI\") as app: app.addLabel(\"lab\", \"Hello world!\") That's it - 2 lines to create a GUI. If you want to add containers, it's the same process: from appJar import gui with gui(\"My first GUI\") as app: app.setBg(\"lightblue\") with app.labelFrame(\"Left\"): app.addLabel(\"left\", \"Hello world!\") with app.labelFrame(\"Right\", row=0, column=1): app.addLabel(\"right\", \"Hello world again!\") app.addNamedButton(\"PRESS ME\", \"Pop-up\", app.showSubWindow, colspan=2) with app.subWindow(\"Pop-up\"): app.addLabel(\"popLab\", \"Here's a pop-up!\") And, that's all there is to it - this feature is available on all containers, and I think it's going to make things a lot simpler! The old start/stop functions all still exist, so there is no need to use the with command. But if you prefer this method, it's there. An added bonus, is that the same syntax works for starting a container or opening a container! Available Containers from appJar import gui def press(btn): with app.page(windowTitle=\"pages\", pageNumber=1): app.addLabel(\"newLab\", \"New Label\") with gui() as app: app.setSize(250, 300) with app.pagedWindow(\"pages\"): with app.page(): app.addLabel(\"l1\", \"Page One\") app.addButton(\"PRESS\", press) with app.page(): app.addLabel(\"l2\", \"Page Two\") with app.page(): app.addLabel(\"l3\", \"Page Three\") The following can all be used in the same format to start or open a container: Have a look on the containers page for usage information. .frame(title) .frameStack(title) .labelFrame(title, hideTitle=False) .toggleFrame(title) .scrollPane(title) .tabbedFrame(title) .tab(title, tabTitle=None) .panedFrame(title, vertical=False) .pagedWindow(title) .page(windowTitle, pageNumber) - NB. only provide the named parameters if opening a page .subWindow(name, title=None, modal=False, blocking=False, transient=False, grouped=True) If you're playing with ttk , you can try: .notebook(title) .note(title, tabTitle=None)","title":"The power of WITH"},{"location":"pythonContextManager/#the-power-of-with","text":"Using ContextManagers to make GUIs even easier. One thing I really wanted to get into appJar, was some indentation - I wanted the code for the GUI to look more like the actual GUI. I also wanted to simplify the creation of containers, and even the GUI itself. with gui(\"My first GUI\") as app: app.addLabel(\"lab\", \"Hello world!\") That's it - 2 lines to create a GUI. If you want to add containers, it's the same process: from appJar import gui with gui(\"My first GUI\") as app: app.setBg(\"lightblue\") with app.labelFrame(\"Left\"): app.addLabel(\"left\", \"Hello world!\") with app.labelFrame(\"Right\", row=0, column=1): app.addLabel(\"right\", \"Hello world again!\") app.addNamedButton(\"PRESS ME\", \"Pop-up\", app.showSubWindow, colspan=2) with app.subWindow(\"Pop-up\"): app.addLabel(\"popLab\", \"Here's a pop-up!\") And, that's all there is to it - this feature is available on all containers, and I think it's going to make things a lot simpler! The old start/stop functions all still exist, so there is no need to use the with command. But if you prefer this method, it's there. An added bonus, is that the same syntax works for starting a container or opening a container!","title":"The power of WITH"},{"location":"pythonContextManager/#available-containers","text":"from appJar import gui def press(btn): with app.page(windowTitle=\"pages\", pageNumber=1): app.addLabel(\"newLab\", \"New Label\") with gui() as app: app.setSize(250, 300) with app.pagedWindow(\"pages\"): with app.page(): app.addLabel(\"l1\", \"Page One\") app.addButton(\"PRESS\", press) with app.page(): app.addLabel(\"l2\", \"Page Two\") with app.page(): app.addLabel(\"l3\", \"Page Three\") The following can all be used in the same format to start or open a container: Have a look on the containers page for usage information. .frame(title) .frameStack(title) .labelFrame(title, hideTitle=False) .toggleFrame(title) .scrollPane(title) .tabbedFrame(title) .tab(title, tabTitle=None) .panedFrame(title, vertical=False) .pagedWindow(title) .page(windowTitle, pageNumber) - NB. only provide the named parameters if opening a page .subWindow(name, title=None, modal=False, blocking=False, transient=False, grouped=True) If you're playing with ttk , you can try: .notebook(title) .note(title, tabTitle=None)","title":"Available Containers"},{"location":"pythonDevWidgets/","text":"Beta Widgets The following widgets are in beta - they're available and being used, they're just not quite finished... Accessibility A pop-up to configure GUI settings. from appJar import gui with gui(\"Demo Access\") as app: app.button('Accessibility', app.showAccess, icon='ACCESS') It allows you to configure: Font Family Font Size Bold True/False Normal/Italic Underline True/False Overstrike True/False Foreground Colour Background Colour Table Used to create a spreadsheet like interface. The Table has mouse interactivity, with mouse-over highlighting, and mouse-click highlighting. It is possible to include buttons at the end of each row, and an additional row of entry boxes, with their own button. from appJar import gui app = gui() app.setFont(20) app.addTable(\"g1\", [[\"Name\", \"Age\", \"Gender\"], [\"Fred\", 45, \"Male\"], [\"Tina\", 37, \"Female\"], [\"Clive\", 28, \"Male\"], [\"Betty\", 51, \"Female\"]]) app.go() Add Tables .addTable(title, data, action=None, addRow=None) Receives a (jagged) 2D list of values. The first list should be the headers for the Table, the rest will contain each row of values. If action is set, a button will be created, at the end of each row, calling the specified function. It will pass the row number (starting at 0). If addRow is set, then an additional row will appear at the end of the Table, with entry boxes and a button to call the specified function. The button will pass the string newRow to the specified function. If both parameters are set to a function, then both buttons at the end of each row and a row of Entry boxes will be shown: It's also possible to set the following parameters: * actionHeading - set the title of the right column * actionButton - set the button text for each row (can be a list of button names) * addButton - set the button text for the Entry row * showMenu - boolean to show a right-click menu * edit - function to call when right-click menu pressed * disabledEntries - pass a list of numbers, to disable entry boxes in those positions * border - the style of the cell border: sunken , solid , etc * wrap - The maximum number of pixels to show per line in a cell, defaults to 250 pixels * horizontal - boolean to align action buttons horizontally (default) or vertically Connecting to Databases .addDbTable(title, db, table) Will connect to the specified database, and show all rows in the specified table. appJar will query the table to detect the PrimaryKey, and use this as the key when selecting the row. .replaceDBTable(title, db, table) Will replace the currently shown data in the Table, with the data found in the specified database/table. .refreshDBTable(title) Will refresh the specified DB Table. .addDbOptionBox(title, db, change=None) Will create an OptionBox, containing a list of all the tables available in the specified database. .refreshDbOptionBox(title) Will reload the list of tables displayed in the specified DB OptionBox. Get Tables .getTableRow(title, rowNumber) Returns a list of values representing the specified row. .getTableRowCount(title) Returns a count of how many rows are in the Table (not including the header row). .getTableSelectedCells(title) Gets a dictionary of booleans, indicating the status of each cell. True indicates the cell is selected, False indicates the cell is not selected. The name of each entry on the dictionary will be in the format ROW-COLUMN, eg. 0-2 .getTableEntries(title) If addRow was set when the Table was created, this function will get the contents of the entry boxes. They will be returned as a list, in the same order as the entry boxes. .getTableLastChange(title) Get a dictionary of the last change performed on the table. Containing: title, gridPos, action, cellText, newText, widget Action types: edit, clear, paste, deleteColumn, deleteRow, columnBefore, columnAfter, sortAscending, sortDescending Set Tables .addTableRow(title, data) Adds a new row of data to the end of the existing Table. It will be positioned at the bottom of the Table, above the entry boxes if present. To have the Press button on the entries row add a new row of data, try the following: def press(btn): if btn == \"addRow\": # the button on the entries row data = app.getTableEntries(\"g1\") app.addTableRow(\"g1\", data) .setTableEditFunction(title, func) Set a function to call, when one of the menu options is clicked. Will pass the name of the table being clicked. Use .getTableLastChange(title) to find out what action has been performed. .addTableRows(title, data) Adds the new rows of data to the end of the existing Table. .replaceTableRow(title, rowNum, data) Replace the values in the specified row with the new data. If the new data has fewer items, the remaining cells will be emptied. .replaceAllTableRows(title, data, deleteHeader=True) Removes all existing rows, before adding the new rows. Set deleteHeader to False if you don't want to replace the new header row. .setTableHeaders(title, data) Replace the values in the header row. If the new data has fewer items, the remaining header cells will be emptied. .deleteTableRow(title, rowNum) Delete the specified row from the specified Table. .deleteAllTableRows(title) Delete all rows from the specified Table (except the header row). .addTableColumn(title, columnNumber, data) Add the column of data to the named Table, in the specified position. .deleteTableColumn(title, columnNumber) Delete the specified column from the named Table. .selectTableRow(title, row, highlight=None) & .selectTableColumn(title, col, highlight=None) These will either select or highlight the specified row or column in the named Table. If you leave highlight=None the row/column will be toggled between selected & deselected. If you set highlight=True the row/column will be highlighted (like a mouse over). If you set highlight=False the row/column will be un-highlighted (like a mouse over). .disableTableEntry(title, entryPos, disabled=True) Will disable the specified entry box (starting at 0) if entries are being displayed. Tree Takes an arbitrary XML string, and converts it into a tree structure. from appJar import gui app = gui() app.addTree(\"t1\", \"\"\"<people> <person><name>Fred</name><age>45</age><gender>Male</gender></person> <person><name>Tina</name><age>37</age><gender>Female</gender></person> <person><name>CLive</name><age>28</age><gender>Male</gender></person> <person><name>Betty</name><age>51</age><gender>Female</gender></person> </people>\"\"\") app.go() Add Trees .addTree(title, data) Create a tree from the specified XML data This data can either be a string (as above) or a Document object generated by the parse function of minidom .generateTree(title) Load all the XML data into the tree. Gets called automatically when the GUI starts, but will need to be called manually, if a tree is added to the GUI after it has been started. Set Trees .setTreeClickFunction(title, func) Register a function to call when an item is clicked. Will receive the name of the tree, and an id attribute, if set in the XML. .setTreeDoubleClickFunction(title, func) Register a function to call when an item is double-clicked Will receive the name of the tree, and an id attribute, if set in the XML. .setTreeEditFunction(title, func) Register a function to call when an item is edited Will receive the name of the tree. .showTreeAttributes(title, show=True) Call this to enable indication of attributes on a tree. Will draw a star & provide a tooltip. .setTreeColours(title, fg, bg, fgH, bgH) Set the fg/bg/fg highlight/bg highlight colours of the tree .setTreeBg(title, colour) Set the background colour of the tree .setTreeFg(title, colour) Set the foreground colour of the tree .setTreeHighlightBg(title, colour) Set the background colour of the highlighted node .setTreeHighlightFg(title, colour) Set the foreground colour of the highlighted node Get Trees .getTreeXML(title) Return the tree as XML .getTreeSelected(title) Return the selected node as a String .getTreeSelectedXML(title) Return the selected node (and any children) as XML","title":"Beta Widgets"},{"location":"pythonDevWidgets/#beta-widgets","text":"The following widgets are in beta - they're available and being used, they're just not quite finished...","title":"Beta Widgets"},{"location":"pythonDevWidgets/#accessibility","text":"A pop-up to configure GUI settings. from appJar import gui with gui(\"Demo Access\") as app: app.button('Accessibility', app.showAccess, icon='ACCESS') It allows you to configure: Font Family Font Size Bold True/False Normal/Italic Underline True/False Overstrike True/False Foreground Colour Background Colour","title":"Accessibility"},{"location":"pythonDevWidgets/#table","text":"Used to create a spreadsheet like interface. The Table has mouse interactivity, with mouse-over highlighting, and mouse-click highlighting. It is possible to include buttons at the end of each row, and an additional row of entry boxes, with their own button. from appJar import gui app = gui() app.setFont(20) app.addTable(\"g1\", [[\"Name\", \"Age\", \"Gender\"], [\"Fred\", 45, \"Male\"], [\"Tina\", 37, \"Female\"], [\"Clive\", 28, \"Male\"], [\"Betty\", 51, \"Female\"]]) app.go()","title":"Table"},{"location":"pythonDevWidgets/#add-tables","text":".addTable(title, data, action=None, addRow=None) Receives a (jagged) 2D list of values. The first list should be the headers for the Table, the rest will contain each row of values. If action is set, a button will be created, at the end of each row, calling the specified function. It will pass the row number (starting at 0). If addRow is set, then an additional row will appear at the end of the Table, with entry boxes and a button to call the specified function. The button will pass the string newRow to the specified function. If both parameters are set to a function, then both buttons at the end of each row and a row of Entry boxes will be shown: It's also possible to set the following parameters: * actionHeading - set the title of the right column * actionButton - set the button text for each row (can be a list of button names) * addButton - set the button text for the Entry row * showMenu - boolean to show a right-click menu * edit - function to call when right-click menu pressed * disabledEntries - pass a list of numbers, to disable entry boxes in those positions * border - the style of the cell border: sunken , solid , etc * wrap - The maximum number of pixels to show per line in a cell, defaults to 250 pixels * horizontal - boolean to align action buttons horizontally (default) or vertically","title":"Add Tables"},{"location":"pythonDevWidgets/#connecting-to-databases","text":".addDbTable(title, db, table) Will connect to the specified database, and show all rows in the specified table. appJar will query the table to detect the PrimaryKey, and use this as the key when selecting the row. .replaceDBTable(title, db, table) Will replace the currently shown data in the Table, with the data found in the specified database/table. .refreshDBTable(title) Will refresh the specified DB Table. .addDbOptionBox(title, db, change=None) Will create an OptionBox, containing a list of all the tables available in the specified database. .refreshDbOptionBox(title) Will reload the list of tables displayed in the specified DB OptionBox.","title":"Connecting to Databases"},{"location":"pythonDevWidgets/#get-tables","text":".getTableRow(title, rowNumber) Returns a list of values representing the specified row. .getTableRowCount(title) Returns a count of how many rows are in the Table (not including the header row). .getTableSelectedCells(title) Gets a dictionary of booleans, indicating the status of each cell. True indicates the cell is selected, False indicates the cell is not selected. The name of each entry on the dictionary will be in the format ROW-COLUMN, eg. 0-2 .getTableEntries(title) If addRow was set when the Table was created, this function will get the contents of the entry boxes. They will be returned as a list, in the same order as the entry boxes. .getTableLastChange(title) Get a dictionary of the last change performed on the table. Containing: title, gridPos, action, cellText, newText, widget Action types: edit, clear, paste, deleteColumn, deleteRow, columnBefore, columnAfter, sortAscending, sortDescending","title":"Get Tables"},{"location":"pythonDevWidgets/#set-tables","text":".addTableRow(title, data) Adds a new row of data to the end of the existing Table. It will be positioned at the bottom of the Table, above the entry boxes if present. To have the Press button on the entries row add a new row of data, try the following: def press(btn): if btn == \"addRow\": # the button on the entries row data = app.getTableEntries(\"g1\") app.addTableRow(\"g1\", data) .setTableEditFunction(title, func) Set a function to call, when one of the menu options is clicked. Will pass the name of the table being clicked. Use .getTableLastChange(title) to find out what action has been performed. .addTableRows(title, data) Adds the new rows of data to the end of the existing Table. .replaceTableRow(title, rowNum, data) Replace the values in the specified row with the new data. If the new data has fewer items, the remaining cells will be emptied. .replaceAllTableRows(title, data, deleteHeader=True) Removes all existing rows, before adding the new rows. Set deleteHeader to False if you don't want to replace the new header row. .setTableHeaders(title, data) Replace the values in the header row. If the new data has fewer items, the remaining header cells will be emptied. .deleteTableRow(title, rowNum) Delete the specified row from the specified Table. .deleteAllTableRows(title) Delete all rows from the specified Table (except the header row). .addTableColumn(title, columnNumber, data) Add the column of data to the named Table, in the specified position. .deleteTableColumn(title, columnNumber) Delete the specified column from the named Table. .selectTableRow(title, row, highlight=None) & .selectTableColumn(title, col, highlight=None) These will either select or highlight the specified row or column in the named Table. If you leave highlight=None the row/column will be toggled between selected & deselected. If you set highlight=True the row/column will be highlighted (like a mouse over). If you set highlight=False the row/column will be un-highlighted (like a mouse over). .disableTableEntry(title, entryPos, disabled=True) Will disable the specified entry box (starting at 0) if entries are being displayed.","title":"Set Tables"},{"location":"pythonDevWidgets/#tree","text":"Takes an arbitrary XML string, and converts it into a tree structure. from appJar import gui app = gui() app.addTree(\"t1\", \"\"\"<people> <person><name>Fred</name><age>45</age><gender>Male</gender></person> <person><name>Tina</name><age>37</age><gender>Female</gender></person> <person><name>CLive</name><age>28</age><gender>Male</gender></person> <person><name>Betty</name><age>51</age><gender>Female</gender></person> </people>\"\"\") app.go()","title":"Tree"},{"location":"pythonDevWidgets/#add-trees","text":".addTree(title, data) Create a tree from the specified XML data This data can either be a string (as above) or a Document object generated by the parse function of minidom .generateTree(title) Load all the XML data into the tree. Gets called automatically when the GUI starts, but will need to be called manually, if a tree is added to the GUI after it has been started.","title":"Add Trees"},{"location":"pythonDevWidgets/#set-trees","text":".setTreeClickFunction(title, func) Register a function to call when an item is clicked. Will receive the name of the tree, and an id attribute, if set in the XML. .setTreeDoubleClickFunction(title, func) Register a function to call when an item is double-clicked Will receive the name of the tree, and an id attribute, if set in the XML. .setTreeEditFunction(title, func) Register a function to call when an item is edited Will receive the name of the tree. .showTreeAttributes(title, show=True) Call this to enable indication of attributes on a tree. Will draw a star & provide a tooltip. .setTreeColours(title, fg, bg, fgH, bgH) Set the fg/bg/fg highlight/bg highlight colours of the tree .setTreeBg(title, colour) Set the background colour of the tree .setTreeFg(title, colour) Set the foreground colour of the tree .setTreeHighlightBg(title, colour) Set the background colour of the highlighted node .setTreeHighlightFg(title, colour) Set the foreground colour of the highlighted node","title":"Set Trees"},{"location":"pythonDevWidgets/#get-trees","text":".getTreeXML(title) Return the tree as XML .getTreeSelected(title) Return the selected node as a String .getTreeSelectedXML(title) Return the selected node (and any children) as XML","title":"Get Trees"},{"location":"pythonDialogs/","text":"Pop-ups A number of pop-ups (aka dialogs) are available, to add a different user experience, notify the user of information, or get one off pieces of data. Tooltips .set XXX Tooltip(name, value) Sets a tooltip for the named widget, with the specified value. The specified value will be displayed in a small pop-up, when the mouse is left over the widget. If called a second time, it will update the value of the tooltip. NB. XXX must be the widget type, eg. Label .enable XXX Tooltip(name) & .disable XXX Tooltip(name) These will enable or disable the named tooltip. When disabled, it will not show-up. Message Boxes .infoBox(title, message, parent=None) Shows a simple information message, with an OK button. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .errorBox(title, message, parent=None) Shows a simple error message, with an OK button. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .warningBox(title, message, parent=None) Shows a simple warning message, with an OK message. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. Question Boxes .yesNoBox(title, message, parent=None) Shows a question, with Yes/No buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .questionBox(title, message, parent=None) Shows a question, with Yes/No buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .okBox(title, message, parent=None) Shows a question, with OK/Cancel buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .retryBox(title, message, parent=None) Shows a question, with Cancel/Retry buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .stringBox(title, message, parent=None) Shows a question requesting a text response. Returns a String, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .integerBox(title, message, parent=None) Shows a question requesting an integer response. Returns an integer, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .floatBox(title, message, parent=None) Shows a question requesting a float response. Returns a float, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. appJar Question Boxes .textBox(title, message, parent=None) Shows a question requesting a text response. Returns a String, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .numberBox(title, message, parent=None) Shows a question requesting a numeric response. Returns a number, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. File Boxes .openBox(title=None, dirName=None, fileTypes=None, asFile=False, parent=None, multiple=False, mode='r') Shows an open file dialog. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. Various parameters can be provided (although they don't work on all platforms): title this will set a title for the dialog dirName this will set a starting directory, defaults to the current working directory fileTypes=[('images', '*.png'), ('images', '*.jpg')] This will set the allowed file extensions, it should be a list of tuples. They will be grouped by the name. asFile this will determine whether a path or actual Python file object is returned, defaults to filename multiple if set to True , this will allow the user to select more than one file, defaults to False mode if asFile is True , this determines what mode to open the file in, one of: r, w, a or U .saveBox(title=None, fileName=None, dirName=None, fileExt=\".txt\", fileTypes=None, asFile=None, parent=None) Shows a save file dialog. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. Various parameters can be provided (although they don't work on all platforms): title this will set a title for the dialog fileName this will set a starting file name to save as dirName this will set a starting directory, defaults to the current working directory fileExt this will set a file extension to start with fileTypes=[('images', '*.png'), ('images', '*.jpg')] This will set the allowed file extensions, it should be a list of tuples. They will be grouped by the name. asFile this will determine whether a path or actual Python file object is returned, defaults to filename .directoryBox(title=None, dirName=None, parent=None) Shows a choose directory dialog. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. title this will set a title for the dialog dirName this will set a starting directory, defaults to the current working directory Other Boxes .colourBox(colour=\"#FF0000\", parent=None) Shows a dialog for choosing colours. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. Can be passed a colour to start with, defaults to red.","title":"Pop-ups"},{"location":"pythonDialogs/#pop-ups","text":"A number of pop-ups (aka dialogs) are available, to add a different user experience, notify the user of information, or get one off pieces of data.","title":"Pop-ups"},{"location":"pythonDialogs/#tooltips","text":".set XXX Tooltip(name, value) Sets a tooltip for the named widget, with the specified value. The specified value will be displayed in a small pop-up, when the mouse is left over the widget. If called a second time, it will update the value of the tooltip. NB. XXX must be the widget type, eg. Label .enable XXX Tooltip(name) & .disable XXX Tooltip(name) These will enable or disable the named tooltip. When disabled, it will not show-up.","title":"Tooltips"},{"location":"pythonDialogs/#message-boxes","text":".infoBox(title, message, parent=None) Shows a simple information message, with an OK button. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .errorBox(title, message, parent=None) Shows a simple error message, with an OK button. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .warningBox(title, message, parent=None) Shows a simple warning message, with an OK message. If this dialog is being launched from a subWindow set parent to be the name of the subWindow.","title":"Message Boxes"},{"location":"pythonDialogs/#question-boxes","text":".yesNoBox(title, message, parent=None) Shows a question, with Yes/No buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .questionBox(title, message, parent=None) Shows a question, with Yes/No buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .okBox(title, message, parent=None) Shows a question, with OK/Cancel buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .retryBox(title, message, parent=None) Shows a question, with Cancel/Retry buttons. Returns True/False. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .stringBox(title, message, parent=None) Shows a question requesting a text response. Returns a String, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .integerBox(title, message, parent=None) Shows a question requesting an integer response. Returns an integer, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .floatBox(title, message, parent=None) Shows a question requesting a float response. Returns a float, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow.","title":"Question Boxes"},{"location":"pythonDialogs/#appjar-question-boxes","text":".textBox(title, message, parent=None) Shows a question requesting a text response. Returns a String, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. .numberBox(title, message, parent=None) Shows a question requesting a numeric response. Returns a number, or None if Cancel pressed. If this dialog is being launched from a subWindow set parent to be the name of the subWindow.","title":"appJar Question Boxes"},{"location":"pythonDialogs/#file-boxes","text":".openBox(title=None, dirName=None, fileTypes=None, asFile=False, parent=None, multiple=False, mode='r') Shows an open file dialog. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. Various parameters can be provided (although they don't work on all platforms): title this will set a title for the dialog dirName this will set a starting directory, defaults to the current working directory fileTypes=[('images', '*.png'), ('images', '*.jpg')] This will set the allowed file extensions, it should be a list of tuples. They will be grouped by the name. asFile this will determine whether a path or actual Python file object is returned, defaults to filename multiple if set to True , this will allow the user to select more than one file, defaults to False mode if asFile is True , this determines what mode to open the file in, one of: r, w, a or U .saveBox(title=None, fileName=None, dirName=None, fileExt=\".txt\", fileTypes=None, asFile=None, parent=None) Shows a save file dialog. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. Various parameters can be provided (although they don't work on all platforms): title this will set a title for the dialog fileName this will set a starting file name to save as dirName this will set a starting directory, defaults to the current working directory fileExt this will set a file extension to start with fileTypes=[('images', '*.png'), ('images', '*.jpg')] This will set the allowed file extensions, it should be a list of tuples. They will be grouped by the name. asFile this will determine whether a path or actual Python file object is returned, defaults to filename .directoryBox(title=None, dirName=None, parent=None) Shows a choose directory dialog. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. title this will set a title for the dialog dirName this will set a starting directory, defaults to the current working directory","title":"File Boxes"},{"location":"pythonDialogs/#other-boxes","text":".colourBox(colour=\"#FF0000\", parent=None) Shows a dialog for choosing colours. If this dialog is being launched from a subWindow set parent to be the name of the subWindow. Can be passed a colour to start with, defaults to red.","title":"Other Boxes"},{"location":"pythonDnD/","text":"Drag'n Drop Drag and Drop functionality is something we're accustomed to in most software. By default, python and tkinter don't provide it. We've incorporated a couple of ways to include drag and drop functionality in appJar . Drag'n Drop Between Widgets There is a beta version of drag and drop between labels . .set XXX DragFunction(name, [startDragFunction, stopDragFunction] ) Set functions to call when the mouse button is dragged from the named widget, or released over any widget. The first function will be called when the mouse is initially dragged. The second function will be called when the mouse is released. from appJar import gui def drag(widget): print(\"Dragged from:\", widget) def drop(widget): print(\"Dropped on:\", widget) app = gui(\"dnd Demo\") app.setFont(20) app.setBg(\"SlateGrey\") app.setFg(\"yellow\") app.addLabel(\"dragLab\", \"Drag Me\") app.addHorizontalSeparator() app.addLabel(\"dropLab\", \"Drop Here\") app.setLabelDragFunction(\"dragLab\", [drag, drop]) app.go() Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Drag'n Drop Between Applications There is also a beta version of drag and drop between applications - at the moment, this has been seen to work on Mac OSX 10.11, Raspberry Pi, and Windows 7 & 10 - let us know of success on other distributions! from appJar import gui def externalDrop(data): print(\"Data dropped:\", data) app = gui(\"External dnd Demo\") app.setFont(20) app.setBg(\"SlateGrey\") app.setFg(\"yellow\") app.addLabel(\"dropLab\", \"Drop Here\") app.setLabelDropTarget(\"dropLab\", externalDrop) app.go() Only certain widgets can be registered to receive Drop events: .setEntryDropTarget(title, function=None, replace=True) .setTextAreaDropTarget(title, function=None, replace=True) .setImageDropTarget(title, function=None, replace=True) .setLabelDropTarget(title, function=None, replace=True) .setMessageDropTarget(title, function=None) .setListBoxDropTarget(title, function=None, replace=True) Then, if you drag a file or a URI onto one of these widgets, the filename/URI will be copied. Or, if it's an image, the image will be replaced. If no function has been set, the contents of the widget will be replaced with the filename/URI. If you'd rather append the URI/filename - set replace to be False. If a function has been set, it will be called, passing in the filename/URI as the only parameter. There is currently no support for registering Drag events. .set XXX DragSource(title, function=None) Beta NB. This is all in beta - long term, the plan is to combine all of this into one set of functions, and provide a unified drag and drop model, that will work across all widgets both within the application and between applications.","title":"Drag'n Drop"},{"location":"pythonDnD/#dragn-drop","text":"Drag and Drop functionality is something we're accustomed to in most software. By default, python and tkinter don't provide it. We've incorporated a couple of ways to include drag and drop functionality in appJar .","title":"Drag'n Drop"},{"location":"pythonDnD/#dragn-drop-between-widgets","text":"There is a beta version of drag and drop between labels . .set XXX DragFunction(name, [startDragFunction, stopDragFunction] ) Set functions to call when the mouse button is dragged from the named widget, or released over any widget. The first function will be called when the mouse is initially dragged. The second function will be called when the mouse is released. from appJar import gui def drag(widget): print(\"Dragged from:\", widget) def drop(widget): print(\"Dropped on:\", widget) app = gui(\"dnd Demo\") app.setFont(20) app.setBg(\"SlateGrey\") app.setFg(\"yellow\") app.addLabel(\"dragLab\", \"Drag Me\") app.addHorizontalSeparator() app.addLabel(\"dropLab\", \"Drop Here\") app.setLabelDragFunction(\"dragLab\", [drag, drop]) app.go() Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Drag'n Drop Between Widgets"},{"location":"pythonDnD/#dragn-drop-between-applications","text":"There is also a beta version of drag and drop between applications - at the moment, this has been seen to work on Mac OSX 10.11, Raspberry Pi, and Windows 7 & 10 - let us know of success on other distributions! from appJar import gui def externalDrop(data): print(\"Data dropped:\", data) app = gui(\"External dnd Demo\") app.setFont(20) app.setBg(\"SlateGrey\") app.setFg(\"yellow\") app.addLabel(\"dropLab\", \"Drop Here\") app.setLabelDropTarget(\"dropLab\", externalDrop) app.go() Only certain widgets can be registered to receive Drop events: .setEntryDropTarget(title, function=None, replace=True) .setTextAreaDropTarget(title, function=None, replace=True) .setImageDropTarget(title, function=None, replace=True) .setLabelDropTarget(title, function=None, replace=True) .setMessageDropTarget(title, function=None) .setListBoxDropTarget(title, function=None, replace=True) Then, if you drag a file or a URI onto one of these widgets, the filename/URI will be copied. Or, if it's an image, the image will be replaced. If no function has been set, the contents of the widget will be replaced with the filename/URI. If you'd rather append the URI/filename - set replace to be False. If a function has been set, it will be called, passing in the filename/URI as the only parameter. There is currently no support for registering Drag events. .set XXX DragSource(title, function=None)","title":"Drag'n Drop Between Applications"},{"location":"pythonDnD/#beta","text":"NB. This is all in beta - long term, the plan is to combine all of this into one set of functions, and provide a unified drag and drop model, that will work across all widgets both within the application and between applications.","title":"Beta"},{"location":"pythonEventDrivenProgramming/","text":"Event-Driven Programming When programming a GUI, you have to think slightly differently... Normally, your code is executed sequentially. You might branch off, using a decision. And you may even introduce some loops. But ultimately your code is executed from top-to-bottom. GUI programming is different. In a GUI, a loop is constantly running in the background, waiting for the user to click something. This is called the event loop. Every time something happens to the GUI, the event loop deals with it.","title":"pythonEventDrivenProgramming"},{"location":"pythonEventDrivenProgramming/#event-driven-programming","text":"When programming a GUI, you have to think slightly differently... Normally, your code is executed sequentially. You might branch off, using a decision. And you may even introduce some loops. But ultimately your code is executed from top-to-bottom. GUI programming is different. In a GUI, a loop is constantly running in the background, waiting for the user to click something. This is called the event loop. Every time something happens to the GUI, the event loop deals with it.","title":"Event-Driven Programming"},{"location":"pythonEvents/","text":"Events An event is just calling a function - you want an event to be generated every time the user does something, such as clicking a button, dragging a scale, or pressing a key... The Button has an event automatically linked to it - whenever you press it, a function gets called. The other widgets don't. Built-in Events appJar currently has four basic types of event you can register: .set XXX ChangeFunction(title, function) call a function whenever the widget changes .set XXX SubmitFunction(title, function) call a function when the widget is submitted .set XXX OverFunction(title, functions) call function(s) when the mouse enters/leaves the widget .set XXX DragFunction(title, functions) call function(s) when the mouse is dragged in/out of the widget Change & Submit Events These do similar things, so probably shouldn't both exist, but have evolved from a single .set XXX Function() which is now deprecated. .set XXX ChangeFunction(title, function) Bind the specified function to the named widget: Scales, OptionBoxes, SpinBoxes, ListBoxes, RadioButtons & CheckBoxes, Entries & TextAreas, and Properties - the function will be called each time the widget is changed. Buttons, Labels & Images - it is not available. Other widgets - it will set the command property for the underlying tkinter widget; this may or may not do anything... .set XXX SubmitFunction(title, function) Creates a submit option for some widgets: Labels & Images - it binds a function to the <Left-Mouse-Button> , making the widget clickable. Entries & Buttons - it binds a function to the <Enter> key TextAreas - it's not available Other widgets - it does the same as ChangeFunction from appJar import gui def songChanged(rb): print(app.getRadioButton(rb)) def reset(btn): # set back to the default, but don't call the change function app.setRadioButton(\"song\", \"Killer Queen\", callFunction=False) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.setRadioButtonChangeFunction(\"song\", songChanged) app.addButton(\"Reset\", reset) app.go() WARNING - it's possible to generate a RuntimeError. If you've got two widgets changing the same variable, say a Scale and a SpinBox, and you want a change in one widget to cause an update in the other, you might inadvertently end up stuck in a recursive loop, until the stack overflows . In this case, make sure you set the optional parameter callFunction = False when you call the set XXX Function() of a widget. Over Events Set functions to call whenever the mouse enters (goes over) or leaves the specified widget. .set XXX OverFunction(name, [inFunction, outFunction]) The first function is called when the mouse first enters the widget. The second function is called when the mouse leaves the widget. If you only want a function to be called when the mouse leaves the widget, pass an array like: [None, leave] from appJar import gui def enter(wdgt): print(\"IN\", wdgt) def leave(wdgt): print(\"OUT\", wdgt) app=gui() app.addLabel(\"l1\", \"Testing...\") app.setLabelOverFunction(\"l1\", [enter, leave]) app.go() .setImageMouseOver(title, image) Additional function, specific to images , to change the specified image, while the mouse is over it. Drag Events Set functions to call when the mouse button is clicked and dragged on a Label, then released. .set XXX DragFunction(name, [startDragFunction, stopDragFunction]) The named Label will be the only one that can start a drag event. The first function will be called when the mouse is initially clicked on the Label. The second function will be called when the mouse is released, this can happen anywhere. The same rules for passing functions apply as above. Registering Other Events It's possible to register any of the other tkinter event types with appJar widgets. Just get the widget, then call the tkinter bind() function, passing in the event name and function to call. NB. The function you register must receive a single parameter, the event object. # either grab the widget when it's created, and bind the event ent = app.addEntry(\"e1\") ent.bind(\"<FocusOut>\", function_name, add=\"+\") # or do the above in one line app.addEntry(\"e1\").bind(\"<FocusOut>\", function_name, add=\"+\") # or, if doing later on, get the widget from appJar and bind the event ent = app.getEntryWidget(\"e1\") ent.bind(\"<FocusOut>\", function_name, add=\"+\") # or do the above in one line app.getEntryWidget(\"e1\").bind(\"<FocusOut>\", function_name, add=\"+\") Binding Keys We also sometimes want keys to trigger events. The classic example is the <Enter> key, we often want to be able to hit the <Enter> key to submit a form... .enableEnter(function) Link a function to the <Enter> key .disableEnter() Unlink a function from the <Enter> key You may also want to bind other keys to events: from appJar import gui def keyPress(key): if key == \"<Up>\": app.increaseFont() elif key == \"<Down>\": app.decreaseFont() elif key == \"<F1>\": app.setFont(12) app = gui(\"Button Demo\") app.addLabel(\"title\", \"Press the arrow keys to change the font\") app.bindKey(\"<Up>\", keyPress) app.bindKey(\"<Down>\", keyPress) app.bindKey(\"<F1>\", keyPress) app.go() NB. You must use the full tkinter event format for events with these bindings, including the angle brackets <> . This is different to how menu shortcuts are defined. .bindKey(key, function) Link the specified key to the specified function. .bindKeys(keys, function) Link the specified keys to the specified function. .unbindKey(key) Unlink the specified key from any functions bound to it. .unbindKeys(keys) Unlink the specified keys from any functions bound to them. Starting the GUI If you want to call a function once the GUI starts, you can register it with the following call: .setStartFunction(function) Set a function to call when the GUI starts up. Stopping the GUI Usually the user just presses the close icon to close and stop the GUI. However, you might want to let them do it in other ways - maybe by pressing a button... app.stop() Will cuase the GUI to close and stop. app.addButton('QUIT', app.stop) Confirming the user wants to quit/running clean up scripts on exit You may want to add in a confirmation that the user really wants to stop the GUI. Or, you may want to do some tidying up when the user stops the GUI, such as save a file. If so, you can set a stopFunction to call, whenever the user tries to stop the GUI. .setStopFunction(function) Set a function to call, before allowing the GUI to be stopped. NB. This function must return True or False to confirm if the GUI should stop. So, if you're just doing some tidying up, return True at the end of the function. If you want to stop the user closing the GUI, return False And, if you want to check if the user really wanted to stop the GUI: def checkStop(): return app.yesNoBox(\"Confirm Exit\", \"Are you sure you want to exit the application?\") app.setStopFunction(checkStop) Stopping Quickly If you have a LOT of widgets (maybe a Table with hundreds of rows), stopping the GUI can take a while... In which case, you should enable fastStop on the GUI. app.setFastStop(True) This will cause the GUI to exit more quickly, but lazily... NB. this doesn't work from IDLE.","title":"Events"},{"location":"pythonEvents/#events","text":"An event is just calling a function - you want an event to be generated every time the user does something, such as clicking a button, dragging a scale, or pressing a key... The Button has an event automatically linked to it - whenever you press it, a function gets called. The other widgets don't.","title":"Events"},{"location":"pythonEvents/#built-in-events","text":"appJar currently has four basic types of event you can register: .set XXX ChangeFunction(title, function) call a function whenever the widget changes .set XXX SubmitFunction(title, function) call a function when the widget is submitted .set XXX OverFunction(title, functions) call function(s) when the mouse enters/leaves the widget .set XXX DragFunction(title, functions) call function(s) when the mouse is dragged in/out of the widget","title":"Built-in Events"},{"location":"pythonEvents/#change-submit-events","text":"These do similar things, so probably shouldn't both exist, but have evolved from a single .set XXX Function() which is now deprecated. .set XXX ChangeFunction(title, function) Bind the specified function to the named widget: Scales, OptionBoxes, SpinBoxes, ListBoxes, RadioButtons & CheckBoxes, Entries & TextAreas, and Properties - the function will be called each time the widget is changed. Buttons, Labels & Images - it is not available. Other widgets - it will set the command property for the underlying tkinter widget; this may or may not do anything... .set XXX SubmitFunction(title, function) Creates a submit option for some widgets: Labels & Images - it binds a function to the <Left-Mouse-Button> , making the widget clickable. Entries & Buttons - it binds a function to the <Enter> key TextAreas - it's not available Other widgets - it does the same as ChangeFunction from appJar import gui def songChanged(rb): print(app.getRadioButton(rb)) def reset(btn): # set back to the default, but don't call the change function app.setRadioButton(\"song\", \"Killer Queen\", callFunction=False) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.setRadioButtonChangeFunction(\"song\", songChanged) app.addButton(\"Reset\", reset) app.go() WARNING - it's possible to generate a RuntimeError. If you've got two widgets changing the same variable, say a Scale and a SpinBox, and you want a change in one widget to cause an update in the other, you might inadvertently end up stuck in a recursive loop, until the stack overflows . In this case, make sure you set the optional parameter callFunction = False when you call the set XXX Function() of a widget.","title":"Change &amp; Submit Events"},{"location":"pythonEvents/#over-events","text":"Set functions to call whenever the mouse enters (goes over) or leaves the specified widget. .set XXX OverFunction(name, [inFunction, outFunction]) The first function is called when the mouse first enters the widget. The second function is called when the mouse leaves the widget. If you only want a function to be called when the mouse leaves the widget, pass an array like: [None, leave] from appJar import gui def enter(wdgt): print(\"IN\", wdgt) def leave(wdgt): print(\"OUT\", wdgt) app=gui() app.addLabel(\"l1\", \"Testing...\") app.setLabelOverFunction(\"l1\", [enter, leave]) app.go() .setImageMouseOver(title, image) Additional function, specific to images , to change the specified image, while the mouse is over it.","title":"Over Events"},{"location":"pythonEvents/#drag-events","text":"Set functions to call when the mouse button is clicked and dragged on a Label, then released. .set XXX DragFunction(name, [startDragFunction, stopDragFunction]) The named Label will be the only one that can start a drag event. The first function will be called when the mouse is initially clicked on the Label. The second function will be called when the mouse is released, this can happen anywhere. The same rules for passing functions apply as above.","title":"Drag Events"},{"location":"pythonEvents/#registering-other-events","text":"It's possible to register any of the other tkinter event types with appJar widgets. Just get the widget, then call the tkinter bind() function, passing in the event name and function to call. NB. The function you register must receive a single parameter, the event object. # either grab the widget when it's created, and bind the event ent = app.addEntry(\"e1\") ent.bind(\"<FocusOut>\", function_name, add=\"+\") # or do the above in one line app.addEntry(\"e1\").bind(\"<FocusOut>\", function_name, add=\"+\") # or, if doing later on, get the widget from appJar and bind the event ent = app.getEntryWidget(\"e1\") ent.bind(\"<FocusOut>\", function_name, add=\"+\") # or do the above in one line app.getEntryWidget(\"e1\").bind(\"<FocusOut>\", function_name, add=\"+\")","title":"Registering Other Events"},{"location":"pythonEvents/#binding-keys","text":"We also sometimes want keys to trigger events. The classic example is the <Enter> key, we often want to be able to hit the <Enter> key to submit a form... .enableEnter(function) Link a function to the <Enter> key .disableEnter() Unlink a function from the <Enter> key You may also want to bind other keys to events: from appJar import gui def keyPress(key): if key == \"<Up>\": app.increaseFont() elif key == \"<Down>\": app.decreaseFont() elif key == \"<F1>\": app.setFont(12) app = gui(\"Button Demo\") app.addLabel(\"title\", \"Press the arrow keys to change the font\") app.bindKey(\"<Up>\", keyPress) app.bindKey(\"<Down>\", keyPress) app.bindKey(\"<F1>\", keyPress) app.go() NB. You must use the full tkinter event format for events with these bindings, including the angle brackets <> . This is different to how menu shortcuts are defined. .bindKey(key, function) Link the specified key to the specified function. .bindKeys(keys, function) Link the specified keys to the specified function. .unbindKey(key) Unlink the specified key from any functions bound to it. .unbindKeys(keys) Unlink the specified keys from any functions bound to them.","title":"Binding Keys"},{"location":"pythonEvents/#starting-the-gui","text":"If you want to call a function once the GUI starts, you can register it with the following call: .setStartFunction(function) Set a function to call when the GUI starts up.","title":"Starting the GUI"},{"location":"pythonEvents/#stopping-the-gui","text":"Usually the user just presses the close icon to close and stop the GUI. However, you might want to let them do it in other ways - maybe by pressing a button... app.stop() Will cuase the GUI to close and stop. app.addButton('QUIT', app.stop)","title":"Stopping the GUI"},{"location":"pythonEvents/#confirming-the-user-wants-to-quitrunning-clean-up-scripts-on-exit","text":"You may want to add in a confirmation that the user really wants to stop the GUI. Or, you may want to do some tidying up when the user stops the GUI, such as save a file. If so, you can set a stopFunction to call, whenever the user tries to stop the GUI. .setStopFunction(function) Set a function to call, before allowing the GUI to be stopped. NB. This function must return True or False to confirm if the GUI should stop. So, if you're just doing some tidying up, return True at the end of the function. If you want to stop the user closing the GUI, return False And, if you want to check if the user really wanted to stop the GUI: def checkStop(): return app.yesNoBox(\"Confirm Exit\", \"Are you sure you want to exit the application?\") app.setStopFunction(checkStop)","title":"Confirming the user wants to quit/running clean up scripts on exit"},{"location":"pythonEvents/#stopping-quickly","text":"If you have a LOT of widgets (maybe a Table with hundreds of rows), stopping the GUI can take a while... In which case, you should enable fastStop on the GUI. app.setFastStop(True) This will cause the GUI to exit more quickly, but lazily... NB. this doesn't work from IDLE.","title":"Stopping Quickly"},{"location":"pythonGuiOptions/","text":"GUI Options There are a number of generic configurations available, which will affect the whole GUI. Some of these are also available at a widget level, where you can specify individual configurations tor specified widgets. GUI Configuration Some basic configuration for the size, position, transparency, etc. of the GUI. Look & Feel .setTitle(title) Sets the title of the GUI. By default, it is the name of the script. .setIcon(fileName) Sets an icon for the GUI. If you want to disable the icon, set the showIcon flag to False, when you call appJar's constructor. .setTransparency(percentage) Sets how transparent the GUI is. Between 0 and 100%. .setOnTop(stay=True) Configure the GUI to always stay on top of other windows. Size & Location .hide() & .show() Used to hide and show the main window. Useful in conjunction with SubWindows You can have a menu or logon SubWindow that hides/shows the main window as necessary. NB. hiding the window, effectively minimizes it, it is still there... .setSize(size) & .setSize(width, height) Sets the height & width of the GUI: Either as a single String .setSize(\"200x100\") (widthxheight) As two separate parameters .setSize(200,100) Or to go Fullscreen .setSize(\"Fullscreen\") .exitFullscreen() Leave fullscreen, if set in the above. Returns True/False - if the app was able to leave fullscreen. Can be called safely, even if app is not in fullscreen: <Escape> will call this automatically, while in fullscreen. if app.exitFullscreen(): # do something else: app.setSize(\"fullscreen\") # do something else .setResizable(canResize=True) Sets whether the GUI can be resized or not. .setLocation(x, y=None) Sets the position of the GUI. If you want to position the widget in the center of the screen, set x to CENTER: app.setLocation(\"CENTER\") .setGuiPadding(x, y) Sets the size of the border inside the GUI - defaults to 2. .hideTitleBar() & .showTitleBar() Hides/shows the GUI's title bar. Note, if the title bar is removed, it's not possible to move or resize the GUI. GUI Design It's possible to change the default colours and fonts for widgets in the GUI. Colour .setFg(colour, override=False) Set a foreground colour for the entire GUI. By default, this will only apply to labels (including on RadioButtons & CheckButtons). NB. To change the colour inside interactive widgets (Entry, TextArea, SpinBox, OptionMenu, etc), set override to be True. .setBg(colour, override=False, tint=False) Set the background colour for the GUI. This should affect all widgets, and will override any backgrounds set before. NB. this doesn't change the background colour of interactive widgets (Entry, TextArea, etc). If you also want to update those, set override to True. It's also possible to set a tint - this will determine an appropriate colour to set mouse-over, highlight colours, etc. It is set automatically if override is True. Font When configuring a font, the following style options can be set: size - the height in points family - the family name, such as: Arial , Courier , Comic Sans , Sans Serif , Times or Verdana weight - bold or normal slant - italic or roman underline - True or False overstrike - True or False app.setFont(size=16, family=\"Times\", underline=True, slant=\"italic\") app.setButtonFont(size=14, family=\"Verdana\", underline=False, slant=\"roman\") Setting a font .setFont(**style) This can be used to set the font for all widgets. Pass in any of the above styles that are required. .setLabelFont(**style) This can be used to set the font for all label-type widgets. Pass in any of the above styles that are required. .setButtonFont(**style) This can be used to set the font for all button-type widgets. Pass in any of the above styles that are required. Modifying fonts .decreaseFont() & .increaseFont() These can be used to increase or decrease the font of all widgets. .increaseLabelFont() & .decreaseLabelFont() These can be used to increase or decrease the font of all label-type widgets. .increaseButtonFont() & .decreaseButtonFont() These can be used to increase or decrease the font of all butotn-type widgets.","title":"GUI Options"},{"location":"pythonGuiOptions/#gui-options","text":"There are a number of generic configurations available, which will affect the whole GUI. Some of these are also available at a widget level, where you can specify individual configurations tor specified widgets.","title":"GUI Options"},{"location":"pythonGuiOptions/#gui-configuration","text":"Some basic configuration for the size, position, transparency, etc. of the GUI.","title":"GUI Configuration"},{"location":"pythonGuiOptions/#look-feel","text":".setTitle(title) Sets the title of the GUI. By default, it is the name of the script. .setIcon(fileName) Sets an icon for the GUI. If you want to disable the icon, set the showIcon flag to False, when you call appJar's constructor. .setTransparency(percentage) Sets how transparent the GUI is. Between 0 and 100%. .setOnTop(stay=True) Configure the GUI to always stay on top of other windows.","title":"Look &amp; Feel"},{"location":"pythonGuiOptions/#size-location","text":".hide() & .show() Used to hide and show the main window. Useful in conjunction with SubWindows You can have a menu or logon SubWindow that hides/shows the main window as necessary. NB. hiding the window, effectively minimizes it, it is still there... .setSize(size) & .setSize(width, height) Sets the height & width of the GUI: Either as a single String .setSize(\"200x100\") (widthxheight) As two separate parameters .setSize(200,100) Or to go Fullscreen .setSize(\"Fullscreen\") .exitFullscreen() Leave fullscreen, if set in the above. Returns True/False - if the app was able to leave fullscreen. Can be called safely, even if app is not in fullscreen: <Escape> will call this automatically, while in fullscreen. if app.exitFullscreen(): # do something else: app.setSize(\"fullscreen\") # do something else .setResizable(canResize=True) Sets whether the GUI can be resized or not. .setLocation(x, y=None) Sets the position of the GUI. If you want to position the widget in the center of the screen, set x to CENTER: app.setLocation(\"CENTER\") .setGuiPadding(x, y) Sets the size of the border inside the GUI - defaults to 2. .hideTitleBar() & .showTitleBar() Hides/shows the GUI's title bar. Note, if the title bar is removed, it's not possible to move or resize the GUI.","title":"Size &amp; Location"},{"location":"pythonGuiOptions/#gui-design","text":"It's possible to change the default colours and fonts for widgets in the GUI.","title":"GUI Design"},{"location":"pythonGuiOptions/#colour","text":".setFg(colour, override=False) Set a foreground colour for the entire GUI. By default, this will only apply to labels (including on RadioButtons & CheckButtons). NB. To change the colour inside interactive widgets (Entry, TextArea, SpinBox, OptionMenu, etc), set override to be True. .setBg(colour, override=False, tint=False) Set the background colour for the GUI. This should affect all widgets, and will override any backgrounds set before. NB. this doesn't change the background colour of interactive widgets (Entry, TextArea, etc). If you also want to update those, set override to True. It's also possible to set a tint - this will determine an appropriate colour to set mouse-over, highlight colours, etc. It is set automatically if override is True.","title":"Colour"},{"location":"pythonGuiOptions/#font","text":"When configuring a font, the following style options can be set: size - the height in points family - the family name, such as: Arial , Courier , Comic Sans , Sans Serif , Times or Verdana weight - bold or normal slant - italic or roman underline - True or False overstrike - True or False app.setFont(size=16, family=\"Times\", underline=True, slant=\"italic\") app.setButtonFont(size=14, family=\"Verdana\", underline=False, slant=\"roman\")","title":"Font"},{"location":"pythonGuiOptions/#setting-a-font","text":".setFont(**style) This can be used to set the font for all widgets. Pass in any of the above styles that are required. .setLabelFont(**style) This can be used to set the font for all label-type widgets. Pass in any of the above styles that are required. .setButtonFont(**style) This can be used to set the font for all button-type widgets. Pass in any of the above styles that are required.","title":"Setting a font"},{"location":"pythonGuiOptions/#modifying-fonts","text":".decreaseFont() & .increaseFont() These can be used to increase or decrease the font of all widgets. .increaseLabelFont() & .decreaseLabelFont() These can be used to increase or decrease the font of all label-type widgets. .increaseButtonFont() & .decreaseButtonFont() These can be used to increase or decrease the font of all butotn-type widgets.","title":"Modifying fonts"},{"location":"pythonImages/","text":"Images Default image support in appJar assumes no extra libraries, so it only has native support for .GIF and .PPM images. However, extra code is included to allow the use of .PNG and .JPG files. appJar will convert these to .GIF files, before showing them. Converting image files is SLOW , so it's best to stick to .GIF files! Also, converting PNGs is temperamental in Python 2.7 - another reason to avoid. Getting the path for images right can be TRICKY It's therefore best to put images in the same folder as your Python code. Or, create an image folder and set it using the .setImageLocation(location) function. Built-in icons appJar has a host of built-in icons you can use. They are all located in a folder called: gui.icon_path If you want to use one, you could just use .addIcon() or .addIconButton() Otherwise, concatenate gui.icon_path with the icon's name and .png Add Images .addImage(title, file, compound=None) Adding an image is exactly the same as adding any other widget. Simply give the image a title, and pass the filename. appJar will confirm the file is valid, and will also check the file contains the type specified. If an animated .GIF is found, then it will be animated within the GUI. compound can be set to one of top , bottom , left , right , center - this will show the image title in that position. app.startLabelFrame(\"Simple\", 0, 0) app.addImage(\"simple\", \"balloons.gif\") app.stopLabelFrame() .addImageData(title, imgData, fmt=\"gif\", compound=None) As above, but receives raw image data. Currently only supports base64 encoded GIF images. Alternatively, you can pass in a ready made PhotoImage, simply set fmt to be 'PhotoImage'. compound can be set to one of top , bottom , left , right , center - this will show the image title in that position. from appJar import gui from PIL import Image, ImageTk app = gui() photo = ImageTk.PhotoImage(Image.open(\"images.jpg\")) app.addImageData(\"pic\", photo, fmt=\"PhotoImage\") app.go() .addIcon(title, iconName, compound=None) This will create an image as above, but use one of appJar's inbuilt icons. Simply pass the name of one of the icons. compound can be set to one of top , bottom , left , right , center - this will show the image title in that position. .setImageLocation(location) Set a folder for image files. This will be put before the names of any image files used. Change Images .setImage(title, image) & .setImageData(title, imgData, fmt=\"gif\") This will replace the existing image with the new one. If the image has the same path, it will not be changed. ImageData is always reloaded. .reloadImage(title, image) & .reloadImageData(title, imgData, fmt=\"gif\") This will replace the existing image with the new one. It will force an image reload, even if the file name hasn't changed. Useful if an outside agency modifies the image file. def changePic(btn): if btn == \"Reload\": app.reloadImage(\"reload\", \"balloons.gif\") app.startLabelFrame(\"Reload\", 1, 1) app.setSticky(\"ew\") app.addImage(\"reload\", \"balloons.gif\") app.addButton(\"Reload\", changePic) app.stopLabelFrame() .setImageSubmitFunction(title, function) This will set a function to call when the image is clicked. clicked = False def changePic(btn): if btn == \"clickme\": global clicked if clicked: app.setImage(\"clickme\", \"balloons.gif\") else: app.setImage(\"clickme\", \"balloons2.png\") clicked = not clicked app.startLabelFrame(\"Click Me\", 0, 2) app.addImage(\"clickme\", \"balloons.gif\") app.setImageSubmitFunction(\"clickme\", changePic) app.stopLabelFrame() .setImageMouseOver(title, image) Set an image to show, instead of the stored image, while the mouse is over this widget. app.startLabelFrame(\"Mouse Over\", 0, 1) app.addImage(\"mo_1\", \"balloons.gif\") app.setImageMouseOver(\"mo_1\", \"balloons2.png\") app.stopLabelFrame() .setImageSize(title, width, height) This will set the size of the container for the image, cropping anything that doesn't fit. .zoomImage(title, mod) This will attempt to change the size of the image. It's very rudimentary, and usually doesn't look good - but is fun to play around with (try adding a slider under an image...) Negative values will shrink the image, positive will enlarge the image. def changePic(btn): if btn == \"Zoom\": app.zoomImage(\"Zoom\", int(app.getSpinBox(\"Zoom\"))) .shrinkImage(title, mod) & .growImage(title, mod) These are wrappers for the above function, simply causing the image to shrink or grow accordingly. Image Maps It is possible to set up a simple ImageMap - a clickable image, with names linked to different areas. When one of those areas is clicked, a function will be called, passing the name of the area as a parameter. .setImageMap(title, func, coords) This will associate an image map with the named image. coords must contain a dictionary of areas on the map. When a position on the image is clicked, in one of the areas, the named function will be called, passing in the area's name. When an unknown position on the image is clicked, UNKNOWN will be passed to the function, along with the coordinates. from appJar import gui # each list of numbers contains the top left x/y and bottom right x/y coords = { \"America\":[32, 17, 242, 167], \"South America\":[126, 170, 226, 292], } def click(area): app.setLabel(\"l1\", area) app=gui() app.addImage(\"i1\", \"map.gif\") app.setImageMap(\"i1\", click, coords) app.addLabel(\"l1\", \"<click the map>\") app.go() Change Image Animation If an image is animated, it's possible to control it. .setAnimationSpeed(title, speed) This will change the speed an image is animated at. .stopAnimation(title) & .startAnimation(title) These will start and stop the animation of an image. def changePic(btn): if btn == \"Stop\": global animated if animated: app.stopAnimation(\"animated\") app.setButton(\"Stop\", \"Start\") else: app.startAnimation(\"animated\") app.setButton(\"Stop\", \"Stop\") animated = not animated app.startLabelFrame(\"Animated\", 1, 2) app.setSticky(\"ew\") app.addImage(\"animated\", \"animated_balloons.gif\") app.addButton(\"Stop\", changePic) app.stopLabelFrame() Set Background Images It's also possible to add a background image to your GUI. If you have lots of grouped widgets, this can look quite UGLY , as all of the widgets are drawn on top. .setBgImage(image) Set the image for the background. .removeBgImage(image) Remove the image form the background. Image Caching appJar employs an image caching mechanism, to speed up image processing. Every time an image is loaded, it's added to the cache. The next time an image of the same filename is referenced, it will be loaded from the cache. This speeds up processes such as mouse-overs, or setting images back-and-forth. Animated images also have their own internal cache, storing each version of the image. appJar attempts to preload mouse over images and animated images, to improve smoothness. If there's ever a need to clear the image cache (maybe reduce memory footprint), call: .clearImageCache()","title":"Images"},{"location":"pythonImages/#images","text":"Default image support in appJar assumes no extra libraries, so it only has native support for .GIF and .PPM images. However, extra code is included to allow the use of .PNG and .JPG files. appJar will convert these to .GIF files, before showing them. Converting image files is SLOW , so it's best to stick to .GIF files! Also, converting PNGs is temperamental in Python 2.7 - another reason to avoid. Getting the path for images right can be TRICKY It's therefore best to put images in the same folder as your Python code. Or, create an image folder and set it using the .setImageLocation(location) function.","title":"Images"},{"location":"pythonImages/#built-in-icons","text":"appJar has a host of built-in icons you can use. They are all located in a folder called: gui.icon_path If you want to use one, you could just use .addIcon() or .addIconButton() Otherwise, concatenate gui.icon_path with the icon's name and .png","title":"Built-in icons"},{"location":"pythonImages/#add-images","text":".addImage(title, file, compound=None) Adding an image is exactly the same as adding any other widget. Simply give the image a title, and pass the filename. appJar will confirm the file is valid, and will also check the file contains the type specified. If an animated .GIF is found, then it will be animated within the GUI. compound can be set to one of top , bottom , left , right , center - this will show the image title in that position. app.startLabelFrame(\"Simple\", 0, 0) app.addImage(\"simple\", \"balloons.gif\") app.stopLabelFrame() .addImageData(title, imgData, fmt=\"gif\", compound=None) As above, but receives raw image data. Currently only supports base64 encoded GIF images. Alternatively, you can pass in a ready made PhotoImage, simply set fmt to be 'PhotoImage'. compound can be set to one of top , bottom , left , right , center - this will show the image title in that position. from appJar import gui from PIL import Image, ImageTk app = gui() photo = ImageTk.PhotoImage(Image.open(\"images.jpg\")) app.addImageData(\"pic\", photo, fmt=\"PhotoImage\") app.go() .addIcon(title, iconName, compound=None) This will create an image as above, but use one of appJar's inbuilt icons. Simply pass the name of one of the icons. compound can be set to one of top , bottom , left , right , center - this will show the image title in that position. .setImageLocation(location) Set a folder for image files. This will be put before the names of any image files used.","title":"Add Images"},{"location":"pythonImages/#change-images","text":".setImage(title, image) & .setImageData(title, imgData, fmt=\"gif\") This will replace the existing image with the new one. If the image has the same path, it will not be changed. ImageData is always reloaded. .reloadImage(title, image) & .reloadImageData(title, imgData, fmt=\"gif\") This will replace the existing image with the new one. It will force an image reload, even if the file name hasn't changed. Useful if an outside agency modifies the image file. def changePic(btn): if btn == \"Reload\": app.reloadImage(\"reload\", \"balloons.gif\") app.startLabelFrame(\"Reload\", 1, 1) app.setSticky(\"ew\") app.addImage(\"reload\", \"balloons.gif\") app.addButton(\"Reload\", changePic) app.stopLabelFrame() .setImageSubmitFunction(title, function) This will set a function to call when the image is clicked. clicked = False def changePic(btn): if btn == \"clickme\": global clicked if clicked: app.setImage(\"clickme\", \"balloons.gif\") else: app.setImage(\"clickme\", \"balloons2.png\") clicked = not clicked app.startLabelFrame(\"Click Me\", 0, 2) app.addImage(\"clickme\", \"balloons.gif\") app.setImageSubmitFunction(\"clickme\", changePic) app.stopLabelFrame() .setImageMouseOver(title, image) Set an image to show, instead of the stored image, while the mouse is over this widget. app.startLabelFrame(\"Mouse Over\", 0, 1) app.addImage(\"mo_1\", \"balloons.gif\") app.setImageMouseOver(\"mo_1\", \"balloons2.png\") app.stopLabelFrame() .setImageSize(title, width, height) This will set the size of the container for the image, cropping anything that doesn't fit. .zoomImage(title, mod) This will attempt to change the size of the image. It's very rudimentary, and usually doesn't look good - but is fun to play around with (try adding a slider under an image...) Negative values will shrink the image, positive will enlarge the image. def changePic(btn): if btn == \"Zoom\": app.zoomImage(\"Zoom\", int(app.getSpinBox(\"Zoom\"))) .shrinkImage(title, mod) & .growImage(title, mod) These are wrappers for the above function, simply causing the image to shrink or grow accordingly.","title":"Change Images"},{"location":"pythonImages/#image-maps","text":"It is possible to set up a simple ImageMap - a clickable image, with names linked to different areas. When one of those areas is clicked, a function will be called, passing the name of the area as a parameter. .setImageMap(title, func, coords) This will associate an image map with the named image. coords must contain a dictionary of areas on the map. When a position on the image is clicked, in one of the areas, the named function will be called, passing in the area's name. When an unknown position on the image is clicked, UNKNOWN will be passed to the function, along with the coordinates. from appJar import gui # each list of numbers contains the top left x/y and bottom right x/y coords = { \"America\":[32, 17, 242, 167], \"South America\":[126, 170, 226, 292], } def click(area): app.setLabel(\"l1\", area) app=gui() app.addImage(\"i1\", \"map.gif\") app.setImageMap(\"i1\", click, coords) app.addLabel(\"l1\", \"<click the map>\") app.go()","title":"Image Maps"},{"location":"pythonImages/#change-image-animation","text":"If an image is animated, it's possible to control it. .setAnimationSpeed(title, speed) This will change the speed an image is animated at. .stopAnimation(title) & .startAnimation(title) These will start and stop the animation of an image. def changePic(btn): if btn == \"Stop\": global animated if animated: app.stopAnimation(\"animated\") app.setButton(\"Stop\", \"Start\") else: app.startAnimation(\"animated\") app.setButton(\"Stop\", \"Stop\") animated = not animated app.startLabelFrame(\"Animated\", 1, 2) app.setSticky(\"ew\") app.addImage(\"animated\", \"animated_balloons.gif\") app.addButton(\"Stop\", changePic) app.stopLabelFrame()","title":"Change Image Animation"},{"location":"pythonImages/#set-background-images","text":"It's also possible to add a background image to your GUI. If you have lots of grouped widgets, this can look quite UGLY , as all of the widgets are drawn on top. .setBgImage(image) Set the image for the background. .removeBgImage(image) Remove the image form the background.","title":"Set Background Images"},{"location":"pythonImages/#image-caching","text":"appJar employs an image caching mechanism, to speed up image processing. Every time an image is loaded, it's added to the cache. The next time an image of the same filename is referenced, it will be loaded from the cache. This speeds up processes such as mouse-overs, or setting images back-and-forth. Animated images also have their own internal cache, storing each version of the image. appJar attempts to preload mouse over images and animated images, to improve smoothness. If there's ever a need to clear the image cache (maybe reduce memory footprint), call: .clearImageCache()","title":"Image Caching"},{"location":"pythonInternationalisation/","text":"Internationalisation appJar offers a simple method for supporting multiple languages. A config file is created, for each supported language, containing a translation for each widget. File Format The config file's name should be the language it represents, with an extension of .ini . Within that file will be a [SECTION] for each widget type, followed by a list of widget IDs and their translation, separated by colons. For example, a file called ENGLISH.ini might contain: [LABEL] l1: some text l2: some more text [BUTTON] b1: button a b2: button b [ENTRY] e1: --default text-- [LINK] l1: New link title If no translation is found, the widget's initial value will be used as a default. NB. The filename should be in all uppercase, of type .ini Coding It from appJar import gui app=gui(\"Language Demo\") app.addLabel(\"l1\", \"default text\") app.addLabel(\"l2\", \"default text\") app.addLabel(\"l3\", \"default text\") # as long as the language file has the same name as the button # the button can call .changeLanguage directly app.addButtons([\"English\", \"Francais\", \"\ud55c\uae00\"], app.changeLanguage) app.go(\"english\") The starting language can be set in the call to .go() or provided as a command line argument . To change the language, call .changeLanguage(language) Command Line Arguments It is possible to set the starting language as a command line argument: python3 languages.py -l ENGLISH This will override any language set in the call to .go() , and removes the need to set one at all. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Widget Support NB. changing the text of a widget through setXXX() method's will work, but will not be remembered if the language is changed. [LABEL] , [BUTTON] , [ENTRY] , [CHECKBOX] , [MESSAGE] , [LINK] , [LABELFRAME] , [TOGGLEFRAME] As demonstrated above, use the widget ID, followed by the text to update it with. Any labels created by auto-label widgets are also set here. NB. Only the default value of entries will be translated. [IMAGE] & [SOUND] For images , you should provide a valid filename. For sounds , the filename will be translated when the sound function is called - it will be modified with the sound folder after translation. [IMAGE] default-flag.jpg: mexican-flag.jpg [SOUND] default-anthem.wav: mexican-anthem.wav default-speech.wav: mexaican-speech.wav default-welcome.wav: mexican-welcome.wav [TITLE] This allows you to change the GUI's title , the splashscreen's text, the statusbar 's header or the title of any SubWindows . [TITLE] appJar: Main GUI Title splash: New Splash Text statusbar: DATA sub1: SubWindow 1 Title sub2: SubWindow 2 Title [RADIOBUTTON] , [PROPERTIES] , [TABBEDFRAME] For these, the ID must be in two parts: the name of the button group/properties/frame followed by the name of the button/property/tab. The two should be joined together with a dash: [RADIOBUTTON] Food-rb1: baguettes Food-rb2: fromage Food-rb3: vin [PROPERTIES] props-prop1: Extra Cheese props-prop2: Sweetcorn props-prop3: Pineapple [TABBEDFRAME] mainFrame-Tab1: Information mainFrame-Tab2: Extras mainFrame-Tab3: Details [GRID] & [PAGEDWINDOW] As above, the key is made of two parts. There are three configurable items in a Grid ; the buttons & label in the right-hand column. There are three configurable items in a PagedWindow ; the title, previous & next buttons. These should each be preceeded by the name of the widget: [GRID] financesGrid-actionHeading: Update Row financesGrid-actionButton: Update financesGrid-addButton: Add [PAGEDWINDOW] Address Book-title: AddressBuch Address Book-prevButton: Vorhergehend Address Book-nextButton: Danach [LISTBOX] , [SPINBOX] , [OPTIONBOX] These have multiple values for a single widget, so each value should be on a new line, after the ID. NB. You can't translate a SpinBox that was generated from a range. [LISTBOX] fruits: apples pears grapes bananas [SPINBOX] weekdays: Monday Tuesday Wednesday Thursday Friday [POPUP] Popups have two pieces of translatable text - the title & message, it's not possible to translate the buttons. As with SpinBoxes & ListBoxes, the title & messages should be put on separate lines: [POPUP] EXIT-POPUP: Confirm Exit Press OK to confirm exit. SAVE-POPUP: Confirm Save Press OK to confirm you want to save the file. def saveFile(btn): # SAVE-POPUP is a translation key, so the two parameters should be replaced if app.okBox(\"SAVE-POPUP\", \"Confirm you want to save.\"): saveFile() def quit(btn): # SAVE-POPUP is a translation key, so the two parameters should be replaced if app.okBox(\"EXIT-POPUP\", \"Confirm you want to exit.\"): app.stop() [TOOLBAR] Each button should be on a new line, if the button has an image the line will be ignored. [TOOLBAR] button1: New Button Name button2: Another New Button Name button3: One More New Button Name OPEN: This will be ignored because it has an image... [TOOLTIP-XXX] To translate tooltips you will need a new section for each widget type, of the format: [TOOLTIP-XXX] : [TOOLTIP-LABEL] l1: New tooltip text. l2: Another new tooltip text [TOOLTIP-ENTRY] e1: Some more tooltip text External Translations It's also possible to store additional translations to use on the fly. These are extra pieces of text you might want to translate during the running of the application, which aren't linked directly to a widget. [EXTERNAL] VALUE-1: This is some translated text. VALUE-2: This is some more translated text. VALUE-3: This is the last piece of translated text. These can then be accessed by using appJar's .translate(key, default=None) function. # this function will print out some translated text def showMessage(): print(app.translate(\"VALUE-1\")) print(app.translate(\"VALUE-2\")) print(app.translate(\"VALUE-3\")) The default value will be returned if no translation is found. Widgets Not Supported [SCALE] , [TEXTAREA] , [METER] , [PIECHART] , [TREE] [GOOGLEMAPS] , [MICROBIT] , [PLOT] , [SEPARATOR] , [GRIP] [FRAME] , [SCROLLPANE] , [PANEDFRAME] These widgets are not included in translation, as they have no static text to change. [DATEPICKER] , [MENUBAR] These widgets have not yet been implemented. Platform Support NB. your platform might not support the characters you want to display. In which case, you'll need to install the relevant font. For example, to get Korean characters to show on a Raspberry Pi, try: sudo apt-get install fonts-nanum If you're after other languages, you can try: apt-cache search chinese And then install a likely looking font...","title":"Internationalisation"},{"location":"pythonInternationalisation/#internationalisation","text":"appJar offers a simple method for supporting multiple languages. A config file is created, for each supported language, containing a translation for each widget.","title":"Internationalisation"},{"location":"pythonInternationalisation/#file-format","text":"The config file's name should be the language it represents, with an extension of .ini . Within that file will be a [SECTION] for each widget type, followed by a list of widget IDs and their translation, separated by colons. For example, a file called ENGLISH.ini might contain: [LABEL] l1: some text l2: some more text [BUTTON] b1: button a b2: button b [ENTRY] e1: --default text-- [LINK] l1: New link title If no translation is found, the widget's initial value will be used as a default. NB. The filename should be in all uppercase, of type .ini","title":"File Format"},{"location":"pythonInternationalisation/#coding-it","text":"from appJar import gui app=gui(\"Language Demo\") app.addLabel(\"l1\", \"default text\") app.addLabel(\"l2\", \"default text\") app.addLabel(\"l3\", \"default text\") # as long as the language file has the same name as the button # the button can call .changeLanguage directly app.addButtons([\"English\", \"Francais\", \"\ud55c\uae00\"], app.changeLanguage) app.go(\"english\") The starting language can be set in the call to .go() or provided as a command line argument . To change the language, call .changeLanguage(language)","title":"Coding It"},{"location":"pythonInternationalisation/#command-line-arguments","text":"It is possible to set the starting language as a command line argument: python3 languages.py -l ENGLISH This will override any language set in the call to .go() , and removes the need to set one at all. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Command Line Arguments"},{"location":"pythonInternationalisation/#widget-support","text":"NB. changing the text of a widget through setXXX() method's will work, but will not be remembered if the language is changed. [LABEL] , [BUTTON] , [ENTRY] , [CHECKBOX] , [MESSAGE] , [LINK] , [LABELFRAME] , [TOGGLEFRAME] As demonstrated above, use the widget ID, followed by the text to update it with. Any labels created by auto-label widgets are also set here. NB. Only the default value of entries will be translated. [IMAGE] & [SOUND] For images , you should provide a valid filename. For sounds , the filename will be translated when the sound function is called - it will be modified with the sound folder after translation. [IMAGE] default-flag.jpg: mexican-flag.jpg [SOUND] default-anthem.wav: mexican-anthem.wav default-speech.wav: mexaican-speech.wav default-welcome.wav: mexican-welcome.wav [TITLE] This allows you to change the GUI's title , the splashscreen's text, the statusbar 's header or the title of any SubWindows . [TITLE] appJar: Main GUI Title splash: New Splash Text statusbar: DATA sub1: SubWindow 1 Title sub2: SubWindow 2 Title [RADIOBUTTON] , [PROPERTIES] , [TABBEDFRAME] For these, the ID must be in two parts: the name of the button group/properties/frame followed by the name of the button/property/tab. The two should be joined together with a dash: [RADIOBUTTON] Food-rb1: baguettes Food-rb2: fromage Food-rb3: vin [PROPERTIES] props-prop1: Extra Cheese props-prop2: Sweetcorn props-prop3: Pineapple [TABBEDFRAME] mainFrame-Tab1: Information mainFrame-Tab2: Extras mainFrame-Tab3: Details [GRID] & [PAGEDWINDOW] As above, the key is made of two parts. There are three configurable items in a Grid ; the buttons & label in the right-hand column. There are three configurable items in a PagedWindow ; the title, previous & next buttons. These should each be preceeded by the name of the widget: [GRID] financesGrid-actionHeading: Update Row financesGrid-actionButton: Update financesGrid-addButton: Add [PAGEDWINDOW] Address Book-title: AddressBuch Address Book-prevButton: Vorhergehend Address Book-nextButton: Danach [LISTBOX] , [SPINBOX] , [OPTIONBOX] These have multiple values for a single widget, so each value should be on a new line, after the ID. NB. You can't translate a SpinBox that was generated from a range. [LISTBOX] fruits: apples pears grapes bananas [SPINBOX] weekdays: Monday Tuesday Wednesday Thursday Friday [POPUP] Popups have two pieces of translatable text - the title & message, it's not possible to translate the buttons. As with SpinBoxes & ListBoxes, the title & messages should be put on separate lines: [POPUP] EXIT-POPUP: Confirm Exit Press OK to confirm exit. SAVE-POPUP: Confirm Save Press OK to confirm you want to save the file. def saveFile(btn): # SAVE-POPUP is a translation key, so the two parameters should be replaced if app.okBox(\"SAVE-POPUP\", \"Confirm you want to save.\"): saveFile() def quit(btn): # SAVE-POPUP is a translation key, so the two parameters should be replaced if app.okBox(\"EXIT-POPUP\", \"Confirm you want to exit.\"): app.stop() [TOOLBAR] Each button should be on a new line, if the button has an image the line will be ignored. [TOOLBAR] button1: New Button Name button2: Another New Button Name button3: One More New Button Name OPEN: This will be ignored because it has an image... [TOOLTIP-XXX] To translate tooltips you will need a new section for each widget type, of the format: [TOOLTIP-XXX] : [TOOLTIP-LABEL] l1: New tooltip text. l2: Another new tooltip text [TOOLTIP-ENTRY] e1: Some more tooltip text","title":"Widget Support"},{"location":"pythonInternationalisation/#external-translations","text":"It's also possible to store additional translations to use on the fly. These are extra pieces of text you might want to translate during the running of the application, which aren't linked directly to a widget. [EXTERNAL] VALUE-1: This is some translated text. VALUE-2: This is some more translated text. VALUE-3: This is the last piece of translated text. These can then be accessed by using appJar's .translate(key, default=None) function. # this function will print out some translated text def showMessage(): print(app.translate(\"VALUE-1\")) print(app.translate(\"VALUE-2\")) print(app.translate(\"VALUE-3\")) The default value will be returned if no translation is found.","title":"External Translations"},{"location":"pythonInternationalisation/#widgets-not-supported","text":"[SCALE] , [TEXTAREA] , [METER] , [PIECHART] , [TREE] [GOOGLEMAPS] , [MICROBIT] , [PLOT] , [SEPARATOR] , [GRIP] [FRAME] , [SCROLLPANE] , [PANEDFRAME] These widgets are not included in translation, as they have no static text to change. [DATEPICKER] , [MENUBAR] These widgets have not yet been implemented.","title":"Widgets Not Supported"},{"location":"pythonInternationalisation/#platform-support","text":"NB. your platform might not support the characters you want to display. In which case, you'll need to install the relevant font. For example, to get Korean characters to show on a Raspberry Pi, try: sudo apt-get install fonts-nanum If you're after other languages, you can try: apt-cache search chinese And then install a likely looking font...","title":"Platform Support"},{"location":"pythonLogging/","text":"Logging in appJar appJar makes use of Python's built in logging capabilities . Logging works in a similar way to the print() function, except you also provide a parameter indicating the importance of the message - the logger will then only display messages of the right importance. There are five levels of importance: CRITICAL - a very serious problem, the GUI may well stop ERROR - a more serious problem, preventing something from happening WARNING - something unexpected happened INFO - confirmation that things are working as expected DEBUG - detailed diagnostic information TRACE - used by appJar to log DEBUG information By default, appJar will only log messages of importance WARNING or above. And, by default, appJar will simply print them to the console (screen). appJar provides some useful functions for logging: .logMessage(msg, level, *args) - log a message, of the specified importance, with any specified arguments (see below) .setLogLevel(level) - set the logging level, all messages of less importance than this will be ignored .setLogFile(fileName) - write all log messages to the named file, instead of the console You can also use the following convenience functions for logging messages: .critical(msg, *args) .error(msg, *args) .warn(msg, *args) .info(msg, *args) .debug(msg, *args) .trace(msg, *args) Optional Arguments: *args allows you to use a string formatter with your message. This can speed things up slightly, as it avoids unnecessary string concatenations, as well as automatically casting all variables to Strings: name = app.getEntry(\"name\") location = app.getEntry(\"location\") app.debug(\"User %s, has accessed the app from %s\", name, location) Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Logging to file One of the benefits of using Python's logging capabilities, is the ability to have them logged to a file. By setting a fileName , messages will no longer appear on the screen. Instead, they will be written to the named file. The logLevel is also increased to DEBUG Command Line Arguments It's possible to set the starting log level using a command line argument . Simply use the first letter of the desired log level as an argument when you start your app: python3 logging.py -d # log DEBUG messages and above It's also possible to set the file name to log to: python3 logging.py -f debug.log # log messages to a file called debug.log External Logging If you want to bypass the appJar functions, and use the logger directly in your code, simply request your own copy of the logger: logger = logging.getLogger(\"appJar\") . You can then talk directly to the same logging mechanism that appJar uses. How to use The idea behind having different levels of logging, is that you don't have to remove all of your debug & testing messages. It is common to include lots of testing messages during development, and then remove them once we're satisfied the code is working. However, these might sometimes prove useful in the future, when trying to diagnose something that has gone wrong. With logging, you can register those messages as DEBUG or INFO . Then set the logLevel to be INFO during development, and WARNING once development is complete. Then, if you ever need them, you can simply change the logLevel .","title":"Logging"},{"location":"pythonLogging/#logging-in-appjar","text":"appJar makes use of Python's built in logging capabilities . Logging works in a similar way to the print() function, except you also provide a parameter indicating the importance of the message - the logger will then only display messages of the right importance. There are five levels of importance: CRITICAL - a very serious problem, the GUI may well stop ERROR - a more serious problem, preventing something from happening WARNING - something unexpected happened INFO - confirmation that things are working as expected DEBUG - detailed diagnostic information TRACE - used by appJar to log DEBUG information By default, appJar will only log messages of importance WARNING or above. And, by default, appJar will simply print them to the console (screen). appJar provides some useful functions for logging: .logMessage(msg, level, *args) - log a message, of the specified importance, with any specified arguments (see below) .setLogLevel(level) - set the logging level, all messages of less importance than this will be ignored .setLogFile(fileName) - write all log messages to the named file, instead of the console You can also use the following convenience functions for logging messages: .critical(msg, *args) .error(msg, *args) .warn(msg, *args) .info(msg, *args) .debug(msg, *args) .trace(msg, *args)","title":"Logging in appJar"},{"location":"pythonLogging/#optional-arguments","text":"*args allows you to use a string formatter with your message. This can speed things up slightly, as it avoids unnecessary string concatenations, as well as automatically casting all variables to Strings: name = app.getEntry(\"name\") location = app.getEntry(\"location\") app.debug(\"User %s, has accessed the app from %s\", name, location) Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Optional Arguments:"},{"location":"pythonLogging/#logging-to-file","text":"One of the benefits of using Python's logging capabilities, is the ability to have them logged to a file. By setting a fileName , messages will no longer appear on the screen. Instead, they will be written to the named file. The logLevel is also increased to DEBUG","title":"Logging to file"},{"location":"pythonLogging/#command-line-arguments","text":"It's possible to set the starting log level using a command line argument . Simply use the first letter of the desired log level as an argument when you start your app: python3 logging.py -d # log DEBUG messages and above It's also possible to set the file name to log to: python3 logging.py -f debug.log # log messages to a file called debug.log","title":"Command Line Arguments"},{"location":"pythonLogging/#external-logging","text":"If you want to bypass the appJar functions, and use the logger directly in your code, simply request your own copy of the logger: logger = logging.getLogger(\"appJar\") . You can then talk directly to the same logging mechanism that appJar uses.","title":"External Logging"},{"location":"pythonLogging/#how-to-use","text":"The idea behind having different levels of logging, is that you don't have to remove all of your debug & testing messages. It is common to include lots of testing messages during development, and then remove them once we're satisfied the code is working. However, these might sometimes prove useful in the future, when trying to diagnose something that has gone wrong. With logging, you can register those messages as DEBUG or INFO . Then set the logLevel to be INFO during development, and WARNING once development is complete. Then, if you ever need them, you can simply change the logLevel .","title":"How to use"},{"location":"pythonLoopsAndSleeps/","text":"Loops & Sleeps When you call app.go() you start a loop in the GUI that is constantly checking for events - every time it finds an event, it processes it. But , if an event takes a long time to process, the GUI loop won't be checking for other events - this is when the GUI hangs (stops processing events). That's why your events need to be quick - they shouldn't have loops or sleeps . There are a few ways to get around this problem... Sleeps If you want to do something at a later date, you can use the .after() function to specify when it should happen. .after(delay_ms, function, *args) This will cause the specified function to be executed after the specified number of milliseconds. Additional parameters for the function can be specified, by setting *args . It will return an ID, which can be used to cancel the function, if it hasn't already started. .afterCancel(afterId) This will cancel the specified function, if it hasn't already started. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Infinite Loops If you just want something to keep happening forever - maybe updating a statusbar or showing a clock, you can use appJar's built in loop. Any functions registered in this way, are called at set intervals. .registerEvent(function) This will cause the GUI to keep repeating the named function in the background. By default, the function will repeat every second. .setPollTime(time) If you want your functions to be called more or less frequently, change the frequency here. #function to set the status bar def getLocation(): x,y,z = mc.player.getPos() app.setStatusbar(\"X: \"+ str(round(x,3)), 0) app.setStatusbar(\"Y: \"+ str(round(y,3)), 1) app.setStatusbar(\"Z: \"+ str(round(z,3)), 2) # call the getLocation function every second app.registerEvent(getLocation) Conditional Loops If you want your loop to only repeat a certain number of times or until a condition is met, you can put a decision at the beginning of the function and still use appJar's built in loop. You can use this method to simulate both while and for loops. # global variable to store the count counter = 10 def countdown(): global counter if counter > 0: app.setLabel(\"counter\", str(counter)) counter -= 1 app.registerEvent(countdown) Advanced Loops If you want more control over your loops, you can simulate your own... Using the .after() function mentioned above, you can simulate a loop, by having your function call .after() again. # global variable to store the count counter = 10 def acceleratingCountdown(): global counter if counter > 0: app.setLabel(\"counter\", str(counter)) counter -= 1 app.after(100*counter, acceleratingCountdown) app.after(0, acceleratingCountdown) This will simulate a countdown, but each time there is a smaller delay between counts. Long Tasks If you want to call a function that does something that takes a long time - such as working with files or networking, you will need a slightly different approach. Have a look at thread support in appJar.","title":"Loops & Sleeps"},{"location":"pythonLoopsAndSleeps/#loops-sleeps","text":"When you call app.go() you start a loop in the GUI that is constantly checking for events - every time it finds an event, it processes it. But , if an event takes a long time to process, the GUI loop won't be checking for other events - this is when the GUI hangs (stops processing events). That's why your events need to be quick - they shouldn't have loops or sleeps . There are a few ways to get around this problem...","title":"Loops &amp; Sleeps"},{"location":"pythonLoopsAndSleeps/#sleeps","text":"If you want to do something at a later date, you can use the .after() function to specify when it should happen. .after(delay_ms, function, *args) This will cause the specified function to be executed after the specified number of milliseconds. Additional parameters for the function can be specified, by setting *args . It will return an ID, which can be used to cancel the function, if it hasn't already started. .afterCancel(afterId) This will cancel the specified function, if it hasn't already started. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Sleeps"},{"location":"pythonLoopsAndSleeps/#infinite-loops","text":"If you just want something to keep happening forever - maybe updating a statusbar or showing a clock, you can use appJar's built in loop. Any functions registered in this way, are called at set intervals. .registerEvent(function) This will cause the GUI to keep repeating the named function in the background. By default, the function will repeat every second. .setPollTime(time) If you want your functions to be called more or less frequently, change the frequency here. #function to set the status bar def getLocation(): x,y,z = mc.player.getPos() app.setStatusbar(\"X: \"+ str(round(x,3)), 0) app.setStatusbar(\"Y: \"+ str(round(y,3)), 1) app.setStatusbar(\"Z: \"+ str(round(z,3)), 2) # call the getLocation function every second app.registerEvent(getLocation)","title":"Infinite Loops"},{"location":"pythonLoopsAndSleeps/#conditional-loops","text":"If you want your loop to only repeat a certain number of times or until a condition is met, you can put a decision at the beginning of the function and still use appJar's built in loop. You can use this method to simulate both while and for loops. # global variable to store the count counter = 10 def countdown(): global counter if counter > 0: app.setLabel(\"counter\", str(counter)) counter -= 1 app.registerEvent(countdown)","title":"Conditional Loops"},{"location":"pythonLoopsAndSleeps/#advanced-loops","text":"If you want more control over your loops, you can simulate your own... Using the .after() function mentioned above, you can simulate a loop, by having your function call .after() again. # global variable to store the count counter = 10 def acceleratingCountdown(): global counter if counter > 0: app.setLabel(\"counter\", str(counter)) counter -= 1 app.after(100*counter, acceleratingCountdown) app.after(0, acceleratingCountdown) This will simulate a countdown, but each time there is a smaller delay between counts.","title":"Advanced Loops"},{"location":"pythonLoopsAndSleeps/#long-tasks","text":"If you want to call a function that does something that takes a long time - such as working with files or networking, you will need a slightly different approach. Have a look at thread support in appJar.","title":"Long Tasks"},{"location":"pythonSettings/","text":"appJar Settings appJar can remember various GUI settings, and restore them on launch. Settings appJar will store the following settings: [GEOM] # geometry = string: size, location # fullscreen = boolean: True/False # minsize = string: x,y # state = string: withdrawn/zoomed [TOOLBAR] # pinned = boolean: True/False [TOGGLES] # name = boolean: True/False [TABS] # name = string: selected tab [PAGES] # name = string: selected page [SUBWINDOWS] # name = boolean: True/False [SUBWINDOW_NAME] # geometry = string: size, location # fullscreen = boolean: True/False # minsize = string: x,y # state = string: withdrawn/zoomed [EXTERNAL] # name = string: value Usage gui(useSettings=False) Set this flag to True in the constructor to enable settings. This will cause them to be loaded & saved automatically. .loadSettings(fileName=\"appJar.ini\", useSettings=True) This function can be called manually if you want to load settings at a later time. An alternative file can be specified. If useSettings is set to False, appjar won't save the settings back at the end. .saveSettings(fileName=\"appJar.ini\") This will save the current settings, with an optional file name. .getSetting(name, default=None) This allows you to request a user setting of the specified name. If no setting is found, the default value will be returned. .setSetting(name, value) This will store the named setting, with the specified value. You must make sure settings are being saved, for this to take effect. Command Line Arguments It's possible to switch on settings from the command line. Simply use the -s flag, with an optional file name: python3 themes.py -s # turn on settings Turn on settings, with a specified filename: python3 themes.py -s myFile.txt # turn on settings with a specified filename","title":"Saving Settings"},{"location":"pythonSettings/#appjar-settings","text":"appJar can remember various GUI settings, and restore them on launch.","title":"appJar Settings"},{"location":"pythonSettings/#settings","text":"appJar will store the following settings: [GEOM] # geometry = string: size, location # fullscreen = boolean: True/False # minsize = string: x,y # state = string: withdrawn/zoomed [TOOLBAR] # pinned = boolean: True/False [TOGGLES] # name = boolean: True/False [TABS] # name = string: selected tab [PAGES] # name = string: selected page [SUBWINDOWS] # name = boolean: True/False [SUBWINDOW_NAME] # geometry = string: size, location # fullscreen = boolean: True/False # minsize = string: x,y # state = string: withdrawn/zoomed [EXTERNAL] # name = string: value","title":"Settings"},{"location":"pythonSettings/#usage","text":"gui(useSettings=False) Set this flag to True in the constructor to enable settings. This will cause them to be loaded & saved automatically. .loadSettings(fileName=\"appJar.ini\", useSettings=True) This function can be called manually if you want to load settings at a later time. An alternative file can be specified. If useSettings is set to False, appjar won't save the settings back at the end. .saveSettings(fileName=\"appJar.ini\") This will save the current settings, with an optional file name. .getSetting(name, default=None) This allows you to request a user setting of the specified name. If no setting is found, the default value will be returned. .setSetting(name, value) This will store the named setting, with the specified value. You must make sure settings are being saved, for this to take effect.","title":"Usage"},{"location":"pythonSettings/#command-line-arguments","text":"It's possible to switch on settings from the command line. Simply use the -s flag, with an optional file name: python3 themes.py -s # turn on settings Turn on settings, with a specified filename: python3 themes.py -s myFile.txt # turn on settings with a specified filename","title":"Command Line Arguments"},{"location":"pythonSound/","text":"Sound Sound is only supported in Windows, using the Winsound API. Therefore, only .WAV files will work. Playing Sound Files .playSound(sound, wait=False) Play the named sound file. By default, the sound plays in the background (asynchronously), meaning the function will return immediately. If you set wait=True the GUI will wait for the sound to finish - not recommended , as the GUI will become unresponsive. If you want to wait for a sound to finish, use a thread . NB. this causes a few issues : Threaded sounds queue up and only start when the previous threaded sound finishes. Trying to play a non-threaded sound does nothing, and returns immediately. Trying to stop a threaded sound won't work, but WILL cause the GUI to hang, until the sound (and any queued sounds) finishes. from appJar import gui # this function only returns once the sound finishes def blockingSound(): app.playSound(\"sound.wav\", wait=True) app.infoBox(\"Sound\", \"Finished sound\") # play the sound in a thread def playSound(): app.thread(blockingSound) with gui(\"SOUND\") as app: app.button(\"PLAY\", playSound) .stopSound() This will stop whatever sound is currently being played. .loopSound(sound) This will play the named sound in a loop, in the background. .setSoundLocation(location) Set a folder for the sound files. This will be put before the names of any sound files used. Playing Built-In Sounds .bell() This will work on all platforms, playing a bell sound. .soundError() This will sound a simple error beep. .soundWarning() This will sound a simple warning beep. Playing Musical Notes .playNote(note, duration=200) Support is built in for playing musical notes, using winsound. The note can be a numeric frequency, or a String note. The duration can be a number in milliseconds, or a String duration. Over 50 String notes are available, such as: f#1 = 46 b7 = 3951 g9 = 12543 The following String durations are supported: BREVE = 2000 SEMIBREVE = 1000 MINIM = 500 CROTCHET = 250 QUAVER = 125 SEMIQUAVER = 63 DEMISEMIQUAVER = 32 HEMIDEMISEMIQUAVER = 16 These can be accessed through the variables gui.NOTES and gui.DURATIONS","title":"Sounds"},{"location":"pythonSound/#sound","text":"Sound is only supported in Windows, using the Winsound API. Therefore, only .WAV files will work.","title":"Sound"},{"location":"pythonSound/#playing-sound-files","text":".playSound(sound, wait=False) Play the named sound file. By default, the sound plays in the background (asynchronously), meaning the function will return immediately. If you set wait=True the GUI will wait for the sound to finish - not recommended , as the GUI will become unresponsive. If you want to wait for a sound to finish, use a thread . NB. this causes a few issues : Threaded sounds queue up and only start when the previous threaded sound finishes. Trying to play a non-threaded sound does nothing, and returns immediately. Trying to stop a threaded sound won't work, but WILL cause the GUI to hang, until the sound (and any queued sounds) finishes. from appJar import gui # this function only returns once the sound finishes def blockingSound(): app.playSound(\"sound.wav\", wait=True) app.infoBox(\"Sound\", \"Finished sound\") # play the sound in a thread def playSound(): app.thread(blockingSound) with gui(\"SOUND\") as app: app.button(\"PLAY\", playSound) .stopSound() This will stop whatever sound is currently being played. .loopSound(sound) This will play the named sound in a loop, in the background. .setSoundLocation(location) Set a folder for the sound files. This will be put before the names of any sound files used.","title":"Playing Sound Files"},{"location":"pythonSound/#playing-built-in-sounds","text":".bell() This will work on all platforms, playing a bell sound. .soundError() This will sound a simple error beep. .soundWarning() This will sound a simple warning beep.","title":"Playing Built-In Sounds"},{"location":"pythonSound/#playing-musical-notes","text":".playNote(note, duration=200) Support is built in for playing musical notes, using winsound. The note can be a numeric frequency, or a String note. The duration can be a number in milliseconds, or a String duration. Over 50 String notes are available, such as: f#1 = 46 b7 = 3951 g9 = 12543 The following String durations are supported: BREVE = 2000 SEMIBREVE = 1000 MINIM = 500 CROTCHET = 250 QUAVER = 125 SEMIQUAVER = 63 DEMISEMIQUAVER = 32 HEMIDEMISEMIQUAVER = 16 These can be accessed through the variables gui.NOTES and gui.DURATIONS","title":"Playing Musical Notes"},{"location":"pythonSubWindows/","text":"Sub Window A way to add additional windows, which can be hidden and shown. from appJar import gui def launch(win): app.showSubWindow(win) app=gui() # these go in the main window app.addButtons([\"one\", \"two\"], launch) # this is a pop-up app.startSubWindow(\"one\", modal=True) app.addLabel(\"l1\", \"SubWindow One\") app.stopSubWindow() # this is another pop-up app.startSubWindow(\"two\") app.addLabel(\"l2\", \"SubWindow Two\") app.stopSubWindow() app.go() Definition of SubWindows happens in the same part of the code as the rest of the GUI, but they default to being hidden. Both SubWindows and the main window can be shown and hidden - this is usually done through button presses. Start/Stop Sub Windows .startSubWindow(name, title=None, modal=False, transient=False, blocking=False) & .stopSubWindow() Used to start and stop defining a SubWindow Setting a title will override the name as a title for the SubWindow . Setting modal to True, will prevent the user from interacting with the parent window until the SubWindow is closed. Setting transient to True, will cause the SubWindow to respond to parent window events such as hide, show & move. Setting blocking to True, will stop execution of your code once the SubWindow is shown, until the user closes it. .openSubWindow(title) Used to reopen the named SubWindow . This lets you modify SubWindows in a different part of the code, for example in a function call. Show/Hide Sub Windows .go(startWindow=None) If you set a SubWindow as the startWindow appJar will start-up showing the named SubWindow . The main window will be minimized. def login(btn): app.hideSubWindow(\"Login\") app.show() app.startSubWindow(\"Login\") app.addLabel(\"l2\", \"Login Window\") app.addButton(\"SUBMIT\", login) app.stopSubWindow() app.go(startWindow=\"Login\") .showSubWindow(title, hide=False) Will cause the specified SubWindow to be shown. If it is set as modal the parent window will become uninteractive until the SubWindow is closed. If hide is set to True, all other SubWindows will be hidden. .showAllSubWindows() Will show all SubWindows . .hideSubWindow(title, useStopFunction=False) & .confirmHideSubWindow(title) Used to hide the specified SubWindow . This will not destroy the SubWindow , so it can be shown again later. By default it bypasses any stopFunction . Set useStopFunction to be True or call .confirmHideSubWindow() to use the stopFunction . .hideAllSubWindows(useStopFunction=False) Will hide all SubWindows . Set useStopFunction to be True to use the stopFunction . .destroySubWindow(title) This will hide and permanently destroy the specified SubWindow . It cannot be shown again. .destroyAllSubWindows() This will hide and permanently destroy all SubWindows . It's useful to be able to create a button that stops a SubWindow: If you define a button, that calls .hideSubWindow() or .destroySubWindow() , and give it the same name as the SubWindow , then it will hide/destroy the SubWindow , and call any associated .stopFunction() . app.startSubWindow(\"Demo\") app.addLabel(\"l1\", \"Press the button to close this window\") # set the button's name to match the SubWindow's name app.addNamedButton(\"CLOSE\", \"Demo\", app.hideSubWindow) app.stopSubWindow() Set Sub Windows Note, all functions available on the main window are also available on SubWindows . Simply call those functions after starting a SubWindow . app.startSubWindow(\"one\", modal=True) app.setBg(\"orange\") app.setSize(400, 400) app.setTransparency(25) app.setStopFunction(checkDone) app.addLabel(\"l1\", \"In sub window\") app.stopSubWindow() Empty Sub Windows If you want to remove all widgets from a SubWindow and repopulate it, you can use the empty function. .emptySubWindow(name) This will empty (delete all widgets) the named SubWindow Or, you can empty the SubWindow whilst it's open: .emptyCurrentContainer() This will empty (delete all widgets) the current container. app.startSubWindow(\"one\", modal=True) # first, delete any widgets in this SubWindow app.emptyCurrentContainer() app.setBg(\"orange\") app.setSize(400, 400) app.setTransparency(25) app.setStopFunction(checkDone) app.addLabel(\"l1\", \"In sub window\") app.stopSubWindow()","title":"Multiple Windows"},{"location":"pythonSubWindows/#sub-window","text":"A way to add additional windows, which can be hidden and shown. from appJar import gui def launch(win): app.showSubWindow(win) app=gui() # these go in the main window app.addButtons([\"one\", \"two\"], launch) # this is a pop-up app.startSubWindow(\"one\", modal=True) app.addLabel(\"l1\", \"SubWindow One\") app.stopSubWindow() # this is another pop-up app.startSubWindow(\"two\") app.addLabel(\"l2\", \"SubWindow Two\") app.stopSubWindow() app.go() Definition of SubWindows happens in the same part of the code as the rest of the GUI, but they default to being hidden. Both SubWindows and the main window can be shown and hidden - this is usually done through button presses.","title":"Sub Window"},{"location":"pythonSubWindows/#startstop-sub-windows","text":".startSubWindow(name, title=None, modal=False, transient=False, blocking=False) & .stopSubWindow() Used to start and stop defining a SubWindow Setting a title will override the name as a title for the SubWindow . Setting modal to True, will prevent the user from interacting with the parent window until the SubWindow is closed. Setting transient to True, will cause the SubWindow to respond to parent window events such as hide, show & move. Setting blocking to True, will stop execution of your code once the SubWindow is shown, until the user closes it. .openSubWindow(title) Used to reopen the named SubWindow . This lets you modify SubWindows in a different part of the code, for example in a function call.","title":"Start/Stop Sub Windows"},{"location":"pythonSubWindows/#showhide-sub-windows","text":".go(startWindow=None) If you set a SubWindow as the startWindow appJar will start-up showing the named SubWindow . The main window will be minimized. def login(btn): app.hideSubWindow(\"Login\") app.show() app.startSubWindow(\"Login\") app.addLabel(\"l2\", \"Login Window\") app.addButton(\"SUBMIT\", login) app.stopSubWindow() app.go(startWindow=\"Login\") .showSubWindow(title, hide=False) Will cause the specified SubWindow to be shown. If it is set as modal the parent window will become uninteractive until the SubWindow is closed. If hide is set to True, all other SubWindows will be hidden. .showAllSubWindows() Will show all SubWindows . .hideSubWindow(title, useStopFunction=False) & .confirmHideSubWindow(title) Used to hide the specified SubWindow . This will not destroy the SubWindow , so it can be shown again later. By default it bypasses any stopFunction . Set useStopFunction to be True or call .confirmHideSubWindow() to use the stopFunction . .hideAllSubWindows(useStopFunction=False) Will hide all SubWindows . Set useStopFunction to be True to use the stopFunction . .destroySubWindow(title) This will hide and permanently destroy the specified SubWindow . It cannot be shown again. .destroyAllSubWindows() This will hide and permanently destroy all SubWindows . It's useful to be able to create a button that stops a SubWindow: If you define a button, that calls .hideSubWindow() or .destroySubWindow() , and give it the same name as the SubWindow , then it will hide/destroy the SubWindow , and call any associated .stopFunction() . app.startSubWindow(\"Demo\") app.addLabel(\"l1\", \"Press the button to close this window\") # set the button's name to match the SubWindow's name app.addNamedButton(\"CLOSE\", \"Demo\", app.hideSubWindow) app.stopSubWindow()","title":"Show/Hide Sub Windows"},{"location":"pythonSubWindows/#set-sub-windows","text":"Note, all functions available on the main window are also available on SubWindows . Simply call those functions after starting a SubWindow . app.startSubWindow(\"one\", modal=True) app.setBg(\"orange\") app.setSize(400, 400) app.setTransparency(25) app.setStopFunction(checkDone) app.addLabel(\"l1\", \"In sub window\") app.stopSubWindow()","title":"Set Sub Windows"},{"location":"pythonSubWindows/#empty-sub-windows","text":"If you want to remove all widgets from a SubWindow and repopulate it, you can use the empty function. .emptySubWindow(name) This will empty (delete all widgets) the named SubWindow Or, you can empty the SubWindow whilst it's open: .emptyCurrentContainer() This will empty (delete all widgets) the current container. app.startSubWindow(\"one\", modal=True) # first, delete any widgets in this SubWindow app.emptyCurrentContainer() app.setBg(\"orange\") app.setSize(400, 400) app.setTransparency(25) app.setStopFunction(checkDone) app.addLabel(\"l1\", \"In sub window\") app.stopSubWindow()","title":"Empty Sub Windows"},{"location":"pythonThreads/","text":"Threads For things that take a long time... Looping is great for regularly updating the GUI, but if you want to call a function that might take a long time (such as downloading a file) you need to use a thread . Running your functions in threads allows the main GUI loop to keep running, so that the GUI won't hang. NB. Threads don't always work nicely with GUIs, so your thread mustn't try to change the GUI, instead you will need to put any GUI updates in a Queue ( see below ). Threading .thread(func, *args, **kwargs) This allows you to run your own functions in a separate thread, so they doesn't cause the GUI to hang. Pass the name of your function (with no brackets) and any arguments that it requires. For example: app.thread(myFunction, param1, param2) .threadCallback(func, callback, *args, **kwargs) Runs the specified function in a thread, with the passed in arguments. Once the thread completes, call the callback function, passing in any return value from the original function. def uploadFile(filename): # this would upload the file to a server pass def uploader(btn=None): filename = app.getEntry(\"file\") if filename != \"\": app.setLabel(\"uploadStatus\", \"Uploading \" + filename) # call uploadFile(), with the contents of the \"file\" entry box # when uploadFile() completes, its return value will be passed to uploadComplete() app.threadCallback(uploadFile, uploadComplete, filename) def uploadComplete(success): if success: message = \"Upload complete\" else: message = \"Upload failed\" app.queueFunction(app.setLabel, \"uploadStatus\", message) app.addLabel(\"uploadStatus\", \"No uploads\") app.addFileEntry(\"file\") app.addButton(\"UPLOAD\", uploader) Queueing You mustn't try to update the GUI directly from a thread. Instead, you should add all your updates to appJar's update queue , and let appJar update the GUI. .queueFunction(func, *args, **kwargs) Pass the name of the GUI function (with no brackets) you want to call, along with any arguments it requires. For example: app.queueFunction(app.setLabel, \"l1\", \"new label text\") downloadCount = 0 def downloader(): global downloadCount # it's fine to put loops in threads for i in range(5): # update the GUI through the GUI queue app.queueFunction(app.setLabel, \"l1\", \"Starting download \" + str(downloadCount)) # this takes a long time downloadFile(\"file\" + str(downloadCount) + \".dat\") # update the GUI through the GUI queue app.queueFunction(app.setLabel, \"l1\", \"Finished download \" + str(downloadCount)) # it's fine to put sleeps in threads time.sleep(1) # put the downloader function in its own thread app.thread(downloader)","title":"Threads"},{"location":"pythonThreads/#threads","text":"For things that take a long time... Looping is great for regularly updating the GUI, but if you want to call a function that might take a long time (such as downloading a file) you need to use a thread . Running your functions in threads allows the main GUI loop to keep running, so that the GUI won't hang. NB. Threads don't always work nicely with GUIs, so your thread mustn't try to change the GUI, instead you will need to put any GUI updates in a Queue ( see below ).","title":"Threads"},{"location":"pythonThreads/#threading","text":".thread(func, *args, **kwargs) This allows you to run your own functions in a separate thread, so they doesn't cause the GUI to hang. Pass the name of your function (with no brackets) and any arguments that it requires. For example: app.thread(myFunction, param1, param2) .threadCallback(func, callback, *args, **kwargs) Runs the specified function in a thread, with the passed in arguments. Once the thread completes, call the callback function, passing in any return value from the original function. def uploadFile(filename): # this would upload the file to a server pass def uploader(btn=None): filename = app.getEntry(\"file\") if filename != \"\": app.setLabel(\"uploadStatus\", \"Uploading \" + filename) # call uploadFile(), with the contents of the \"file\" entry box # when uploadFile() completes, its return value will be passed to uploadComplete() app.threadCallback(uploadFile, uploadComplete, filename) def uploadComplete(success): if success: message = \"Upload complete\" else: message = \"Upload failed\" app.queueFunction(app.setLabel, \"uploadStatus\", message) app.addLabel(\"uploadStatus\", \"No uploads\") app.addFileEntry(\"file\") app.addButton(\"UPLOAD\", uploader)","title":"Threading"},{"location":"pythonThreads/#queueing","text":"You mustn't try to update the GUI directly from a thread. Instead, you should add all your updates to appJar's update queue , and let appJar update the GUI. .queueFunction(func, *args, **kwargs) Pass the name of the GUI function (with no brackets) you want to call, along with any arguments it requires. For example: app.queueFunction(app.setLabel, \"l1\", \"new label text\") downloadCount = 0 def downloader(): global downloadCount # it's fine to put loops in threads for i in range(5): # update the GUI through the GUI queue app.queueFunction(app.setLabel, \"l1\", \"Starting download \" + str(downloadCount)) # this takes a long time downloadFile(\"file\" + str(downloadCount) + \".dat\") # update the GUI through the GUI queue app.queueFunction(app.setLabel, \"l1\", \"Finished download \" + str(downloadCount)) # it's fine to put sleeps in threads time.sleep(1) # put the downloader function in its own thread app.thread(downloader)","title":"Queueing"},{"location":"pythonTtk/","text":"ttk (very BETA) appJar includes experimental support for ttk , a tk themed widget set . If you run appJar in ttk mode, some of the widgets will be replaced with more native looking widgets. NB. appJar has a lot of built in styling for standard widgets, supporting ttk has required changing how all this is done. When you come across issues, please log them in GitHub. Enabling ttk .gui(useTtk=True) To enable ttk, set the useTtk flag in the appJar constructor to True . If you want to specify a particular theme, set it to the name of the theme. .setTtkTheme(theme) This allows you to choose a different theme to use. .getTtkTheme() Returns the currently selected ttk theme as a string. Themes ttk will default to a theme similar to the operating system. A list of additional themes can be displayed by calling: .getTtkThemes() Returns a list of theme names. Additional themes can be installed using ttk extensions . These can be installed via pip: pip install ttkthemes And then used the same as any other theme: app.setTtkTheme(\"black\") . Styling ttk Widgets appJar stores the ttk style as app.ttkStyle this can be modified or changed directly as required. Default Widget Style Each widget type has its own style, such as TLabel or TButton . To change the style for all widgets of a certain type, reconfigure these styles: app.ttkStyle.configure(\"TLabel\", foreground=\"green\", background=\"blue\") Extra Styles Some widgets have their own extra styles you can change: Toolbar.TFrame - used for the toolbar Toolbar.TLabel - used for the pin button on the toolbar * Toolbar.TButton - used for the buttons on the toolbar Root Style All widgets inherit their style from the root style, known simply as . If you want to change the style of all widgets, you can modify the root style. NB. if particular widget types have set their own styles, modifying the root style won't change them. app.ttkStyle.configure(\".\", background=\"black\", foreground=\"white\") Create Your Own Styles Finally, it's possible to create your own styles, and use them for particular widgets. Your new style should inherit from the widget's style: MyButton.TButton app.ttkStyle.configure(\"MyButton.TButton\", foreground=\"red\") You can also create dynamic appearance changes to the widgets, called 'maps'. These allow you to change the properties of the widget in response to certain events, such as changing the colour of a button when the cursor is over it. app.ttkStyle.map(\"MyButton.TButton\", background=[(\"active\", \"blue\")]) You'll need to pass a list, which contains tuples as a parameter. * Each tuple is responsible for changing one aspect of the widget in a particular state. To have multiple changes, you can have more than one tuple within the list. The first item in the tuple should be the state . In this case, it is active . This means that something will be changed when the cursor is within the widget. The second item will be the value . In this case, the button will have a blue background when the cursor is over it. You can learn more about ttk maps here . You then need to apply this style (which includes both ttkStyle.configure and ttkStyle.map ) to the relevant widgets: .set XXX Style(style) This lets you specify the name of a style for a particular widget. app.setEntryStyle(\"Name\", \"BW.TEntry\") Built in Setters You can still use the existing setters for background .setBg() and foreground .setFg() : app.setBg(\"blue\") app.setFg(\"yellow\") Command Line Arguments It's possible to switch on ttk theming from the command line . Simply use the --ttk flag, with an optional theme name: python3 themes.py --ttk # turn on ttk widgets Turn on ttk widgets and set a theme: python3 themes.py --ttk aqua # turn on ttk with the aqua theme","title":"ttk (BETA)"},{"location":"pythonTtk/#ttk-very-beta","text":"appJar includes experimental support for ttk , a tk themed widget set . If you run appJar in ttk mode, some of the widgets will be replaced with more native looking widgets. NB. appJar has a lot of built in styling for standard widgets, supporting ttk has required changing how all this is done. When you come across issues, please log them in GitHub.","title":"ttk (very BETA)"},{"location":"pythonTtk/#enabling-ttk","text":".gui(useTtk=True) To enable ttk, set the useTtk flag in the appJar constructor to True . If you want to specify a particular theme, set it to the name of the theme. .setTtkTheme(theme) This allows you to choose a different theme to use. .getTtkTheme() Returns the currently selected ttk theme as a string.","title":"Enabling ttk"},{"location":"pythonTtk/#themes","text":"ttk will default to a theme similar to the operating system. A list of additional themes can be displayed by calling: .getTtkThemes() Returns a list of theme names. Additional themes can be installed using ttk extensions . These can be installed via pip: pip install ttkthemes And then used the same as any other theme: app.setTtkTheme(\"black\") .","title":"Themes"},{"location":"pythonTtk/#styling-ttk-widgets","text":"appJar stores the ttk style as app.ttkStyle this can be modified or changed directly as required.","title":"Styling ttk Widgets"},{"location":"pythonTtk/#default-widget-style","text":"Each widget type has its own style, such as TLabel or TButton . To change the style for all widgets of a certain type, reconfigure these styles: app.ttkStyle.configure(\"TLabel\", foreground=\"green\", background=\"blue\")","title":"Default Widget Style"},{"location":"pythonTtk/#extra-styles","text":"Some widgets have their own extra styles you can change: Toolbar.TFrame - used for the toolbar Toolbar.TLabel - used for the pin button on the toolbar * Toolbar.TButton - used for the buttons on the toolbar","title":"Extra Styles"},{"location":"pythonTtk/#root-style","text":"All widgets inherit their style from the root style, known simply as . If you want to change the style of all widgets, you can modify the root style. NB. if particular widget types have set their own styles, modifying the root style won't change them. app.ttkStyle.configure(\".\", background=\"black\", foreground=\"white\")","title":"Root Style"},{"location":"pythonTtk/#create-your-own-styles","text":"Finally, it's possible to create your own styles, and use them for particular widgets. Your new style should inherit from the widget's style: MyButton.TButton app.ttkStyle.configure(\"MyButton.TButton\", foreground=\"red\") You can also create dynamic appearance changes to the widgets, called 'maps'. These allow you to change the properties of the widget in response to certain events, such as changing the colour of a button when the cursor is over it. app.ttkStyle.map(\"MyButton.TButton\", background=[(\"active\", \"blue\")]) You'll need to pass a list, which contains tuples as a parameter. * Each tuple is responsible for changing one aspect of the widget in a particular state. To have multiple changes, you can have more than one tuple within the list. The first item in the tuple should be the state . In this case, it is active . This means that something will be changed when the cursor is within the widget. The second item will be the value . In this case, the button will have a blue background when the cursor is over it. You can learn more about ttk maps here . You then need to apply this style (which includes both ttkStyle.configure and ttkStyle.map ) to the relevant widgets: .set XXX Style(style) This lets you specify the name of a style for a particular widget. app.setEntryStyle(\"Name\", \"BW.TEntry\")","title":"Create Your Own Styles"},{"location":"pythonTtk/#built-in-setters","text":"You can still use the existing setters for background .setBg() and foreground .setFg() : app.setBg(\"blue\") app.setFg(\"yellow\")","title":"Built in Setters"},{"location":"pythonTtk/#command-line-arguments","text":"It's possible to switch on ttk theming from the command line . Simply use the --ttk flag, with an optional theme name: python3 themes.py --ttk # turn on ttk widgets Turn on ttk widgets and set a theme: python3 themes.py --ttk aqua # turn on ttk with the aqua theme","title":"Command Line Arguments"},{"location":"pythonWidgetGrouping/","text":"Grouping Widgets The standard way of using appJar , is simply to place all widgets into a single window. Everything is grouped into that single window, and any changes affect everything in that window. It's sometimes desirable to group widgets together within a window. Or to have multiple pages of widgets. A number of options are provided to make this easier. Format All of these methods work in the same way. You call the start function when you want to start a container, then the stop function when you're done. When you call start you can pass in positional arguments like any other widget (row, column, rowspan, colspan). Any GUI Options you set, within the container, will only affect that container. Reopening Containers If you want to dynamically add widgets to a container, once the gui has been started, you can open a specific container, perform the desired actions, then stop it again. def addRows(btn): count = app.getEntry(\"numRows\") app.openTab(\"tabbedPane\", \"Details Tab\") # open the required tab for rowLoop in range(count): # add a new label, with a unique ID # make sure to put it in the right place app.addLabel(\"dyn\"+str(rowLoop), \"Dynamic Label\", rowLoop+5) app.stopTab() Frame A way of grouping together widgets. Position the Frame within the grid, then position widgets inside the Frame from appJar import gui app=gui(\"FRAME DEMO\", \"250x150\") app.setBg(\"yellow\") app.startFrame(\"LEFT\", row=0, column=0) app.setBg(\"blue\") app.setSticky(\"NEW\") app.setStretch(\"COLUMN\") app.addLabel(\"LEFT LABEL\", \"Label on the left 1\") app.setLabelBg(\"LEFT LABEL\", \"red\") app.addLabel(\"LEFT LABEL2\", \"Label on the left 2\") app.setLabelBg(\"LEFT LABEL2\", \"orange\") app.addLabel(\"LEFT LABEL3\", \"Label on the left 3\") app.setLabelBg(\"LEFT LABEL3\", \"yellow\") app.stopFrame() app.startFrame(\"RIGHT\", row=0, column=1) app.setBg(\"green\") app.setFg(\"white\") for x in range(5): app.addRadioButton(\"RADIO\", \"Choice \" + str(x)) app.stopFrame() app.go() Or in v1.0: from appJar import gui with gui(\"FRAME DEMO\", \"250x150\", bg='yellow') as app: with app.frame(\"LEFT\", row=0, column=0, bg='blue', sticky='NEW', stretch='COLUMN'): app.label(\"Label on the left 1\", bg='red') app.label(\"Label on the left 2\", bg='orange') app.label(\"Label on the left 3\", bg='yellow') with app.frame(\"RIGHT\", row=0, column=1, bg='green', fg='white'): for x in range(5): app.radio(\"RADIO\", \"Choice \" + str(x)) Start/Stop Frames .startFrame(name) & .stopFrame() Used to start and stop a Frame . .openFrame(title) Used to reopen the named Frame . Juggling Frames .raiseFrame(name) Lifts the named frame to the top of the grid stack. If two frames are placed in the same grid square, this is used to determine which is on top. By default, the last frame added is on top. from appJar import gui with gui() as app: with app.frame(\"ONE\", 0,0): app.label(\"In frame one\") with app.frame(\"TWO\", 0,0): app.label(\"In frame two\") app.buttons([\"ONE\", \"TWO\"], app.raiseFrame) Frame Stack A way of having mutiple frames on top of each other, with all but one hidden. Each frame is created and added to the stack. Then they can be navigated through, using first , next , prev and last . from appJar import gui def press(btn): if btn == \"FIRST\": app.firstFrame(\"Pages\") elif btn == \"NEXT\": app.nextFrame(\"Pages\") elif btn == \"PREV\": app.prevFrame(\"Pages\") elif btn == \"LAST\": app.lastFrame(\"Pages\") app=gui(\"FRAME STACK\") app.startFrameStack(\"Pages\") app.startFrame() for i in range(5): app.addLabel(\"Text: \" + str(i)) app.stopFrame() app.startFrame() for i in range(5): app.addEntry(\"e\" + str(i)) app.stopFrame() app.startFrame() for i in range(5): app.addButton(str(i), None) app.stopFrame() app.stopFrameStack() app.addButtons([\"FIRST\", \"PREV\", \"NEXT\", \"LAST\"], press) app.go() Or in v1.0: from appJar import gui def press(btn): if btn == \"FIRST\": app.firstFrame(\"Pages\") elif btn == \"NEXT\": app.nextFrame(\"Pages\") elif btn == \"PREV\": app.prevFrame(\"Pages\") elif btn == \"LAST\": app.lastFrame(\"Pages\") with gui(\"FRAME STACK\") as app: with app.frameStack(\"Pages\", start=0): with app.frame(): for i in range(5): app.label(\"Text: \" + str(i)) with app.frame(): for i in range(5): app.entry(\"e\" + str(i)) with app.frame(): for i in range(5): app.button(str(i), None) app.buttons([\"FIRST\", \"PREV\", \"NEXT\", \"LAST\"], press) Start/Stop Frame Stacks .startFrameStack(title, change=None, start=-1) & .stopFrameStack() Used to start & stop a FrameStack Multiple Frames should be added to the FrameStack and can then be navigated through. Set start to the frame you want initially displayed. Defaults to the last frame added. Set change to a function to call when the FrameStack is changed. .openFrameStack(title) Used to reopen the named FrameStack , for later modification. .setFrameStackChangeFunction(title, function) Sets a function to call whenever the FrameStack is changed. If this function returns False , then the frame won't change (if it returns nothing, then it will change). Useful when used in conjunction with .getPreviousFrame(title) as checks can be run before allowing the user to progress. .setStartFrame(title, num) Sets the frame that will be displayed when the GUI starts. Navigating Frame Stacks .frameStackAtStart(title) & .frameStackAtEnd(title) Returns True/False if the FrameStack is showing the first/last Frame. .nextFrame(title, callFunction=True) Display the next frame in the stack. .prevFrame(title, callFunction=True) Display the previous frame in the stack. .firstFrame(title, callFunction=True) Display the first frame in the stack. .lastFrame(title, callFunction=True) Display the last frame in the stack. .selectFrame(title, num, callFunction=True) Display the frame ay the specified position in the stack (starting at 0). .getPreviousFrame(title) & .getCurrentFrame(title) Returns the frame number of the previously shown and currently show frame. .countFrames(title) Returns the number of frames in the stack. Label Frame A way of grouping widgets into a box, with a label at the top of the box. Position the LabelFrame within the grid, then position widgets inside the LabelFrame NB. LabelFrames have a different stickiness to the appJar GUI - they only stick widgets to the w (left) side. If you want your widgets to stretch across the LabelFrame , like the rest of appJar , you will need to call app.setSticky(\"ew\") after starting the LabelFrame . from appJar import gui app=gui() app.startLabelFrame(\"Login Details\") # these only affect the labelFrame app.setSticky(\"ew\") app.setFont(20) app.addLabel(\"l1\", \"Name\", 0, 0) app.addEntry(\"Name\", 0, 1) app.addLabel(\"l2\", \"Password\", 1, 0) app.addEntry(\"Password\", 1, 1) app.addButtons([\"Submit\", \"Cancel\"], None, 2, 0, 2) app.stopLabelFrame() app.go() Start/Stop Label Frames .startLabelFrame(title, hideTitle=False, label=None) & .stopLabelFrame() Used to start and stop a LabelFrame The specified title will be used as the label for the frame. Set label if you want to show a different label for the frame. Set hideTitle to be True or label to be an empty String if you don't want to show a title. .openLabelFrame(title) Used to reopen the named LabelFrame , for later modification. Set Label Frames .setLabelFrameTitle(title, newTitle) Used to change the label displayed in the LabelFrame . .setLabelFrameAnchor(title, position) Used to change the position of the label on the LabelFrame . Use compass coordinates, eg. \"ne\" or \"sw\" . .setSticky(coords) By default, widgets in the frame will align on the left. If you want to change this, specify a different sticky value. For example, .setSticky(\"ew\") will cause the widgets to stretch to fit the width, aligning in the centre. Scroll Pane A scrollable pane, inside a frame, to contain widgets. Allows you to have more widgets than will fit on the screen, or have a smaller window than required. from appJar import gui app=gui(\"SCROLLABLE DEMO\", \"150x150\") app.startScrollPane(\"PANE\") for x in range(10): for y in range(10): name = str(x) + \"-\" + str(y) app.addLabel(name, name, row=x, column=y) app.setLabelBg(name, app.RANDOM_COLOUR()) app.stopScrollPane() app.go() Scrolling The ScrollPane has been configured to allow scrolling through lots of different methods: On Mac & Windows horizontal & vertical scroll events (generated by amouse/trackpad) will work as normal. On Linux horizontal scroll events will work, <SHIFT> horizontal scroll events will scroll vertically. The following key presses will also work: <Up> & <Down>: Move up or down the equivalent of a line <Left> & <Right>: Move left or right the equivalent of a line <PageUp> & <PageDown>: Move up or down the equivalent of a page <Ctrl><PageUp> & <Ctrl><PageDown>: Move left or right the equivalent of a page <Ctrl><Up> & <Ctrl><Down>: Move up or down the equivalent of a page <Ctrl><Left> & <Ctrl><Right>: Move left or right the equivalent of a page <Home> & <End>: Move to the top or bottom <Ctrl><Home> & <Ctrl><End>: Move to the far-left or the far-right Start/Stop Scroll Panes .startScrollPane(title) & .stopScrollPane() Used to start and stop the ScrollPane . Pass a disabled parameter of horizontal or vertical to disable one of the scrollbars. .openScrollPane(title) Used to reopen the named ScrollPane , for later modification. Toggle Frame A collapsible container for a group of related widgets. By default, the contents of the frame are hidden. They can be revealed/hidden again by clicking an associated button. from appJar import gui app=gui() app.setFont(20) app.startToggleFrame(\"Options\") app.addCheckBox(\"Show this\") app.addCheckBox(\"Show that\") app.addCheckBox(\"Show the other\") app.setCheckBox(\"Show that\") app.stopToggleFrame() app.go() Start/Stop Toggle Frames .startToggleFrame(title) & .stopToggleFrame(title) Used to start and stop a ToggleFrame . The title will be used as the title for the ToggleFrame . .openToggleFrame(title) Used to reopen the named ToggleFrame . Set Toggle Frames .setToggleFrameText(title, newText) Will update the text displayed in the ToggleFrame . .toggleToggleFrame(title) Will toggle the state of the specified ToggleFrame . .disableToggleFrame(title, disabled=True) Will disable the specified ToggleFrame . If disabled is set to False, the ToggleFrame will be re-enabled. Get Toggle Frames .getToggleFrameState(title) Will return True if the ToggleFrame is open, else will return False. Tabbed Frame A way to create a (basic) tabbed-style interface. Position the TabbedFrame within the grid, start a Tab , then position widgets inside the Tab from appJar import gui app=gui() app.startTabbedFrame(\"TabbedFrame\") app.startTab(\"Tab1\") app.addLabel(\"l1\", \"Tab 1 Label\") app.stopTab() app.startTab(\"Tab2\") app.addLabel(\"l2\", \"Tab 2 Label\") app.stopTab() app.startTab(\"Tab3\") app.addLabel(\"l3\", \"Tab 3 Label\") app.stopTab() app.stopTabbedFrame() app.go() Start/Stop Tabbed Frames .startTabbedFrame(name) & .stopTabbedFrame() Used to start & stop a TabbedFrame , with the specified name. .startTab(name, beforeTab=None, afterTab=None) & .stopTab() Used to start and stop each of the tabs in the TabbedFrame . The title for the tab will be the specified name . If beforeTab / afterTab are populated, the tab will be positioned appropriately. .openTabbedFrame(title) & .openTab(frameTitle, tabTitle) Used to reopen the named TabbedFrame or named Tab . Set TabbedFrame .setTabText(title, tab, newText=None) Change the text of the named tab in the specified TabbedFrame . If no newText is provided, the tab will revert back to its original text. .setTabbedFrameTabExpand(title, expand=True) By default, the tabs take up the minimum amount of space necessary. Set this to True, to have the tabs fill the entire row. .setTabbedFrameSelectedTab(title, tab, callFunction=True) Select the specified tab in the TabbedFrame. Set callFunction to be False, if you don't want to call any associated functions. .setTabbedFrameChangeCommand(title, func) Set a function to call when the tab is changed. .setTabbedFrameDisabledTab(title, tab, disabled=True) Disable the specified tab in the TabbedFrame. Set disabled to False to re-enable it. This will also change the displayed tab, if the displayed tab is being disabled. .setTabbedFrameDisableAllTabs(title, disabled=True) Will disable all tabs for the named TabFrame. Or, enable them if disabled is set to False. Changing Colours TabbedFrames have a set of colours that can be changed: ActiveFg - Sets the colour of the text in the active tab ActiveBg - Sets the background colour of the active tab InactiveFg - Sets the colour of the text in all inactive tabs InactiveBg - Sets the background colour of all inactive tabs DisabledFg - Sets the colour of the text in all disabled tabs DisabledBg - Sets the background colour of all disabled tabs Bg - Sets the background colour behind the widget - only visible at the end of the tabs These are all changed via the standard property changing functions, eg: .setTabbedFrameBg(\"t1\", \"red\") .setTabbedFrameActiveBg(\"t1\", \"yellow\") It is also possible to change the colour of individual panes. Call .setBg(\"colour\") while adding widgets to the specific pane. Or .setTabBg(title, tab, 'colour') at other times. Get TabbedFrame .getTabbedFrameSelectedTab(title) Gets the name of the currently selected tab, for the named TabFrame. Notebook NB. This will only work with ttk enabled. NB. Notes have a different stickiness to the appJar GUI - they only stick widgets to the w (left) side. If you want your widgets to stretch across the Note , like the rest of appJar , you will need to call app.setSticky(\"ew\") after starting the Note . Similar to the Tabbed Frame , it is a way of placing widgets in different tabs or 'notes'. Position the Notebook within the grid, start a Note , then position widgets inside the Note . from appJar import gui app = gui(\"Notebook\", useTtk=True) app.setTtkTheme(\"clam\") app.startNotebook(\"Notebook\") app.startNote(\"Note 1\") app.addLabel(\"l1\", \"Note 1\") app.stopNote() app.startNote(\"Note 2\") app.addLabel(\"l2\", \"Note 2\") app.stopNote() app.startNote(\"Note 3\") app.addLabel(\"l3\", \"Note 3\") app.stopNote() app.stopNotebook() app.go() Start/Stop Notebooks .startNotebook(name) & .stopNotebook() Used to start & stop Notebooks , with the specified name. .startNote(name) & .stopNote() Used to start & stop each of the notes in the Notebook . Set Notebooks .getNotebookWidget(name).select([index]) Change the currently selected note, by putting the Notebook's name in name and putting the index of the note as an integer in index . Eg. To change the selected note to Note 3, then the index would be 2 (as 0 is the first note). Styles & Colours You will need to use a ttk Style and Map to change the colour of notebook widget or its tabs. To change the style for the Notebook widget, use TNotebook . To change the style for the Notebook Tabs, use TNotebook.Tab . Paned Frame A way to present re-sizable panes, separated by drag-bars. Once the first pane is placed, all additional panes should be placed inside it. By default, panes will be placed side-by-side (horizontally). This can be changed by setting the pane to vertical, then they'll be placed underneath each other. Start/Stop Paned Frames .startPanedFrame(name) , .startPanedFrameVertical(name) & .stopPanedFrame() Used to start & stop PanedFrames , with the specified name. By default, any panes added to this pane will be added side-by-side (horizontally). Starting a vertical pane will cause additional panes to be stacked on top of each other. .openPanedFrame(title) Used to reopen the named PanedFrame . Set Paned Frames .setPaneSashPosition(pos, pane=None) Used to set the starting position of the sash (divider) between two panes (as a percentage) - defaults to 50%. This property can only be set once the next pane has been added, otherwise the sash won't exist yet. So, it should only be called after .stopPanedFrame() has been called, or during an .openPanedFrame() . If called during an .openPanedFrame() the pane property doesn't need to be set. NB. The final pane doesn't have a sash after it. Horizontal Pane Layout Start an initial pane Start all additional panes inside the initial pane from appJar import gui app = gui() # start initial pane app.startPanedFrame(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start additional panes inside initial pane app.startPanedFrame(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") app.stopPanedFrame() app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop initial pane app.stopPanedFrame() app.go() Vertical Pane Layout Start an initial, vertical pane Start all additional panes inside the initial pane from appJar import gui app = gui() # start initial, vertical pane app.startPanedFrameVertical(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start additional panes inside initial pane app.startPanedFrame(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") app.stopPanedFrame() app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop initial pane app.stopPanedFrame() app.go() E-Pane Layout Start an initial pane Start a second, vertical pane inside the initial pane Start all additional panes inside the second pane from appJar import gui app = gui() # start initial pane app.startPanedFrame(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start second, vertical pane inside initial pane app.startPanedFrameVertical(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") # start additional panes inside second pane app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop second & initial panes app.stopPanedFrame() app.stopPanedFrame() app.go() T-Pane Layout Start an initial, vertical pane Start a second pane, inside the initial pane Start additional panes inside the second pane from appJar import gui app = gui() # start intial, vertical pane app.startPanedFrameVertical(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start second pane app.startPanedFrame(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") # start additional panes inside second pane app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop second & initial panes app.stopPanedFrame() app.stopPanedFrame() app.go() Paged Window A container that mimics a classic phone based interface. It provides PREVIOUS / NEXT buttons to navigate through a series of pages. It has an optional widget title, and shows the current page, in a page counter. Keyboard bindings are provided to navigate with arrow key presses. CTRL-arrow will navigate to the beginning/end. Events can be bound to page changes, the page can be changed via a function call, and the current page number can be queried. from appJar import gui app=gui() app.setBg(\"DarkKhaki\") app.setSize(280,400) app.startPagedWindow(\"Main Title\") app.startPage() app.addLabel(\"l13\", \"Label 1\") app.stopPage() app.startPage() app.addLabel(\"l21\", \"Label 2\") app.stopPage() app.startPage() app.addLabel(\"l3\", \"Label 3\") app.stopPage() app.startPage() app.addLabel(\"l4\", \"Label 4\") app.stopPage() app.stopPagedWindow() app.go() Start/Stop Paged Windows .startPagedWindow(title) & .stopPagedWindow() Used to start and stop a PagedWindow . The title will be used in the title section of the widget. .startPage() & .stopPage() Used to start and stop each new page. Navigation, page count, etc are all dealt with automatically. .openPagedWindow(title) & .openPage(windowTitle, pageNumber) Used to reopen the named PagedWindow or Page . NB. pageNumber must be an integer, starting at 1 for the first page. Set Paged Windows .setPagedWindowTitle(title, title) & .setPagedWindowButtons(title, [buttons]) Used to change the text in the title and buttons. When changing the buttons, two values must be passed in: previous/next. .setPagedWindowButtonsTop(title, top=True) Used to position the navigation buttons. By default, they are at the bottom. Call this function to move them to the top. .setPagedWindowPage(title, pageNum) Used to display the selected page. .setPagedWindowFunction(title, function) Declare a function to call, each time the page is changed. .showPagedWindowPageNumber(title, show=True) & .showPagedWindowTitle(title, show=True) Use these to declare if you want the page title, page numbers to be shown. Get Paged Windows .getPagedWindowPageNumber(title) Used to get the page number currently being shown. Sub Window A way to add additional windows, which can be hidden and shown. This has been moved to its own page: Multiple Windows .","title":"Grouping Widgets"},{"location":"pythonWidgetGrouping/#grouping-widgets","text":"The standard way of using appJar , is simply to place all widgets into a single window. Everything is grouped into that single window, and any changes affect everything in that window. It's sometimes desirable to group widgets together within a window. Or to have multiple pages of widgets. A number of options are provided to make this easier.","title":"Grouping Widgets"},{"location":"pythonWidgetGrouping/#format","text":"All of these methods work in the same way. You call the start function when you want to start a container, then the stop function when you're done. When you call start you can pass in positional arguments like any other widget (row, column, rowspan, colspan). Any GUI Options you set, within the container, will only affect that container.","title":"Format"},{"location":"pythonWidgetGrouping/#reopening-containers","text":"If you want to dynamically add widgets to a container, once the gui has been started, you can open a specific container, perform the desired actions, then stop it again. def addRows(btn): count = app.getEntry(\"numRows\") app.openTab(\"tabbedPane\", \"Details Tab\") # open the required tab for rowLoop in range(count): # add a new label, with a unique ID # make sure to put it in the right place app.addLabel(\"dyn\"+str(rowLoop), \"Dynamic Label\", rowLoop+5) app.stopTab()","title":"Reopening Containers"},{"location":"pythonWidgetGrouping/#frame","text":"A way of grouping together widgets. Position the Frame within the grid, then position widgets inside the Frame from appJar import gui app=gui(\"FRAME DEMO\", \"250x150\") app.setBg(\"yellow\") app.startFrame(\"LEFT\", row=0, column=0) app.setBg(\"blue\") app.setSticky(\"NEW\") app.setStretch(\"COLUMN\") app.addLabel(\"LEFT LABEL\", \"Label on the left 1\") app.setLabelBg(\"LEFT LABEL\", \"red\") app.addLabel(\"LEFT LABEL2\", \"Label on the left 2\") app.setLabelBg(\"LEFT LABEL2\", \"orange\") app.addLabel(\"LEFT LABEL3\", \"Label on the left 3\") app.setLabelBg(\"LEFT LABEL3\", \"yellow\") app.stopFrame() app.startFrame(\"RIGHT\", row=0, column=1) app.setBg(\"green\") app.setFg(\"white\") for x in range(5): app.addRadioButton(\"RADIO\", \"Choice \" + str(x)) app.stopFrame() app.go() Or in v1.0: from appJar import gui with gui(\"FRAME DEMO\", \"250x150\", bg='yellow') as app: with app.frame(\"LEFT\", row=0, column=0, bg='blue', sticky='NEW', stretch='COLUMN'): app.label(\"Label on the left 1\", bg='red') app.label(\"Label on the left 2\", bg='orange') app.label(\"Label on the left 3\", bg='yellow') with app.frame(\"RIGHT\", row=0, column=1, bg='green', fg='white'): for x in range(5): app.radio(\"RADIO\", \"Choice \" + str(x))","title":"Frame"},{"location":"pythonWidgetGrouping/#startstop-frames","text":".startFrame(name) & .stopFrame() Used to start and stop a Frame . .openFrame(title) Used to reopen the named Frame .","title":"Start/Stop Frames"},{"location":"pythonWidgetGrouping/#juggling-frames","text":".raiseFrame(name) Lifts the named frame to the top of the grid stack. If two frames are placed in the same grid square, this is used to determine which is on top. By default, the last frame added is on top. from appJar import gui with gui() as app: with app.frame(\"ONE\", 0,0): app.label(\"In frame one\") with app.frame(\"TWO\", 0,0): app.label(\"In frame two\") app.buttons([\"ONE\", \"TWO\"], app.raiseFrame)","title":"Juggling Frames"},{"location":"pythonWidgetGrouping/#frame-stack","text":"A way of having mutiple frames on top of each other, with all but one hidden. Each frame is created and added to the stack. Then they can be navigated through, using first , next , prev and last . from appJar import gui def press(btn): if btn == \"FIRST\": app.firstFrame(\"Pages\") elif btn == \"NEXT\": app.nextFrame(\"Pages\") elif btn == \"PREV\": app.prevFrame(\"Pages\") elif btn == \"LAST\": app.lastFrame(\"Pages\") app=gui(\"FRAME STACK\") app.startFrameStack(\"Pages\") app.startFrame() for i in range(5): app.addLabel(\"Text: \" + str(i)) app.stopFrame() app.startFrame() for i in range(5): app.addEntry(\"e\" + str(i)) app.stopFrame() app.startFrame() for i in range(5): app.addButton(str(i), None) app.stopFrame() app.stopFrameStack() app.addButtons([\"FIRST\", \"PREV\", \"NEXT\", \"LAST\"], press) app.go() Or in v1.0: from appJar import gui def press(btn): if btn == \"FIRST\": app.firstFrame(\"Pages\") elif btn == \"NEXT\": app.nextFrame(\"Pages\") elif btn == \"PREV\": app.prevFrame(\"Pages\") elif btn == \"LAST\": app.lastFrame(\"Pages\") with gui(\"FRAME STACK\") as app: with app.frameStack(\"Pages\", start=0): with app.frame(): for i in range(5): app.label(\"Text: \" + str(i)) with app.frame(): for i in range(5): app.entry(\"e\" + str(i)) with app.frame(): for i in range(5): app.button(str(i), None) app.buttons([\"FIRST\", \"PREV\", \"NEXT\", \"LAST\"], press)","title":"Frame Stack"},{"location":"pythonWidgetGrouping/#startstop-frame-stacks","text":".startFrameStack(title, change=None, start=-1) & .stopFrameStack() Used to start & stop a FrameStack Multiple Frames should be added to the FrameStack and can then be navigated through. Set start to the frame you want initially displayed. Defaults to the last frame added. Set change to a function to call when the FrameStack is changed. .openFrameStack(title) Used to reopen the named FrameStack , for later modification. .setFrameStackChangeFunction(title, function) Sets a function to call whenever the FrameStack is changed. If this function returns False , then the frame won't change (if it returns nothing, then it will change). Useful when used in conjunction with .getPreviousFrame(title) as checks can be run before allowing the user to progress. .setStartFrame(title, num) Sets the frame that will be displayed when the GUI starts.","title":"Start/Stop Frame Stacks"},{"location":"pythonWidgetGrouping/#navigating-frame-stacks","text":".frameStackAtStart(title) & .frameStackAtEnd(title) Returns True/False if the FrameStack is showing the first/last Frame. .nextFrame(title, callFunction=True) Display the next frame in the stack. .prevFrame(title, callFunction=True) Display the previous frame in the stack. .firstFrame(title, callFunction=True) Display the first frame in the stack. .lastFrame(title, callFunction=True) Display the last frame in the stack. .selectFrame(title, num, callFunction=True) Display the frame ay the specified position in the stack (starting at 0). .getPreviousFrame(title) & .getCurrentFrame(title) Returns the frame number of the previously shown and currently show frame. .countFrames(title) Returns the number of frames in the stack.","title":"Navigating Frame Stacks"},{"location":"pythonWidgetGrouping/#label-frame","text":"A way of grouping widgets into a box, with a label at the top of the box. Position the LabelFrame within the grid, then position widgets inside the LabelFrame NB. LabelFrames have a different stickiness to the appJar GUI - they only stick widgets to the w (left) side. If you want your widgets to stretch across the LabelFrame , like the rest of appJar , you will need to call app.setSticky(\"ew\") after starting the LabelFrame . from appJar import gui app=gui() app.startLabelFrame(\"Login Details\") # these only affect the labelFrame app.setSticky(\"ew\") app.setFont(20) app.addLabel(\"l1\", \"Name\", 0, 0) app.addEntry(\"Name\", 0, 1) app.addLabel(\"l2\", \"Password\", 1, 0) app.addEntry(\"Password\", 1, 1) app.addButtons([\"Submit\", \"Cancel\"], None, 2, 0, 2) app.stopLabelFrame() app.go()","title":"Label Frame"},{"location":"pythonWidgetGrouping/#startstop-label-frames","text":".startLabelFrame(title, hideTitle=False, label=None) & .stopLabelFrame() Used to start and stop a LabelFrame The specified title will be used as the label for the frame. Set label if you want to show a different label for the frame. Set hideTitle to be True or label to be an empty String if you don't want to show a title. .openLabelFrame(title) Used to reopen the named LabelFrame , for later modification.","title":"Start/Stop Label Frames"},{"location":"pythonWidgetGrouping/#set-label-frames","text":".setLabelFrameTitle(title, newTitle) Used to change the label displayed in the LabelFrame . .setLabelFrameAnchor(title, position) Used to change the position of the label on the LabelFrame . Use compass coordinates, eg. \"ne\" or \"sw\" . .setSticky(coords) By default, widgets in the frame will align on the left. If you want to change this, specify a different sticky value. For example, .setSticky(\"ew\") will cause the widgets to stretch to fit the width, aligning in the centre.","title":"Set Label Frames"},{"location":"pythonWidgetGrouping/#scroll-pane","text":"A scrollable pane, inside a frame, to contain widgets. Allows you to have more widgets than will fit on the screen, or have a smaller window than required. from appJar import gui app=gui(\"SCROLLABLE DEMO\", \"150x150\") app.startScrollPane(\"PANE\") for x in range(10): for y in range(10): name = str(x) + \"-\" + str(y) app.addLabel(name, name, row=x, column=y) app.setLabelBg(name, app.RANDOM_COLOUR()) app.stopScrollPane() app.go()","title":"Scroll Pane"},{"location":"pythonWidgetGrouping/#scrolling","text":"The ScrollPane has been configured to allow scrolling through lots of different methods: On Mac & Windows horizontal & vertical scroll events (generated by amouse/trackpad) will work as normal. On Linux horizontal scroll events will work, <SHIFT> horizontal scroll events will scroll vertically. The following key presses will also work: <Up> & <Down>: Move up or down the equivalent of a line <Left> & <Right>: Move left or right the equivalent of a line <PageUp> & <PageDown>: Move up or down the equivalent of a page <Ctrl><PageUp> & <Ctrl><PageDown>: Move left or right the equivalent of a page <Ctrl><Up> & <Ctrl><Down>: Move up or down the equivalent of a page <Ctrl><Left> & <Ctrl><Right>: Move left or right the equivalent of a page <Home> & <End>: Move to the top or bottom <Ctrl><Home> & <Ctrl><End>: Move to the far-left or the far-right","title":"Scrolling"},{"location":"pythonWidgetGrouping/#startstop-scroll-panes","text":".startScrollPane(title) & .stopScrollPane() Used to start and stop the ScrollPane . Pass a disabled parameter of horizontal or vertical to disable one of the scrollbars. .openScrollPane(title) Used to reopen the named ScrollPane , for later modification.","title":"Start/Stop Scroll Panes"},{"location":"pythonWidgetGrouping/#toggle-frame","text":"A collapsible container for a group of related widgets. By default, the contents of the frame are hidden. They can be revealed/hidden again by clicking an associated button. from appJar import gui app=gui() app.setFont(20) app.startToggleFrame(\"Options\") app.addCheckBox(\"Show this\") app.addCheckBox(\"Show that\") app.addCheckBox(\"Show the other\") app.setCheckBox(\"Show that\") app.stopToggleFrame() app.go()","title":"Toggle Frame"},{"location":"pythonWidgetGrouping/#startstop-toggle-frames","text":".startToggleFrame(title) & .stopToggleFrame(title) Used to start and stop a ToggleFrame . The title will be used as the title for the ToggleFrame . .openToggleFrame(title) Used to reopen the named ToggleFrame .","title":"Start/Stop Toggle Frames"},{"location":"pythonWidgetGrouping/#set-toggle-frames","text":".setToggleFrameText(title, newText) Will update the text displayed in the ToggleFrame . .toggleToggleFrame(title) Will toggle the state of the specified ToggleFrame . .disableToggleFrame(title, disabled=True) Will disable the specified ToggleFrame . If disabled is set to False, the ToggleFrame will be re-enabled.","title":"Set Toggle Frames"},{"location":"pythonWidgetGrouping/#get-toggle-frames","text":".getToggleFrameState(title) Will return True if the ToggleFrame is open, else will return False.","title":"Get Toggle Frames"},{"location":"pythonWidgetGrouping/#tabbed-frame","text":"A way to create a (basic) tabbed-style interface. Position the TabbedFrame within the grid, start a Tab , then position widgets inside the Tab from appJar import gui app=gui() app.startTabbedFrame(\"TabbedFrame\") app.startTab(\"Tab1\") app.addLabel(\"l1\", \"Tab 1 Label\") app.stopTab() app.startTab(\"Tab2\") app.addLabel(\"l2\", \"Tab 2 Label\") app.stopTab() app.startTab(\"Tab3\") app.addLabel(\"l3\", \"Tab 3 Label\") app.stopTab() app.stopTabbedFrame() app.go()","title":"Tabbed Frame"},{"location":"pythonWidgetGrouping/#startstop-tabbed-frames","text":".startTabbedFrame(name) & .stopTabbedFrame() Used to start & stop a TabbedFrame , with the specified name. .startTab(name, beforeTab=None, afterTab=None) & .stopTab() Used to start and stop each of the tabs in the TabbedFrame . The title for the tab will be the specified name . If beforeTab / afterTab are populated, the tab will be positioned appropriately. .openTabbedFrame(title) & .openTab(frameTitle, tabTitle) Used to reopen the named TabbedFrame or named Tab .","title":"Start/Stop Tabbed Frames"},{"location":"pythonWidgetGrouping/#set-tabbedframe","text":".setTabText(title, tab, newText=None) Change the text of the named tab in the specified TabbedFrame . If no newText is provided, the tab will revert back to its original text. .setTabbedFrameTabExpand(title, expand=True) By default, the tabs take up the minimum amount of space necessary. Set this to True, to have the tabs fill the entire row. .setTabbedFrameSelectedTab(title, tab, callFunction=True) Select the specified tab in the TabbedFrame. Set callFunction to be False, if you don't want to call any associated functions. .setTabbedFrameChangeCommand(title, func) Set a function to call when the tab is changed. .setTabbedFrameDisabledTab(title, tab, disabled=True) Disable the specified tab in the TabbedFrame. Set disabled to False to re-enable it. This will also change the displayed tab, if the displayed tab is being disabled. .setTabbedFrameDisableAllTabs(title, disabled=True) Will disable all tabs for the named TabFrame. Or, enable them if disabled is set to False.","title":"Set TabbedFrame"},{"location":"pythonWidgetGrouping/#changing-colours","text":"TabbedFrames have a set of colours that can be changed: ActiveFg - Sets the colour of the text in the active tab ActiveBg - Sets the background colour of the active tab InactiveFg - Sets the colour of the text in all inactive tabs InactiveBg - Sets the background colour of all inactive tabs DisabledFg - Sets the colour of the text in all disabled tabs DisabledBg - Sets the background colour of all disabled tabs Bg - Sets the background colour behind the widget - only visible at the end of the tabs These are all changed via the standard property changing functions, eg: .setTabbedFrameBg(\"t1\", \"red\") .setTabbedFrameActiveBg(\"t1\", \"yellow\") It is also possible to change the colour of individual panes. Call .setBg(\"colour\") while adding widgets to the specific pane. Or .setTabBg(title, tab, 'colour') at other times.","title":"Changing Colours"},{"location":"pythonWidgetGrouping/#get-tabbedframe","text":".getTabbedFrameSelectedTab(title) Gets the name of the currently selected tab, for the named TabFrame.","title":"Get TabbedFrame"},{"location":"pythonWidgetGrouping/#notebook","text":"NB. This will only work with ttk enabled. NB. Notes have a different stickiness to the appJar GUI - they only stick widgets to the w (left) side. If you want your widgets to stretch across the Note , like the rest of appJar , you will need to call app.setSticky(\"ew\") after starting the Note . Similar to the Tabbed Frame , it is a way of placing widgets in different tabs or 'notes'. Position the Notebook within the grid, start a Note , then position widgets inside the Note . from appJar import gui app = gui(\"Notebook\", useTtk=True) app.setTtkTheme(\"clam\") app.startNotebook(\"Notebook\") app.startNote(\"Note 1\") app.addLabel(\"l1\", \"Note 1\") app.stopNote() app.startNote(\"Note 2\") app.addLabel(\"l2\", \"Note 2\") app.stopNote() app.startNote(\"Note 3\") app.addLabel(\"l3\", \"Note 3\") app.stopNote() app.stopNotebook() app.go()","title":"Notebook"},{"location":"pythonWidgetGrouping/#startstop-notebooks","text":".startNotebook(name) & .stopNotebook() Used to start & stop Notebooks , with the specified name. .startNote(name) & .stopNote() Used to start & stop each of the notes in the Notebook .","title":"Start/Stop Notebooks"},{"location":"pythonWidgetGrouping/#set-notebooks","text":".getNotebookWidget(name).select([index]) Change the currently selected note, by putting the Notebook's name in name and putting the index of the note as an integer in index . Eg. To change the selected note to Note 3, then the index would be 2 (as 0 is the first note).","title":"Set Notebooks"},{"location":"pythonWidgetGrouping/#styles-colours","text":"You will need to use a ttk Style and Map to change the colour of notebook widget or its tabs. To change the style for the Notebook widget, use TNotebook . To change the style for the Notebook Tabs, use TNotebook.Tab .","title":"Styles &amp; Colours"},{"location":"pythonWidgetGrouping/#paned-frame","text":"A way to present re-sizable panes, separated by drag-bars. Once the first pane is placed, all additional panes should be placed inside it. By default, panes will be placed side-by-side (horizontally). This can be changed by setting the pane to vertical, then they'll be placed underneath each other.","title":"Paned Frame"},{"location":"pythonWidgetGrouping/#startstop-paned-frames","text":".startPanedFrame(name) , .startPanedFrameVertical(name) & .stopPanedFrame() Used to start & stop PanedFrames , with the specified name. By default, any panes added to this pane will be added side-by-side (horizontally). Starting a vertical pane will cause additional panes to be stacked on top of each other. .openPanedFrame(title) Used to reopen the named PanedFrame .","title":"Start/Stop Paned Frames"},{"location":"pythonWidgetGrouping/#set-paned-frames","text":".setPaneSashPosition(pos, pane=None) Used to set the starting position of the sash (divider) between two panes (as a percentage) - defaults to 50%. This property can only be set once the next pane has been added, otherwise the sash won't exist yet. So, it should only be called after .stopPanedFrame() has been called, or during an .openPanedFrame() . If called during an .openPanedFrame() the pane property doesn't need to be set. NB. The final pane doesn't have a sash after it.","title":"Set Paned Frames"},{"location":"pythonWidgetGrouping/#horizontal-pane-layout","text":"Start an initial pane Start all additional panes inside the initial pane from appJar import gui app = gui() # start initial pane app.startPanedFrame(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start additional panes inside initial pane app.startPanedFrame(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") app.stopPanedFrame() app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop initial pane app.stopPanedFrame() app.go()","title":"Horizontal Pane Layout"},{"location":"pythonWidgetGrouping/#vertical-pane-layout","text":"Start an initial, vertical pane Start all additional panes inside the initial pane from appJar import gui app = gui() # start initial, vertical pane app.startPanedFrameVertical(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start additional panes inside initial pane app.startPanedFrame(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") app.stopPanedFrame() app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop initial pane app.stopPanedFrame() app.go()","title":"Vertical Pane Layout"},{"location":"pythonWidgetGrouping/#e-pane-layout","text":"Start an initial pane Start a second, vertical pane inside the initial pane Start all additional panes inside the second pane from appJar import gui app = gui() # start initial pane app.startPanedFrame(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start second, vertical pane inside initial pane app.startPanedFrameVertical(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") # start additional panes inside second pane app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop second & initial panes app.stopPanedFrame() app.stopPanedFrame() app.go()","title":"E-Pane Layout"},{"location":"pythonWidgetGrouping/#t-pane-layout","text":"Start an initial, vertical pane Start a second pane, inside the initial pane Start additional panes inside the second pane from appJar import gui app = gui() # start intial, vertical pane app.startPanedFrameVertical(\"p1\") app.addLabel(\"l1\", \"Inside Pane 1\") # start second pane app.startPanedFrame(\"p2\") app.addLabel(\"l2\", \"Inside Pane 2\") # start additional panes inside second pane app.startPanedFrame(\"p3\") app.addLabel(\"l3\", \"Inside Pane 3\") app.stopPanedFrame() # stop second & initial panes app.stopPanedFrame() app.stopPanedFrame() app.go()","title":"T-Pane Layout"},{"location":"pythonWidgetGrouping/#paged-window","text":"A container that mimics a classic phone based interface. It provides PREVIOUS / NEXT buttons to navigate through a series of pages. It has an optional widget title, and shows the current page, in a page counter. Keyboard bindings are provided to navigate with arrow key presses. CTRL-arrow will navigate to the beginning/end. Events can be bound to page changes, the page can be changed via a function call, and the current page number can be queried. from appJar import gui app=gui() app.setBg(\"DarkKhaki\") app.setSize(280,400) app.startPagedWindow(\"Main Title\") app.startPage() app.addLabel(\"l13\", \"Label 1\") app.stopPage() app.startPage() app.addLabel(\"l21\", \"Label 2\") app.stopPage() app.startPage() app.addLabel(\"l3\", \"Label 3\") app.stopPage() app.startPage() app.addLabel(\"l4\", \"Label 4\") app.stopPage() app.stopPagedWindow() app.go()","title":"Paged Window"},{"location":"pythonWidgetGrouping/#startstop-paged-windows","text":".startPagedWindow(title) & .stopPagedWindow() Used to start and stop a PagedWindow . The title will be used in the title section of the widget. .startPage() & .stopPage() Used to start and stop each new page. Navigation, page count, etc are all dealt with automatically. .openPagedWindow(title) & .openPage(windowTitle, pageNumber) Used to reopen the named PagedWindow or Page . NB. pageNumber must be an integer, starting at 1 for the first page.","title":"Start/Stop Paged Windows"},{"location":"pythonWidgetGrouping/#set-paged-windows","text":".setPagedWindowTitle(title, title) & .setPagedWindowButtons(title, [buttons]) Used to change the text in the title and buttons. When changing the buttons, two values must be passed in: previous/next. .setPagedWindowButtonsTop(title, top=True) Used to position the navigation buttons. By default, they are at the bottom. Call this function to move them to the top. .setPagedWindowPage(title, pageNum) Used to display the selected page. .setPagedWindowFunction(title, function) Declare a function to call, each time the page is changed. .showPagedWindowPageNumber(title, show=True) & .showPagedWindowTitle(title, show=True) Use these to declare if you want the page title, page numbers to be shown.","title":"Set Paged Windows"},{"location":"pythonWidgetGrouping/#get-paged-windows","text":".getPagedWindowPageNumber(title) Used to get the page number currently being shown.","title":"Get Paged Windows"},{"location":"pythonWidgetGrouping/#sub-window","text":"A way to add additional windows, which can be hidden and shown. This has been moved to its own page: Multiple Windows .","title":"Sub Window"},{"location":"pythonWidgetLayout/","text":"Arranging Widgets You can make your GUIs as simple or as complicated as you want... Sequential Layout By default, each time you add a widget to a GUI, it is simply added on a new row: from appJar import gui def changeLabel(btn): app.setLabel(\"l2\", app.getEntry(\"text\")) app = gui() app.addLabel(\"l1\", \"Simple Demo\") app.addEntry(\"text\") app.addButton(\"OK\", changeLabel) app.addEmptyLabel(\"l2\") app.go() Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Grid Layout If, however, you want a bit more control, then you can treat your GUI like a GRID . Think of it just like a spreadsheet, and position your widgets in whichever cell you want. Each time you add a widget, simply specify the row and column it should appear in (always in that order): from appJar import gui app=gui(\"Grid Demo\", \"300x300\") app.setSticky(\"news\") app.setExpand(\"both\") app.setFont(20) app.addLabel(\"l1\", \"row=0\\ncolumn=0\", 0, 0) app.addLabel(\"l2\", \"row=0\\ncolumn=1\", 0, 1) app.addLabel(\"l3\", \"row=0\\ncolumn=2\", 0, 2) app.addLabel(\"l4\", \"row=1\\ncolumn=0\", 1, 0) app.addLabel(\"l5\", \"row=1\\ncolumn=1\", 1, 1) app.addLabel(\"l6\", \"row=1\\ncolumn=2\", 1, 2) app.addLabel(\"l7\", \"row=2\\ncolumn=0\", 2, 0) app.addLabel(\"l8\", \"row=2\\ncolumn=1\", 2, 1) app.addLabel(\"l9\", \"row=2\\ncolumn=2\", 2, 2) app.setLabelBg(\"l1\", \"LightYellow\") app.setLabelBg(\"l2\", \"LemonChiffon\") app.setLabelBg(\"l3\", \"LightGoldenRodYellow\") app.setLabelBg(\"l4\", \"PapayaWhip\") app.setLabelBg(\"l5\", \"Moccasin\") app.setLabelBg(\"l6\", \"PeachPuff\") app.setLabelBg(\"l7\", \"PaleGoldenRod\") app.setLabelBg(\"l8\", \"Khaki\") app.setLabelBg(\"l9\", \"DarkKhaki\") app.go() If you're still not satisfied, you can configure widgets to span across multiple columns or rows. Simply provide a third & fourth parameter to specify how many rows and columns to span: from appJar import gui app=gui(\"Grid Demo\", \"300x300\") app.setSticky(\"news\") app.setExpand(\"both\") app.setFont(14) app.addLabel(\"l1\", \"row=0\\ncolumn=0\") app.addLabel(\"l2\", \"row=0\\ncolumn=1\\ncolspan=2\", 0, 1, 2) app.addLabel(\"l4\", \"row=1\\ncolumn=0\\ncolspan=2\", 1, 0, 2) app.addLabel(\"l6\", \"row=1\\ncolumn=2\\ncolspan=1\\nrowspan=2\", 1, 2, 1, 2) app.addLabel(\"l7\", \"row=2\\ncolumn=0\", 2) app.addLabel(\"l8\", \"row=2\\ncolumn=1\", 2, 1) app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"blue\") app.setLabelBg(\"l4\", \"green\") app.setLabelBg(\"l6\", \"orange\") app.setLabelBg(\"l7\", \"yellow\") app.go() Note, the parameters are read from left to right, so: If you're specifying a column, you must first specify a row If you're specifying a row-span, you must first specify both the row & column And, if you're specifying a column-span, you must first specify a row, column & column-span Layout Tricks There are a few tricks you can employ, to make life a bit easier... Named Arguments It can be annoying having to specify all of the positional parameters each time, so why not take advantage of Python's support for Named Arguments . These allow you to set specific parameters, using their name. For example: app.addLabel(\"l1\", \"text here\", colspan=2) , will set the colspan parameter, without having to set the preceding ones. Row Helpers appJar tracks the next available row.: .getRow() or .gr() Returns the next free row. Useful if you're mainly adding things sequentially, but want to modify one line out of sequence. from appJar import gui colours=[\"red\",\"blue\"] app=gui() for loop in range(3): app.addLabel(loop, \"New Row\", colspan=2) app.setLabelBg(loop, colours[loop%2]) row = app.getRow() # get current row app.addLabel(\"a\", \"LEFT\", row, 0) app.addLabel(\"b\", \"RIGHT\", row, 1) app.setLabelBg(\"a\", \"green\") app.setLabelBg(\"b\", \"orange\") for loop in range(3, 6): app.addLabel(loop, \"New Row\", colspan=2) app.setLabelBg(loop, colours[loop%2]) app.go() Instead of calling .getRow() , you can specify the string \"previous\" or \"p\" to use the the previous row: from appJar import gui with gui(\"LABS\", \"400x400\", sticky=\"news\") as app: app.label(\"0-0\", bg=\"red\") app.label(\"0-1\", bg=\"orange\", row=\"previous\", column=1) app.label(\"0-2\", bg=\"yellow\", row=\"previous\", column=2) app.label(\"1-0\", bg=\"green\") app.label(\"1-1-2\", bg=\"blue\", row=\"previous\", column=1, colspan=2) Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Widget Positioning Once you've laid out your widgets, the next most important thing is how they fill the space in their rows and columns. NB. These settings only take affect from the point at which they are set, so: If you want them to affect the whole GUI, set them at the start. If you want different settings for different groups of widgets, you'll need to set them before each group. If you want different settigs for every widget, you'll need to set them before every widget! There are two settings you can configure: How columns and rows stretch to fill the GUI - stretchiness How widgets stretch to fill their cells - stickiness Setting Stretchiness .setStretch(sides) This tells rows & columns how to stretch to fill the GUI, especially when the GUI is resized. It allows them to adjust to fill the available space: none - don't stretch row - only rows will stretch (down the GUI) column - only columns will stretch (across the GUI) both - rows & columns will stretch across and and down By default: Columns stretch to fill the width of the GUI Rows don't, they take up the minimum space required It's possible to tell the rows to stretch too: app.setStretch(\"both\") But, as you can see below - this doesn't make any difference (yet). Even though the rows have stretched down the GUI to fill the space, the widgets inside them aren't sticking to all sides. Setting Stickiness .setSticky(sides) This determines which sides of a grid-cell a widget will stick to. It should be a string, made up of any combination of n , e , s or w By default, most widgets use 'ew' - the stick to the sides, but not the top/bottom. Even if the cells in the columns & rows are stretching (see above), the widgets inside them might not. Widgets have a stickiness which tells them which sides of their cells to stick to. By default, widgets are configured to stick to the left & right sides ( ew ), but not the top & bottom ( ns ). To change this, you need to set a new stickiness: app.setStretch(\"both\") app.setSticky(\"nesw\") If you remove all stickiness: app.setStretch(\"both\") app.setSticky(\"\") You end up with: And, remember, it's possible to give each widget its own stickiness : from appJar import gui app=gui() app.setBg(\"blue\") app.setStretch(\"both\") app.setSticky(\"nw\") #top-right app.addLabel(\"l1\", \"One\", 0, 0) app.setLabelBg(\"l1\", \"yellow\") app.setSticky(\"ne\") #top-left app.addLabel(\"l2\", \"Two\", 0, 1) app.setLabelBg(\"l2\", \"green\") app.setSticky(\"sw\") #bottom-left app.addLabel(\"l3\", \"Three\", 1, 0) app.setLabelBg(\"l3\", \"pink\") app.setSticky(\"se\") # bottom-right app.addLabel(\"l4\", \"Four\", 1, 1) app.setLabelBg(\"l4\", \"Orange\") app.go() NB There is a function to modify an individual widget's stickiness Examples You may want two widgets - one filling most of the GUI space, and a second one at the bottom, taking up minimal space: from appJar import gui with gui('Demo', '200x200') as app: app.setStretch('both') app.setSticky('news') app.addLabel('top', 'The big part') app.setLabelBg('top', 'red') app.setStretch('column') app.setSticky('esw') app.addLabel('bottom', 'The little part') NB. This can be achieved in much less code, using the new 1.0 syntax: from appJar import gui # set stretch & sticky for the whole GUI with gui('Demo', '200x200', stretch='both', sticky='news') as app: app.label('The big part', bg='red') # change stretch & sticky from this widget on app.label('The little part', stretch='column', sticky='esw') Widget Padding It's possible to configure how much empty space is around a widget. This is known as padding. You can put padding both inside and outside a widget... app.setPadding([20,20]) # 20 pixels padding outside the widget [X, Y] app.setInPadding([20,20]) # 20 pixels padding inside the widget [X, Y] Set Padding & InPadding .setPadding([x,y]) This sets the X & Y padding outside a widget. .setInPadding([x,y]) This sets the X & Y padding inside a widget. app.setPadding([20,20]) # padding outside the widget app.setInPadding([40,20]) # padding inside the widget","title":"Layout"},{"location":"pythonWidgetLayout/#arranging-widgets","text":"You can make your GUIs as simple or as complicated as you want...","title":"Arranging Widgets"},{"location":"pythonWidgetLayout/#sequential-layout","text":"By default, each time you add a widget to a GUI, it is simply added on a new row: from appJar import gui def changeLabel(btn): app.setLabel(\"l2\", app.getEntry(\"text\")) app = gui() app.addLabel(\"l1\", \"Simple Demo\") app.addEntry(\"text\") app.addButton(\"OK\", changeLabel) app.addEmptyLabel(\"l2\") app.go() Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Sequential Layout"},{"location":"pythonWidgetLayout/#grid-layout","text":"If, however, you want a bit more control, then you can treat your GUI like a GRID . Think of it just like a spreadsheet, and position your widgets in whichever cell you want. Each time you add a widget, simply specify the row and column it should appear in (always in that order): from appJar import gui app=gui(\"Grid Demo\", \"300x300\") app.setSticky(\"news\") app.setExpand(\"both\") app.setFont(20) app.addLabel(\"l1\", \"row=0\\ncolumn=0\", 0, 0) app.addLabel(\"l2\", \"row=0\\ncolumn=1\", 0, 1) app.addLabel(\"l3\", \"row=0\\ncolumn=2\", 0, 2) app.addLabel(\"l4\", \"row=1\\ncolumn=0\", 1, 0) app.addLabel(\"l5\", \"row=1\\ncolumn=1\", 1, 1) app.addLabel(\"l6\", \"row=1\\ncolumn=2\", 1, 2) app.addLabel(\"l7\", \"row=2\\ncolumn=0\", 2, 0) app.addLabel(\"l8\", \"row=2\\ncolumn=1\", 2, 1) app.addLabel(\"l9\", \"row=2\\ncolumn=2\", 2, 2) app.setLabelBg(\"l1\", \"LightYellow\") app.setLabelBg(\"l2\", \"LemonChiffon\") app.setLabelBg(\"l3\", \"LightGoldenRodYellow\") app.setLabelBg(\"l4\", \"PapayaWhip\") app.setLabelBg(\"l5\", \"Moccasin\") app.setLabelBg(\"l6\", \"PeachPuff\") app.setLabelBg(\"l7\", \"PaleGoldenRod\") app.setLabelBg(\"l8\", \"Khaki\") app.setLabelBg(\"l9\", \"DarkKhaki\") app.go() If you're still not satisfied, you can configure widgets to span across multiple columns or rows. Simply provide a third & fourth parameter to specify how many rows and columns to span: from appJar import gui app=gui(\"Grid Demo\", \"300x300\") app.setSticky(\"news\") app.setExpand(\"both\") app.setFont(14) app.addLabel(\"l1\", \"row=0\\ncolumn=0\") app.addLabel(\"l2\", \"row=0\\ncolumn=1\\ncolspan=2\", 0, 1, 2) app.addLabel(\"l4\", \"row=1\\ncolumn=0\\ncolspan=2\", 1, 0, 2) app.addLabel(\"l6\", \"row=1\\ncolumn=2\\ncolspan=1\\nrowspan=2\", 1, 2, 1, 2) app.addLabel(\"l7\", \"row=2\\ncolumn=0\", 2) app.addLabel(\"l8\", \"row=2\\ncolumn=1\", 2, 1) app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"blue\") app.setLabelBg(\"l4\", \"green\") app.setLabelBg(\"l6\", \"orange\") app.setLabelBg(\"l7\", \"yellow\") app.go() Note, the parameters are read from left to right, so: If you're specifying a column, you must first specify a row If you're specifying a row-span, you must first specify both the row & column And, if you're specifying a column-span, you must first specify a row, column & column-span","title":"Grid Layout"},{"location":"pythonWidgetLayout/#layout-tricks","text":"There are a few tricks you can employ, to make life a bit easier...","title":"Layout Tricks"},{"location":"pythonWidgetLayout/#named-arguments","text":"It can be annoying having to specify all of the positional parameters each time, so why not take advantage of Python's support for Named Arguments . These allow you to set specific parameters, using their name. For example: app.addLabel(\"l1\", \"text here\", colspan=2) , will set the colspan parameter, without having to set the preceding ones.","title":"Named Arguments"},{"location":"pythonWidgetLayout/#row-helpers","text":"appJar tracks the next available row.: .getRow() or .gr() Returns the next free row. Useful if you're mainly adding things sequentially, but want to modify one line out of sequence. from appJar import gui colours=[\"red\",\"blue\"] app=gui() for loop in range(3): app.addLabel(loop, \"New Row\", colspan=2) app.setLabelBg(loop, colours[loop%2]) row = app.getRow() # get current row app.addLabel(\"a\", \"LEFT\", row, 0) app.addLabel(\"b\", \"RIGHT\", row, 1) app.setLabelBg(\"a\", \"green\") app.setLabelBg(\"b\", \"orange\") for loop in range(3, 6): app.addLabel(loop, \"New Row\", colspan=2) app.setLabelBg(loop, colours[loop%2]) app.go() Instead of calling .getRow() , you can specify the string \"previous\" or \"p\" to use the the previous row: from appJar import gui with gui(\"LABS\", \"400x400\", sticky=\"news\") as app: app.label(\"0-0\", bg=\"red\") app.label(\"0-1\", bg=\"orange\", row=\"previous\", column=1) app.label(\"0-2\", bg=\"yellow\", row=\"previous\", column=2) app.label(\"1-0\", bg=\"green\") app.label(\"1-1-2\", bg=\"blue\", row=\"previous\", column=1, colspan=2) Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Row Helpers"},{"location":"pythonWidgetLayout/#widget-positioning","text":"Once you've laid out your widgets, the next most important thing is how they fill the space in their rows and columns. NB. These settings only take affect from the point at which they are set, so: If you want them to affect the whole GUI, set them at the start. If you want different settings for different groups of widgets, you'll need to set them before each group. If you want different settigs for every widget, you'll need to set them before every widget! There are two settings you can configure: How columns and rows stretch to fill the GUI - stretchiness How widgets stretch to fill their cells - stickiness","title":"Widget Positioning"},{"location":"pythonWidgetLayout/#setting-stretchiness","text":".setStretch(sides) This tells rows & columns how to stretch to fill the GUI, especially when the GUI is resized. It allows them to adjust to fill the available space: none - don't stretch row - only rows will stretch (down the GUI) column - only columns will stretch (across the GUI) both - rows & columns will stretch across and and down By default: Columns stretch to fill the width of the GUI Rows don't, they take up the minimum space required It's possible to tell the rows to stretch too: app.setStretch(\"both\") But, as you can see below - this doesn't make any difference (yet). Even though the rows have stretched down the GUI to fill the space, the widgets inside them aren't sticking to all sides.","title":"Setting Stretchiness"},{"location":"pythonWidgetLayout/#setting-stickiness","text":".setSticky(sides) This determines which sides of a grid-cell a widget will stick to. It should be a string, made up of any combination of n , e , s or w By default, most widgets use 'ew' - the stick to the sides, but not the top/bottom. Even if the cells in the columns & rows are stretching (see above), the widgets inside them might not. Widgets have a stickiness which tells them which sides of their cells to stick to. By default, widgets are configured to stick to the left & right sides ( ew ), but not the top & bottom ( ns ). To change this, you need to set a new stickiness: app.setStretch(\"both\") app.setSticky(\"nesw\") If you remove all stickiness: app.setStretch(\"both\") app.setSticky(\"\") You end up with: And, remember, it's possible to give each widget its own stickiness : from appJar import gui app=gui() app.setBg(\"blue\") app.setStretch(\"both\") app.setSticky(\"nw\") #top-right app.addLabel(\"l1\", \"One\", 0, 0) app.setLabelBg(\"l1\", \"yellow\") app.setSticky(\"ne\") #top-left app.addLabel(\"l2\", \"Two\", 0, 1) app.setLabelBg(\"l2\", \"green\") app.setSticky(\"sw\") #bottom-left app.addLabel(\"l3\", \"Three\", 1, 0) app.setLabelBg(\"l3\", \"pink\") app.setSticky(\"se\") # bottom-right app.addLabel(\"l4\", \"Four\", 1, 1) app.setLabelBg(\"l4\", \"Orange\") app.go() NB There is a function to modify an individual widget's stickiness","title":"Setting Stickiness"},{"location":"pythonWidgetLayout/#examples","text":"You may want two widgets - one filling most of the GUI space, and a second one at the bottom, taking up minimal space: from appJar import gui with gui('Demo', '200x200') as app: app.setStretch('both') app.setSticky('news') app.addLabel('top', 'The big part') app.setLabelBg('top', 'red') app.setStretch('column') app.setSticky('esw') app.addLabel('bottom', 'The little part') NB. This can be achieved in much less code, using the new 1.0 syntax: from appJar import gui # set stretch & sticky for the whole GUI with gui('Demo', '200x200', stretch='both', sticky='news') as app: app.label('The big part', bg='red') # change stretch & sticky from this widget on app.label('The little part', stretch='column', sticky='esw')","title":"Examples"},{"location":"pythonWidgetLayout/#widget-padding","text":"It's possible to configure how much empty space is around a widget. This is known as padding. You can put padding both inside and outside a widget... app.setPadding([20,20]) # 20 pixels padding outside the widget [X, Y] app.setInPadding([20,20]) # 20 pixels padding inside the widget [X, Y]","title":"Widget Padding"},{"location":"pythonWidgetLayout/#set-padding-inpadding","text":".setPadding([x,y]) This sets the X & Y padding outside a widget. .setInPadding([x,y]) This sets the X & Y padding inside a widget. app.setPadding([20,20]) # padding outside the widget app.setInPadding([40,20]) # padding inside the widget","title":"Set Padding &amp; InPadding"},{"location":"pythonWidgetOptions/","text":"Changing Widgets There are a lot of things that can be changed in a widget. There is a pattern to how this works, you simply specify the widget type and the parameter, eg: .setLabelBg(name, value) .setButtonFg(name, value) .setListBoxState(name, value) This should work for most widgets & containers. Some widgets have different types, eg. TextArea & ScrolledTextArea, all types can be configured with the main widget name. Basic Looks The following options are available for all widgets: .set XXX Fg(name, value) Sets the foreground colour (usually the text) of the named widget. .set XXX Bg(name, value) Sets the background colour of the named widget. .set XXX DisabledFg(name, value) Sets the disabled foreground colour (usually the text) of the named widget. .set XXX DisabledBg(name, value) Sets the disabled background colour of the named widget. .set XXX ActiveFg(name, value) Sets the active foreground colour (usually the text) of the named widget. .set XXX ActiveBg(name, value) Sets the active background colour of the named widget. .set XXX Width(name, value) Sets the width of the named widget. .set XXX Height(name, value) Set the height of the named widget. .set XXX Relief(name, value) Sets the border of the named widget. One of: \"sunken\" , \"raised\" , \"groove\" , \"ridge\" , \"flat\" .set XXX State(name, value) Sets the state of the named widget. One of: \"normal\" , \"active\" , \"disabled\" It's possible to change global GUI settings , such as the background and font. If you need to modify individual settings of a widget, you can access it directly, and use the traditional tKinter methods. To change the font for a specific widget, try the following: app.addLabel(\"l1\", \"Times\") app.addLabel(\"l2\", \"Comic Sans\") app.addLabel(\"l3\", \"Helvetica\") app.addLabel(\"l4\", \"Sans Serif\") app.addLabel(\"l5\", \"Verdana\") app.addLabel(\"l6\", \"Courier\") app.getLabelWidget(\"l1\").config(font=\"Times 20 italic underline\") app.getLabelWidget(\"l2\").config(font=(\"Comic Sans\", \"20\", \"normal\")) app.getLabelWidget(\"l3\").config(font=\"Helvetica 20 underline\") app.getLabelWidget(\"l4\").config(font=(\"Sans Serif\", \"20\", \"bold\")) app.getLabelWidget(\"l5\").config(font=\"Verdana 20 overstrike\") app.getLabelWidget(\"l6\").config(font=\"Courier 20\") Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Advanced Looks The following are supported by most widgets: .set XXX Align(name, value) Specifies how to align text within the widget: \"left\" , \"right\" , \"center\" Calls justify on the Entry widget, and anchor on all others (converting left/right into e/w) . .set XXX Anchor(name, value) Sets where the text is positioned within the widget. One of: \"center\" , \"n\" , \"s\" , \"e\" , \"w\" , \"ne\" , \"nw\" , \"se\" , \"sw\" .set XXX Sticky(name, value) Specifies which side of the cell to stick the widget to, as the GUI expands: \"left\" , \"right\" , \"both\" .set XXX Padding(name, [x, y]) Set external padding of the named widget. .set XXX InPadding(name, [x, y]) Set internal padding of the named widget. Fancy Options .set XXX Tooltip(name, value) Sets a tooltip for the named widget, with the specified value. The specified value will be displayed in a small pop-up, when the mouse is left over the widget. If called a second time, it will update the text of the tooltip. See Tooltips for more info. .enable XXX Tooltip(name) & .disable XXX Tooltip(name) These will enable or disable the named tooltip. When disabled, it will not show-up. .set XXX Cursor(name, value) Sets the cursor shown, when the mouse goes over this widget. There are lots of cursors available, for different platforms, see here .set XXX RightClickMenu(name, menu) Links the right-click menu to the specified widget. Make sure you have created a right-click menu first, .createRightClickMenu(menu) and added some menu-items to it. See Menubars for more info. .set XXX Focus(name) Gives focus to the specified widget. This is the widget where the user will be able to start typing. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Widget Manipulation The following allow widgets to be manipulated on screen: .disable XXX (name) Disable the widget - stops the user from interacting with it, but keeps it visible. .enable XXX (name) Enable a disabled widget. .hide XXX (name) Temporarily hides the widget from view. .show XXX (name) Show the widget, if it was already hidden. .move XXX (name, row, column=0, colspan=0, rowspan=0, sticky='EW') Move a widget to a new grid position. If called while inside a different container, the widget will be cloned into that container. NB. Cloning widgtes is very rudimentary, it won't work for compound widgets. .empty XXX(name) Will destroy all widgets in the named container. .emptyCurrentContainer() Will destroy all widgets in the current container. .remove XXX (name) Permanently remove the widget (deletes it). .removeAllWidgets() Permanently remove all widgets. Grouped Options The following are convenience functions, for modifying a group of widgets: .set XXX Widths(names, val) & .set XXX Heights(names, val) Sets the widths/heights of the specified widgets. .setAll XXX Widths(val) & .setAll XXX Heights(val) Sets the widths/heights of all widgets of the specified type. tkinter Options It's also possible to request a widget, and modify it directly: .get XXX Widget(name, value=None) This will get the named widget of the specified type. Any standard tkinter options can then be changed. If it's a RadioButton, you also need to specify a value - the text displayed in the widget.","title":"Configuration"},{"location":"pythonWidgetOptions/#changing-widgets","text":"There are a lot of things that can be changed in a widget. There is a pattern to how this works, you simply specify the widget type and the parameter, eg: .setLabelBg(name, value) .setButtonFg(name, value) .setListBoxState(name, value) This should work for most widgets & containers. Some widgets have different types, eg. TextArea & ScrolledTextArea, all types can be configured with the main widget name.","title":"Changing Widgets"},{"location":"pythonWidgetOptions/#basic-looks","text":"The following options are available for all widgets: .set XXX Fg(name, value) Sets the foreground colour (usually the text) of the named widget. .set XXX Bg(name, value) Sets the background colour of the named widget. .set XXX DisabledFg(name, value) Sets the disabled foreground colour (usually the text) of the named widget. .set XXX DisabledBg(name, value) Sets the disabled background colour of the named widget. .set XXX ActiveFg(name, value) Sets the active foreground colour (usually the text) of the named widget. .set XXX ActiveBg(name, value) Sets the active background colour of the named widget. .set XXX Width(name, value) Sets the width of the named widget. .set XXX Height(name, value) Set the height of the named widget. .set XXX Relief(name, value) Sets the border of the named widget. One of: \"sunken\" , \"raised\" , \"groove\" , \"ridge\" , \"flat\" .set XXX State(name, value) Sets the state of the named widget. One of: \"normal\" , \"active\" , \"disabled\" It's possible to change global GUI settings , such as the background and font. If you need to modify individual settings of a widget, you can access it directly, and use the traditional tKinter methods. To change the font for a specific widget, try the following: app.addLabel(\"l1\", \"Times\") app.addLabel(\"l2\", \"Comic Sans\") app.addLabel(\"l3\", \"Helvetica\") app.addLabel(\"l4\", \"Sans Serif\") app.addLabel(\"l5\", \"Verdana\") app.addLabel(\"l6\", \"Courier\") app.getLabelWidget(\"l1\").config(font=\"Times 20 italic underline\") app.getLabelWidget(\"l2\").config(font=(\"Comic Sans\", \"20\", \"normal\")) app.getLabelWidget(\"l3\").config(font=\"Helvetica 20 underline\") app.getLabelWidget(\"l4\").config(font=(\"Sans Serif\", \"20\", \"bold\")) app.getLabelWidget(\"l5\").config(font=\"Verdana 20 overstrike\") app.getLabelWidget(\"l6\").config(font=\"Courier 20\") Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Basic  Looks"},{"location":"pythonWidgetOptions/#advanced-looks","text":"The following are supported by most widgets: .set XXX Align(name, value) Specifies how to align text within the widget: \"left\" , \"right\" , \"center\" Calls justify on the Entry widget, and anchor on all others (converting left/right into e/w) . .set XXX Anchor(name, value) Sets where the text is positioned within the widget. One of: \"center\" , \"n\" , \"s\" , \"e\" , \"w\" , \"ne\" , \"nw\" , \"se\" , \"sw\" .set XXX Sticky(name, value) Specifies which side of the cell to stick the widget to, as the GUI expands: \"left\" , \"right\" , \"both\" .set XXX Padding(name, [x, y]) Set external padding of the named widget. .set XXX InPadding(name, [x, y]) Set internal padding of the named widget.","title":"Advanced Looks"},{"location":"pythonWidgetOptions/#fancy-options","text":".set XXX Tooltip(name, value) Sets a tooltip for the named widget, with the specified value. The specified value will be displayed in a small pop-up, when the mouse is left over the widget. If called a second time, it will update the text of the tooltip. See Tooltips for more info. .enable XXX Tooltip(name) & .disable XXX Tooltip(name) These will enable or disable the named tooltip. When disabled, it will not show-up. .set XXX Cursor(name, value) Sets the cursor shown, when the mouse goes over this widget. There are lots of cursors available, for different platforms, see here .set XXX RightClickMenu(name, menu) Links the right-click menu to the specified widget. Make sure you have created a right-click menu first, .createRightClickMenu(menu) and added some menu-items to it. See Menubars for more info. .set XXX Focus(name) Gives focus to the specified widget. This is the widget where the user will be able to start typing. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Fancy Options"},{"location":"pythonWidgetOptions/#widget-manipulation","text":"The following allow widgets to be manipulated on screen: .disable XXX (name) Disable the widget - stops the user from interacting with it, but keeps it visible. .enable XXX (name) Enable a disabled widget. .hide XXX (name) Temporarily hides the widget from view. .show XXX (name) Show the widget, if it was already hidden. .move XXX (name, row, column=0, colspan=0, rowspan=0, sticky='EW') Move a widget to a new grid position. If called while inside a different container, the widget will be cloned into that container. NB. Cloning widgtes is very rudimentary, it won't work for compound widgets. .empty XXX(name) Will destroy all widgets in the named container. .emptyCurrentContainer() Will destroy all widgets in the current container. .remove XXX (name) Permanently remove the widget (deletes it). .removeAllWidgets() Permanently remove all widgets.","title":"Widget Manipulation"},{"location":"pythonWidgetOptions/#grouped-options","text":"The following are convenience functions, for modifying a group of widgets: .set XXX Widths(names, val) & .set XXX Heights(names, val) Sets the widths/heights of the specified widgets. .setAll XXX Widths(val) & .setAll XXX Heights(val) Sets the widths/heights of all widgets of the specified type.","title":"Grouped Options"},{"location":"pythonWidgetOptions/#tkinter-options","text":"It's also possible to request a widget, and modify it directly: .get XXX Widget(name, value=None) This will get the named widget of the specified type. Any standard tkinter options can then be changed. If it's a RadioButton, you also need to specify a value - the text displayed in the widget.","title":"tkinter Options"},{"location":"pythonWidgets/","text":"Widgets In a GUI, the fillings are known as widgets . There are lots of different widgets to choose from, each suited to a specific task. Nearly every widget needs a TITLE . This is a unique name for the widget, so that later you can get information from that widget, or change it. Nearly all widgets in appJar provide the same three functions: (Always) - ADD a widget (with a unique title) - this creates the widget (Often) - GET the widget (using its unique title) - this gets the contents of the widget (usually done in a function) (Sometimes) - SET the widget (using its unique title) - this changes what's in the widget On top of these, there is a common set of functions for changing widgets . As well as some specialist functions, unique to each widget (see below). Label Labels are used for displaying text in the GUI. They are great for titles, at the top of the GUI, usually spanning multiple columns. They are really useful before Entries and Drop-downs to explain their purpose. And, they're very helpful at the bottom of the GUI, to show the results of an action. from appJar import gui app = gui() app.addLabel(\"l1\", \"Label 1\") app.addLabel(\"l2\", \"Label 2\") app.addLabel(\"l3\", \"Label 3\") app.addLabel(\"l4\", \"Label 4\") # common set functions app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"yellow\") app.setLabelBg(\"l3\", \"purple\") app.setLabelBg(\"l4\", \"orange\") app.go() Add Labels .addLabel(title, text=None) This will create a label widget to display text in the GUI. The title is used to uniquely identify the label, in case you want to change it later, and the text is what gets displayed. If text is set to None, or no text is provided, the title will be displayed in the label. .addEmptyLabel(title) Does the same as add a label , except there's no parameter to set any text. .addSelectableLabel(title, text=None) This adds a label whose text can be selected with the mouse. This is really just a read-only Entry, disguised to look like a label. But it seems to do the trick... .addFlashLabel(title, text=None) This adds a flashing label , that will alternate between the foreground and background colours. from appJar import gui app = gui() app.addFlashLabel(\"f1\", \"This is flashing\") app.addLabel(\"f2\", \"This is not flashing\") app.addFlashLabel(\"f3\", \"This is also flashing\") app.go() Set Labels .setLabel(title, text) Change the contents of the label . .clearLabel(title) Clear the contents of the label . Get Labels .getLabel(title) Get the contents of the label . Auto-Labelled Widgets It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does. Entry Entries are used to capture input from the user. They take a single parameter - a title. There are five special-case Entries: NumericEntry - this only allows numbers to be typed in - always returns a float (None if empty). SecretEntry - this will show stars, instead of the letters typed - useful for capturing passwords. AutoEntry - this takes a list of words to provide auto-completion. ValidationEntry - can be set to valid/invalid/waiting - will colour the border green/red/black and show a \u2714/\u2716/\u2605 FileEntry/DirectoryEntry - provides a button to select a file/directory and auto-populates the Entry from appJar import gui app=gui() app.addEntry(\"e1\") app.addEntry(\"e2\") app.addEntry(\"e3\") app.addLabelEntry(\"Name\") app.addValidationEntry(\"v1\") app.addFileEntry(\"f1\") app.setEntryDefault(\"e2\", \"Age here\") app.setEntryValid(\"v1\") app.go() Add Entries .addEntry(title) .addNumericEntry(title) .addSecretEntry(title) .addAutoEntry(title, words) .addValidationEntry(title) .addFileEntry(title) .addDirectoryEntry(title) Each of these will add the specified type of Entry, using the title provided. Set Entries .setEntry(title, text, callFunction=True) This sets the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .setEntryDefault(title, text) This sets a default value to display in an Entry. Once the user starts typing, it will disappear. The text is centered, shown in a light gray font, and will not be returned by .getEntry(title) .setEntryUpperCase(title) & .setEntryLowerCase(title) This will force all text typed into the Entry to be uppercase/lowercase. .setEntryMaxLength(title, maxLength) This will set a maximum length for the specified Entry. Any additional characters typed will be discarded. .setEntryValid(title) & .setEntryInvalid(title) & .setEntryWaitingValidation(title) These will set the relevant status of a validation Entry. (Have a look here for help displaying special characters) .setValidationEntry(title, state=\"valid\") Same as above, set flag to one of valid , invalid or wait . .setAutoEntryNumRows(title, rows) This will set the number of rows to display in an AutoEntry. NB. this is limited to the depth of the GUI - if there is no space, then no rows will be displayed. .appendAutoEntry(title, value) This will add the value/list of values to the specified AutoEntry. .removeAutoEntry(title, value) This will remove the value from the specified AutoEntry. .changeAutoEntry(title, value) This will replace all items in the specified AutoEntry with a new list of values. .clearEntry(title, callFunction=True) This will clear the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .clearAllEntries(callFunction=False) This will clear all Entries in the GUI. Set callFunction to be True, if you want to call any associated functions. .setFocus(title) This will put the cursor in the specified Entry, so that the user can start typing without needing to click. Get Entries .getEntry(title) This will return the contents of the specified Entry. NB. numericEntries always return a float. .getAllEntries() This will return the contents of all Entries in the app, as a dictionary. NB. numericEntries always return a float. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Button A clickable button, that will call a function. These are the key to starting an interactive application. The GUI is looping, waiting for something to happen. A button click is the classic way to start interacting with a GUI. Whenever any function is called by the GUI, the title of the widget that called it is passed as a parameter. That way, multiple widgets can use the same function, but different actions can be performed, depending on the name passed as a parameter. from appJar import gui # the title of the button will be received as a parameter def press(btn): print(btn) app=gui() # 3 buttons, each calling the same function app.addButton(\"One\", press) app.addButton(\"Two\", press) app.addButton(\"Three\", press) app.go() Add Buttons .addButton(title, function) Add a single button to the GUI, the text on the button will be the same as the button's title. A function should be specified, which will be called when the button is clicked, where the title is passed as a parameter to the function. Alternatively, the function can have no parameter, and appJar will not supply an argument. .addButtons(titles, functions) It's possible to add a list of buttons to the GUI. Pass a 1-dimensional or 2-dimensional list, and they will be rendered accordingly. A single function can be passed, to use for all buttons. Or a list of functions can be passed, which MUST correspond to the buttons. .addImageButton(title, function, imgFile, align=None) This creates the named button, as above, using the specified image. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addIconButton(title, function, iconName, align=None) This creates the named button, as above, using the specified icon. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addNamedButton(name, title, function) By default, it's not possible to have two buttons with the same text. If that's required, a named button should be used. This allows a name and title to be set for a button. The name will be displayed on the button, and the title passed to the function. Set Buttons .setButton(name, text) This will change the text displayed on a button, but NOT the value passed as a parameter to the function. .setButtonImage(title, image, align=None) This allows an image to be placed on a button, instead of the usual text. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. RadioButton A group of round boxes, only one of which can be selected. These are great for getting a single value, for a multiple choice question. from appJar import gui app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.addRadioButton(\"song\", \"Parklife\") app.go() Add RadioButtons .addRadioButton(title, name) This will create a RadioButton grouped by the specified title. This button will have the value of name. Radio buttons are usually used in groups. Set RadioButtons .setRadioButton(title, value, callFunction=True) This will tick the specified RadioButton. Set callFunction to be False, if you don't want to call any associated functions. .setRadioTick(title, tick=True) It is possible to use tick-boxes instead of the classic circular radio-button. Setting tick to True will convert all the radio-buttons for this title to tick boxes. .clearAllRadioButtons(callFunction=False) This will reset all RadioButtons in the app to their first value. Set callFunction to be True, if you want to call any associated functions. Get RadioButtons .getRadioButton(title) Gets the value of the selected RadioButton, for the specified title. from appJar import gui def press(rb): print(app.getRadioButton(\"song\")) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") # call this function, when the RadioButton changes app.setRadioButtonChangeFunction(\"song\", press) app.addButton(\"PLAY\", press) app.go() .getAllRadioButtons() This will return the contents of all RadioButtons in the app, as a dictionary. CheckBox A simple tick-box, with a label, that can be either ON or OFF. from appJar import gui app=gui() app.setFont(20) app.addCheckBox(\"Apples\") app.addCheckBox(\"Pears\") app.addCheckBox(\"Oranges\") app.addCheckBox(\"Kiwis\") app.setCheckBox(\"Oranges\") app.go() Add CheckBoxes .addCheckBox(title) This creates a CheckBox, with the specified title. .addNamedCheckBox(name, title) By default, it's not possible to have two CheckBoxes with the same text. If that's required, a named CheckBox should be used. This creates a CheckBox, with the specified title. The name will be displayed next to the CheckBox, and the title passed to the function as a unique ID. Set CheckBoxes .setCheckBox(title, ticked=True, callFunction=True) This will tick the CheckBox, or untick it if ticked is set to False. Set callFunction to be False, if you don't want to call any associated functions. .clearAllCheckBoxes(callFunction=False) This will clear (untick) all CheckBoxes in the app. Set callFunction to be True, if you want to call any associated functions. Get CheckBoxes .getCheckBox(title) This will return True or False, depending on the state of the CheckBox. .getAllCheckBoxes() This will return the contents of all CheckBoxes in the app, as a dictionary. OptionBox Creates a simple drop-down box. It is only possible to select one option from this drop-down. Pass in a list of values to show in the drop-down box. They will be added in the same order, with the first item shown. If the first item is empty, a simple title - options - will be created. Any other empty items will be removed. If an item starts with a dash (-), it will be treated as a separator, and can't be selected. from appJar import gui app=gui() app.setFont(20) app.addLabelOptionBox(\"Options\", [\"- Fruits -\", \"Apple\", \"Orange\", \"Pear\", \"kiwi\", \"- Pets -\", \"Dogs\", \"Cats\", \"Fish\", \"Hamsters\"]) app.go() Add OptionBoxes .addOptionBox(title, values) This will create an OptionBox, adding the contents of the values list, in the order specified. .addTickOptionBox(title, values) This will create an OptionBox made up of check boxes. The title will always be displayed as the selected entry in the OptionBox, event though it can't be selected/ticked. Instead of selecting a single item, you tick the ones you want. Calling .getOptionBox(title) will return a dictionary of the options along with a True/False value. from appJar import gui def get(btn): print(app.getOptionBox(\"Favourite Pets\")) app=gui() app.setFont(20) app.addTickOptionBox(\"Favourite Pets\", [\"Dogs\", \"Cats\", \"Hamsters\", \"Fish\"]) app.addButton(\"GET\", get) app.go() Set OptionBoxes .changeOptionBox(title, newOptions, index, callFunction=False) This will replace the contents of the OptionBox, with the new list provided. If specified, the indexed item will be selected - this can be a position or an item name. If setting a TickOptionBox, the old list will be replaced with the new list. None will be ticked. index will be ignored. Set callFunction to be True, if you want to call any associated change functions. .setOptionBox(title, position, value=True, callFunction=True, override=False) This will select the item in the list, at the position specified. Alternatively, the name of an item can be specified. If changing a TickOptionBox, the specified item will be set to the specified value. Set callFunction to be False, if you don't want to call any associated functions. By default, you can't select a disabled item. You can change this by setting override to be True. .renameOptionBoxItem(title, item, newName, callFunction=False) This will rename the specified item in the named OptionBox. Set callFunction to be True, if you want to call any associated change functions. .clearOptionBox(title, callFunction=True) This will set the named OptionBox back to its first value (even if it's disabled). Set callFunction to be False, if you don't want to call any associated functions. .clearAllOptionBoxes(callFunction=False) This will set all OptionBoxes in the app back to their first value (even if it's disabled). Set callFunction to be True, if you want to call any associated functions. .deleteOptionBox(title, position) This will delete the item in the list, at the position specified. Alternatively, the name of an item can be specified. Not available on TickOptionBoxes. Get OptionBoxes .getOptionBox(title) This will return the currently displayed value in an OptionBox. Or a dictionary of names, and their boolean value if a TickOptionBox. Will return None, if an invalid option is currently selected. .getAllOptionBoxes() This will return the contents of all OptionBoxes in the app, as a dictionary. SpinBox A scrollable list of options. Up and down buttons are provided to scroll from one item to the next. Unlike the OptionBox, you do not get a drop-down of choices, instead it spins to the next/previous option. from appJar import gui app=gui() app.setFont(20) app.addLabelSpinBox(\"options\", [\"Apple\", \"Orange\", \"Pear\", \"kiwi\"]) app.go() Add SpinBoxes .addSpinBox(title, values) This will create a SpinBox, adding the contents of the values list, in the order specified. .addSpinBoxRange(title, from, to) This will create a SpinBox, with a numeric range of items. from appJar import gui app=gui() app.setFont(20) app.addSpinBoxRange(\"Numbers\", 1, 12) app.go() Set SpinBoxes .setSpinBox(title, value, callFunction=True) This will select the specified value in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .setSpinBoxPos(title, pos, callFunction=True) This will select the value at the specified position in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllSpinBoxes(callFunction=False) This will set all SpinBoxes in the app to their first value. Set callFunction to be True, if you want to call any associated functions. Get SpinBoxes .getSpinBox(title) This will get the selected value from the specified SpinBox. .getAllSpinBoxes() This will return the contents of all SpinBoxes in the app, as a dictionary. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); ListBox A box containing a list of items, single or multi-select from appJar import gui app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.go() Add ListBoxes .addListBox(title, values) Creates a ListBox with the specified values. .addListItem(title, item) Adds a single item to the the end of the ListBox, and selects it. .addListItems(title, items) Adds a list of items to the end of the List Box, selecting the last one. Set ListBoxes .setListItem(title, item, newVal, first=False) .setListItemAtPos(title, pos, newVal) Changes the specified list item to the new value. If first is set to True, only the first item found will be changed. Otherwise, all occurrences of the specified value will be changed. .removeListItem(title, item) .removeListItemAtPos(title, pos) Remove the specified item from the specified ListBox. Will only remove the first item that matches the parameter. .clearListBox(title, callFunction=True) Removes all items from the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllListBoxes(callFunction=False) This will remove all items from all ListBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .updateListBox(title, items, select=False) Replace the contents of the specified ListBox with the new values. If you set select to be True, the last item in the list will be selected. from appJar import gui def press(btn): items = app.getListItems(\"list\") if len(items)> 0: app.removeListItem(\"list\", items[0]) app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.addButton(\"press\", press) app.go() .selectListItem(title, item, callFunction=True) .selectListItemAtPos(title, pos, callFunction=False) Selects the specified item in the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .setListBoxRows(title, rows) Sets how many rows to display in the specified ListBox. .setListBoxMulti(list, multi=True) Configures whether the specified ListBox is single or multi select. .setListBoxGroup(list, group=True) Adds the named ListBox to a group of selectable ListBoxes. All ListBoxes in the group can have items selected at the same time. .setListItemBg(title, item, colour) & .setListItemFg(title, item, colour) .setListItemAtPosBg(title, item, colour) & .setListItemAtPosFg(title, item, colour) Sets the background or foreground colours the specified ListBox item. Can either specify a named item (will update all with that name) or the position of an item. Get ListBoxes .getListBox(title) Gets all of the selected items from the specified ListBox. .getAllListBoxes() This will return the contents of all ListBoxes in the app, as a dictionary. .getAllListItems(title) Gets all of the items from the specified ListBox. Scale A slider, that has a minimum & maximum value. from appJar import gui app=gui() app.setFont(20) app.addLabelScale(\"scale\") app.go() Add Scales .addScale(title) Adds a horizontal scale, with a default range between 0 and 100. Set Scales .setScale(title, pos, callFunction=True) Sets the selected pos for the specified Scale. Set callFunction to be False, if you don't want to call any associated functions. .setScaleRange(title from, to, curr=None) Allows you to change the range available in the Scale. If curr is provided, then the Scale will be set to that value. .setScaleIncrement(title, increment) Configures how much the scale jumps, when the trough is clicked. It defaults to 10%. .showScaleIntervals(title, intervals) Configures the Scale to show interval labels along its length. intervals should be how often to show a value, eg. 25 would show 0, 25, 50, and so on... .showScaleValue(title, show=True) Configures the Scale to show the currently selected value. .setScaleHorizontal(title) & .setScaleVertical(title) Changes the Scale's orientation to the specified value. .setScaleWidth(title, width) & .setScaleLength(title, length) Sets a width/length for the scale's slider. .setScaleChangeFunction(title, func) Sets a function to call, each time the scale is changed. The function must take one parameter, which will be populated with the scale's title. .clearAllScales(callFunction=False) This will set all Scales in the app to their minimum value. Set callFunction to be True, if you want to call any associated functions. Get Scales .getScale(title) Gets the currently selected value from the scale. .getAllScales() This will return the contents of all Scales in the app, as a dictionary. Message Similar to a Label, except it will wrap the text over multiple lines. from appJar import gui app=gui() app.setFont(12) app.addMessage(\"mess\", \"\"\"You can put a lot of text in this widget. The text will be wrapped over multiple lines. It's not possible to apply different styles to different words.\"\"\") app.go() Add Messages .addMessage(title, text) Adds a Message widget, with the specified text. If not text is provided, the title will be used for the text. .addEmptyMessage(title) Adds an empty Message widget. Set Messages .clearMessage(title) Clears the specified Message widget. .setMessage(title, text) Sets the contents of the specified Message widget, to the specified text. TextArea Similar to an Entry, but allows you to type text over multiple lines. from appJar import gui app=gui() app.addTextArea(\"t1\") app.go() Add TextAreas .addTextArea(title) Adds an empty TextArea, with the specified title. .addScrolledTextArea(title) Adds a scrollable TextArea with the specified title. Set TextAreas .setTextArea(title, text, end=True, callFunction=True) Adds the supplied text to the specified TextArea. By default, the text is added to the end. Set end to be False if you want to add at the beginning. Set callFunction to be False, if you don't want to call any associated functions. .clearTextArea(title, callFunction=True) Clears the contents of the specified TextArea. Set callFunction to be False, if you don't want to call any associated functions. .clearAllTextAreas(callFunction=False) This will clear the contents of all TextAreas in the app. Set callFunction to be True, if you want to call any associated functions. Get TextAreas .getTextArea(title) Gets the contents of the specified TextArea. .getAllTextAreas() This will return the contents of all TextAreas in the app, as a dictionary. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({}); Meter Various styles of progress meter: Meter A simple meter for showing progress from 0% to 100%. SplitMeter A possession style meter, showing percentages on either side. DualMeter Two separate meters, expanding out from the middle. from appJar import gui app=gui() app.addMeter(\"progress\") app.setMeterFill(\"progress\", \"blue\") app.go() Add Meters .addMeter(name) & .addSplitMeter(name) & .addDualMeter(name) Adds a meter with the specified name, of the specified type. Set Meters .setMeter(name, value, text=None) Changes the specified meter to the specified value. For Meter & SplitMeter should be a value between 0 and 100. For DualMeter should be a list of two values, each between 0 and 100. .setMeterFill(name, colour) Changes the fill colour of the specified meter. For SplitMeter & DualMeter should be a list of two colours. Get Meters .getMeter(name) Gets the value of the specified meter. As meters convert their data to a value between 0 and 1, this will return a list of two values: (0.45, '45 %') .getAllMeters() This will return the contents of all Meters in the app, as a dictionary. Background Processing Meters are designed to show progress over time. One common solution is to register a function that is constantly updating a meter. This should then be monitoring/updating a global variable: def updateMeter(): app.setMeter(\"progress\", percentComplete) # schedule function to be called regularly app.registerEvent(updateMeter) Properties A compound widget that shows multiple CheckButtons linked to a dictionary. Note, dictionaries have no order, so when added as a dictionary, the items will be automatically sorted. from appJar import gui toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.addProperties(\"Toppings\", toppings) app.setProperty(\"Toppings\", \"Pepper\") app.go() Add Properties .addProperties(title, values) Creates a new Properties widget, with the specified title. If values is populated, then the dictionary items will be added to the widget. Set Properties .setPropertyText(title, prop, newText=None) Change the displayed text for the named property. If no value is provided, the original value will be used. .setProperties(title, props, callFunction=True) Adds the dictionary of properties to the widget. If any of them already exist, they will be updated. Set callFunction to be False, if you don't want to call any associated functions. .setProperty(title, prop, value=False, callFunction=True) Sets the named property to the specified value. If it doesn't exist, it will be added first, at the end of the widget. Set callFunction to be False, if you don't want to call any associated functions. .deleteProperty(title, prop) Deletes the named property from the widget. .resetProperties(title, callFunction=True) This will reset the specified Properties back to its original values. Set callFunction to be False, if you don't want to call any associated functions. .clearProperties(title, callFunction=True) This will set all values in the specified Properties to False. Set callFunction to be False, if you don't want to call any associated functions. .resetAllProperties(callFunction=False) This will reset all Properties in the app back to their original values. Set callFunction to be True, if you want to call any associated functions. .clearAllProperties(callFunction=False) This will set all values in all Properties in the app to False. Set callFunction to be True, if you want to call any associated functions. Get Properties .getProperties(title) Gets a dictionary of the all items in the Properties widget. .getAllProperties() This will return the contents of all Properties in the app, as a dictionary. .getProperty(title, prop) Gets the value of the named property. Examples It's possible to put Properties into ToggleFrames, and also set a Function to listen for any changes. from appJar import gui def changed(props): print(\"Changed\", props) toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.startToggleFrame(\"Toppings\") app.addProperties(\"Toppings\", toppings) app.setPropertiesChangeFunction(\"Toppings\", changed) app.stopToggleFrame() app.go() Separator Useful for indicating separation between widgets. Will draw a horizontal/vertical line spanning the cell. from appJar import gui app=gui() app.setBg(\"lightBlue\") app.addHorizontalSeparator(0,0,4, colour=\"red\") app.addVerticalSeparator(1,0, colour=\"red\") app.addVerticalSeparator(1,1, colour=\"red\") app.addVerticalSeparator(1,2, colour=\"red\") app.addVerticalSeparator(1,3, colour=\"red\") app.addHorizontalSeparator(2,0,4, colour=\"red\") app.go() Add Seperators .addHorizontalSeparator(colour=None) & .addVerticalSeparator(colour=None) Adds a separator (a horizontal or vertical line) spanning the cell. An optional colour can be passed in, to set a colour for the separator. Link/WebLink Clickable text to call a function or launch a URL from appJar import gui def press(link): app.infoBox(\"Info\", \"You clicked the link!\") app=gui() app.setFont(20) app.addLink(\"Click me\", press) app.addWebLink(\"appJar.info\", \"http://appJar.info\") app.go() Add Links .addLink(title, func) Adds a hyperlink , that when clicked, will call the specified function. .addWebLink(title, page) Adds a hyperlink , that when clicked, will launch the default browser, and load the specified page. It must be a fully formed link, including http:// Grip Clickable icon to drag the window around. from appJar import gui app=gui() app.setFont(20) app.setBg(\"lightBlue\") app.addLabel(\"l1\", \"Move me around...\", 0, 0) app.addGrip(0,1) app.addSeparator(1,0,2, colour=\"red\") app.go() Add Grips .addGrip() Adds a simple grip icon. The mouse pointer changes over the grip, and a ToolTip will be shown. The size and image can't be changed. DatePicker A widget to capture a date - will handle presenting accurate drop-downs, and return a date. from appJar import gui def showDate(btn): print(app.getDatePicker(\"dp\")) app=gui() app.addDatePicker(\"dp\") app.addButton(\"GET\", showDate) app.setDatePickerRange(\"dp\", 1900, 2100) app.setDatePicker(\"dp\") app.go() Add DatePickers .addDatePicker(title) Create a DatePicker, with a range from 1/1/1970 to 31/12/2020 Set DatePickers .setDatePicker(title, date=None) Will set the specified DatePicker to the specified date, or current date if no date is supplied. .setDatePickerRange(title, startYear, endYear=None) Set the range for the named DatePicker. If endYear is None, the current Year will be used. .setDatePickerChangeFunction(title, function) Set a function to call when the DatePicker is changed. .clearDatePicker(title, callFunction=True) This will reset the specified DatePicker to the earliest available date. Set callFunction to be False, if you don't want to call any associated functions. .clearAllDatePickers(callFunction=False) This will reset all DatePickers in the app to their earliest available date. Set callFunction to be True, if you want to call any associated functions. Get DatePickers .getDatePicker(title) Will return the currently selected date. .getAllDatePickers() This will return the contents of all DatePickers in the app, as a dictionary.","title":"pythonWidgets"},{"location":"pythonWidgets/#widgets","text":"In a GUI, the fillings are known as widgets . There are lots of different widgets to choose from, each suited to a specific task. Nearly every widget needs a TITLE . This is a unique name for the widget, so that later you can get information from that widget, or change it. Nearly all widgets in appJar provide the same three functions: (Always) - ADD a widget (with a unique title) - this creates the widget (Often) - GET the widget (using its unique title) - this gets the contents of the widget (usually done in a function) (Sometimes) - SET the widget (using its unique title) - this changes what's in the widget On top of these, there is a common set of functions for changing widgets . As well as some specialist functions, unique to each widget (see below).","title":"Widgets"},{"location":"pythonWidgets/#label","text":"Labels are used for displaying text in the GUI. They are great for titles, at the top of the GUI, usually spanning multiple columns. They are really useful before Entries and Drop-downs to explain their purpose. And, they're very helpful at the bottom of the GUI, to show the results of an action. from appJar import gui app = gui() app.addLabel(\"l1\", \"Label 1\") app.addLabel(\"l2\", \"Label 2\") app.addLabel(\"l3\", \"Label 3\") app.addLabel(\"l4\", \"Label 4\") # common set functions app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"yellow\") app.setLabelBg(\"l3\", \"purple\") app.setLabelBg(\"l4\", \"orange\") app.go()","title":"Label"},{"location":"pythonWidgets/#add-labels","text":".addLabel(title, text=None) This will create a label widget to display text in the GUI. The title is used to uniquely identify the label, in case you want to change it later, and the text is what gets displayed. If text is set to None, or no text is provided, the title will be displayed in the label. .addEmptyLabel(title) Does the same as add a label , except there's no parameter to set any text. .addSelectableLabel(title, text=None) This adds a label whose text can be selected with the mouse. This is really just a read-only Entry, disguised to look like a label. But it seems to do the trick... .addFlashLabel(title, text=None) This adds a flashing label , that will alternate between the foreground and background colours. from appJar import gui app = gui() app.addFlashLabel(\"f1\", \"This is flashing\") app.addLabel(\"f2\", \"This is not flashing\") app.addFlashLabel(\"f3\", \"This is also flashing\") app.go()","title":"Add Labels"},{"location":"pythonWidgets/#set-labels","text":".setLabel(title, text) Change the contents of the label . .clearLabel(title) Clear the contents of the label .","title":"Set Labels"},{"location":"pythonWidgets/#get-labels","text":".getLabel(title) Get the contents of the label .","title":"Get Labels"},{"location":"pythonWidgets/#auto-labelled-widgets","text":"It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does.","title":"Auto-Labelled Widgets"},{"location":"pythonWidgets/#entry","text":"Entries are used to capture input from the user. They take a single parameter - a title. There are five special-case Entries: NumericEntry - this only allows numbers to be typed in - always returns a float (None if empty). SecretEntry - this will show stars, instead of the letters typed - useful for capturing passwords. AutoEntry - this takes a list of words to provide auto-completion. ValidationEntry - can be set to valid/invalid/waiting - will colour the border green/red/black and show a \u2714/\u2716/\u2605 FileEntry/DirectoryEntry - provides a button to select a file/directory and auto-populates the Entry from appJar import gui app=gui() app.addEntry(\"e1\") app.addEntry(\"e2\") app.addEntry(\"e3\") app.addLabelEntry(\"Name\") app.addValidationEntry(\"v1\") app.addFileEntry(\"f1\") app.setEntryDefault(\"e2\", \"Age here\") app.setEntryValid(\"v1\") app.go()","title":"Entry"},{"location":"pythonWidgets/#add-entries","text":".addEntry(title) .addNumericEntry(title) .addSecretEntry(title) .addAutoEntry(title, words) .addValidationEntry(title) .addFileEntry(title) .addDirectoryEntry(title) Each of these will add the specified type of Entry, using the title provided.","title":"Add Entries"},{"location":"pythonWidgets/#set-entries","text":".setEntry(title, text, callFunction=True) This sets the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .setEntryDefault(title, text) This sets a default value to display in an Entry. Once the user starts typing, it will disappear. The text is centered, shown in a light gray font, and will not be returned by .getEntry(title) .setEntryUpperCase(title) & .setEntryLowerCase(title) This will force all text typed into the Entry to be uppercase/lowercase. .setEntryMaxLength(title, maxLength) This will set a maximum length for the specified Entry. Any additional characters typed will be discarded. .setEntryValid(title) & .setEntryInvalid(title) & .setEntryWaitingValidation(title) These will set the relevant status of a validation Entry. (Have a look here for help displaying special characters) .setValidationEntry(title, state=\"valid\") Same as above, set flag to one of valid , invalid or wait . .setAutoEntryNumRows(title, rows) This will set the number of rows to display in an AutoEntry. NB. this is limited to the depth of the GUI - if there is no space, then no rows will be displayed. .appendAutoEntry(title, value) This will add the value/list of values to the specified AutoEntry. .removeAutoEntry(title, value) This will remove the value from the specified AutoEntry. .changeAutoEntry(title, value) This will replace all items in the specified AutoEntry with a new list of values. .clearEntry(title, callFunction=True) This will clear the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .clearAllEntries(callFunction=False) This will clear all Entries in the GUI. Set callFunction to be True, if you want to call any associated functions. .setFocus(title) This will put the cursor in the specified Entry, so that the user can start typing without needing to click.","title":"Set Entries"},{"location":"pythonWidgets/#get-entries","text":".getEntry(title) This will return the contents of the specified Entry. NB. numericEntries always return a float. .getAllEntries() This will return the contents of all Entries in the app, as a dictionary. NB. numericEntries always return a float. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Get Entries"},{"location":"pythonWidgets/#button","text":"A clickable button, that will call a function. These are the key to starting an interactive application. The GUI is looping, waiting for something to happen. A button click is the classic way to start interacting with a GUI. Whenever any function is called by the GUI, the title of the widget that called it is passed as a parameter. That way, multiple widgets can use the same function, but different actions can be performed, depending on the name passed as a parameter. from appJar import gui # the title of the button will be received as a parameter def press(btn): print(btn) app=gui() # 3 buttons, each calling the same function app.addButton(\"One\", press) app.addButton(\"Two\", press) app.addButton(\"Three\", press) app.go()","title":"Button"},{"location":"pythonWidgets/#add-buttons","text":".addButton(title, function) Add a single button to the GUI, the text on the button will be the same as the button's title. A function should be specified, which will be called when the button is clicked, where the title is passed as a parameter to the function. Alternatively, the function can have no parameter, and appJar will not supply an argument. .addButtons(titles, functions) It's possible to add a list of buttons to the GUI. Pass a 1-dimensional or 2-dimensional list, and they will be rendered accordingly. A single function can be passed, to use for all buttons. Or a list of functions can be passed, which MUST correspond to the buttons. .addImageButton(title, function, imgFile, align=None) This creates the named button, as above, using the specified image. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addIconButton(title, function, iconName, align=None) This creates the named button, as above, using the specified icon. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addNamedButton(name, title, function) By default, it's not possible to have two buttons with the same text. If that's required, a named button should be used. This allows a name and title to be set for a button. The name will be displayed on the button, and the title passed to the function.","title":"Add Buttons"},{"location":"pythonWidgets/#set-buttons","text":".setButton(name, text) This will change the text displayed on a button, but NOT the value passed as a parameter to the function. .setButtonImage(title, image, align=None) This allows an image to be placed on a button, instead of the usual text. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text.","title":"Set Buttons"},{"location":"pythonWidgets/#radiobutton","text":"A group of round boxes, only one of which can be selected. These are great for getting a single value, for a multiple choice question. from appJar import gui app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.addRadioButton(\"song\", \"Parklife\") app.go()","title":"RadioButton"},{"location":"pythonWidgets/#add-radiobuttons","text":".addRadioButton(title, name) This will create a RadioButton grouped by the specified title. This button will have the value of name. Radio buttons are usually used in groups.","title":"Add RadioButtons"},{"location":"pythonWidgets/#set-radiobuttons","text":".setRadioButton(title, value, callFunction=True) This will tick the specified RadioButton. Set callFunction to be False, if you don't want to call any associated functions. .setRadioTick(title, tick=True) It is possible to use tick-boxes instead of the classic circular radio-button. Setting tick to True will convert all the radio-buttons for this title to tick boxes. .clearAllRadioButtons(callFunction=False) This will reset all RadioButtons in the app to their first value. Set callFunction to be True, if you want to call any associated functions.","title":"Set RadioButtons"},{"location":"pythonWidgets/#get-radiobuttons","text":".getRadioButton(title) Gets the value of the selected RadioButton, for the specified title. from appJar import gui def press(rb): print(app.getRadioButton(\"song\")) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") # call this function, when the RadioButton changes app.setRadioButtonChangeFunction(\"song\", press) app.addButton(\"PLAY\", press) app.go() .getAllRadioButtons() This will return the contents of all RadioButtons in the app, as a dictionary.","title":"Get RadioButtons"},{"location":"pythonWidgets/#checkbox","text":"A simple tick-box, with a label, that can be either ON or OFF. from appJar import gui app=gui() app.setFont(20) app.addCheckBox(\"Apples\") app.addCheckBox(\"Pears\") app.addCheckBox(\"Oranges\") app.addCheckBox(\"Kiwis\") app.setCheckBox(\"Oranges\") app.go()","title":"CheckBox"},{"location":"pythonWidgets/#add-checkboxes","text":".addCheckBox(title) This creates a CheckBox, with the specified title. .addNamedCheckBox(name, title) By default, it's not possible to have two CheckBoxes with the same text. If that's required, a named CheckBox should be used. This creates a CheckBox, with the specified title. The name will be displayed next to the CheckBox, and the title passed to the function as a unique ID.","title":"Add CheckBoxes"},{"location":"pythonWidgets/#set-checkboxes","text":".setCheckBox(title, ticked=True, callFunction=True) This will tick the CheckBox, or untick it if ticked is set to False. Set callFunction to be False, if you don't want to call any associated functions. .clearAllCheckBoxes(callFunction=False) This will clear (untick) all CheckBoxes in the app. Set callFunction to be True, if you want to call any associated functions.","title":"Set CheckBoxes"},{"location":"pythonWidgets/#get-checkboxes","text":".getCheckBox(title) This will return True or False, depending on the state of the CheckBox. .getAllCheckBoxes() This will return the contents of all CheckBoxes in the app, as a dictionary.","title":"Get CheckBoxes"},{"location":"pythonWidgets/#optionbox","text":"Creates a simple drop-down box. It is only possible to select one option from this drop-down. Pass in a list of values to show in the drop-down box. They will be added in the same order, with the first item shown. If the first item is empty, a simple title - options - will be created. Any other empty items will be removed. If an item starts with a dash (-), it will be treated as a separator, and can't be selected. from appJar import gui app=gui() app.setFont(20) app.addLabelOptionBox(\"Options\", [\"- Fruits -\", \"Apple\", \"Orange\", \"Pear\", \"kiwi\", \"- Pets -\", \"Dogs\", \"Cats\", \"Fish\", \"Hamsters\"]) app.go()","title":"OptionBox"},{"location":"pythonWidgets/#add-optionboxes","text":".addOptionBox(title, values) This will create an OptionBox, adding the contents of the values list, in the order specified. .addTickOptionBox(title, values) This will create an OptionBox made up of check boxes. The title will always be displayed as the selected entry in the OptionBox, event though it can't be selected/ticked. Instead of selecting a single item, you tick the ones you want. Calling .getOptionBox(title) will return a dictionary of the options along with a True/False value. from appJar import gui def get(btn): print(app.getOptionBox(\"Favourite Pets\")) app=gui() app.setFont(20) app.addTickOptionBox(\"Favourite Pets\", [\"Dogs\", \"Cats\", \"Hamsters\", \"Fish\"]) app.addButton(\"GET\", get) app.go()","title":"Add OptionBoxes"},{"location":"pythonWidgets/#set-optionboxes","text":".changeOptionBox(title, newOptions, index, callFunction=False) This will replace the contents of the OptionBox, with the new list provided. If specified, the indexed item will be selected - this can be a position or an item name. If setting a TickOptionBox, the old list will be replaced with the new list. None will be ticked. index will be ignored. Set callFunction to be True, if you want to call any associated change functions. .setOptionBox(title, position, value=True, callFunction=True, override=False) This will select the item in the list, at the position specified. Alternatively, the name of an item can be specified. If changing a TickOptionBox, the specified item will be set to the specified value. Set callFunction to be False, if you don't want to call any associated functions. By default, you can't select a disabled item. You can change this by setting override to be True. .renameOptionBoxItem(title, item, newName, callFunction=False) This will rename the specified item in the named OptionBox. Set callFunction to be True, if you want to call any associated change functions. .clearOptionBox(title, callFunction=True) This will set the named OptionBox back to its first value (even if it's disabled). Set callFunction to be False, if you don't want to call any associated functions. .clearAllOptionBoxes(callFunction=False) This will set all OptionBoxes in the app back to their first value (even if it's disabled). Set callFunction to be True, if you want to call any associated functions. .deleteOptionBox(title, position) This will delete the item in the list, at the position specified. Alternatively, the name of an item can be specified. Not available on TickOptionBoxes.","title":"Set OptionBoxes"},{"location":"pythonWidgets/#get-optionboxes","text":".getOptionBox(title) This will return the currently displayed value in an OptionBox. Or a dictionary of names, and their boolean value if a TickOptionBox. Will return None, if an invalid option is currently selected. .getAllOptionBoxes() This will return the contents of all OptionBoxes in the app, as a dictionary.","title":"Get OptionBoxes"},{"location":"pythonWidgets/#spinbox","text":"A scrollable list of options. Up and down buttons are provided to scroll from one item to the next. Unlike the OptionBox, you do not get a drop-down of choices, instead it spins to the next/previous option. from appJar import gui app=gui() app.setFont(20) app.addLabelSpinBox(\"options\", [\"Apple\", \"Orange\", \"Pear\", \"kiwi\"]) app.go()","title":"SpinBox"},{"location":"pythonWidgets/#add-spinboxes","text":".addSpinBox(title, values) This will create a SpinBox, adding the contents of the values list, in the order specified. .addSpinBoxRange(title, from, to) This will create a SpinBox, with a numeric range of items. from appJar import gui app=gui() app.setFont(20) app.addSpinBoxRange(\"Numbers\", 1, 12) app.go()","title":"Add SpinBoxes"},{"location":"pythonWidgets/#set-spinboxes","text":".setSpinBox(title, value, callFunction=True) This will select the specified value in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .setSpinBoxPos(title, pos, callFunction=True) This will select the value at the specified position in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllSpinBoxes(callFunction=False) This will set all SpinBoxes in the app to their first value. Set callFunction to be True, if you want to call any associated functions.","title":"Set SpinBoxes"},{"location":"pythonWidgets/#get-spinboxes","text":".getSpinBox(title) This will get the selected value from the specified SpinBox. .getAllSpinBoxes() This will return the contents of all SpinBoxes in the app, as a dictionary. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Get SpinBoxes"},{"location":"pythonWidgets/#listbox","text":"A box containing a list of items, single or multi-select from appJar import gui app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.go()","title":"ListBox"},{"location":"pythonWidgets/#add-listboxes","text":".addListBox(title, values) Creates a ListBox with the specified values. .addListItem(title, item) Adds a single item to the the end of the ListBox, and selects it. .addListItems(title, items) Adds a list of items to the end of the List Box, selecting the last one.","title":"Add ListBoxes"},{"location":"pythonWidgets/#set-listboxes","text":".setListItem(title, item, newVal, first=False) .setListItemAtPos(title, pos, newVal) Changes the specified list item to the new value. If first is set to True, only the first item found will be changed. Otherwise, all occurrences of the specified value will be changed. .removeListItem(title, item) .removeListItemAtPos(title, pos) Remove the specified item from the specified ListBox. Will only remove the first item that matches the parameter. .clearListBox(title, callFunction=True) Removes all items from the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllListBoxes(callFunction=False) This will remove all items from all ListBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .updateListBox(title, items, select=False) Replace the contents of the specified ListBox with the new values. If you set select to be True, the last item in the list will be selected. from appJar import gui def press(btn): items = app.getListItems(\"list\") if len(items)> 0: app.removeListItem(\"list\", items[0]) app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.addButton(\"press\", press) app.go() .selectListItem(title, item, callFunction=True) .selectListItemAtPos(title, pos, callFunction=False) Selects the specified item in the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .setListBoxRows(title, rows) Sets how many rows to display in the specified ListBox. .setListBoxMulti(list, multi=True) Configures whether the specified ListBox is single or multi select. .setListBoxGroup(list, group=True) Adds the named ListBox to a group of selectable ListBoxes. All ListBoxes in the group can have items selected at the same time. .setListItemBg(title, item, colour) & .setListItemFg(title, item, colour) .setListItemAtPosBg(title, item, colour) & .setListItemAtPosFg(title, item, colour) Sets the background or foreground colours the specified ListBox item. Can either specify a named item (will update all with that name) or the position of an item.","title":"Set ListBoxes"},{"location":"pythonWidgets/#get-listboxes","text":".getListBox(title) Gets all of the selected items from the specified ListBox. .getAllListBoxes() This will return the contents of all ListBoxes in the app, as a dictionary. .getAllListItems(title) Gets all of the items from the specified ListBox.","title":"Get ListBoxes"},{"location":"pythonWidgets/#scale","text":"A slider, that has a minimum & maximum value. from appJar import gui app=gui() app.setFont(20) app.addLabelScale(\"scale\") app.go()","title":"Scale"},{"location":"pythonWidgets/#add-scales","text":".addScale(title) Adds a horizontal scale, with a default range between 0 and 100.","title":"Add Scales"},{"location":"pythonWidgets/#set-scales","text":".setScale(title, pos, callFunction=True) Sets the selected pos for the specified Scale. Set callFunction to be False, if you don't want to call any associated functions. .setScaleRange(title from, to, curr=None) Allows you to change the range available in the Scale. If curr is provided, then the Scale will be set to that value. .setScaleIncrement(title, increment) Configures how much the scale jumps, when the trough is clicked. It defaults to 10%. .showScaleIntervals(title, intervals) Configures the Scale to show interval labels along its length. intervals should be how often to show a value, eg. 25 would show 0, 25, 50, and so on... .showScaleValue(title, show=True) Configures the Scale to show the currently selected value. .setScaleHorizontal(title) & .setScaleVertical(title) Changes the Scale's orientation to the specified value. .setScaleWidth(title, width) & .setScaleLength(title, length) Sets a width/length for the scale's slider. .setScaleChangeFunction(title, func) Sets a function to call, each time the scale is changed. The function must take one parameter, which will be populated with the scale's title. .clearAllScales(callFunction=False) This will set all Scales in the app to their minimum value. Set callFunction to be True, if you want to call any associated functions.","title":"Set Scales"},{"location":"pythonWidgets/#get-scales","text":".getScale(title) Gets the currently selected value from the scale. .getAllScales() This will return the contents of all Scales in the app, as a dictionary.","title":"Get Scales"},{"location":"pythonWidgets/#message","text":"Similar to a Label, except it will wrap the text over multiple lines. from appJar import gui app=gui() app.setFont(12) app.addMessage(\"mess\", \"\"\"You can put a lot of text in this widget. The text will be wrapped over multiple lines. It's not possible to apply different styles to different words.\"\"\") app.go()","title":"Message"},{"location":"pythonWidgets/#add-messages","text":".addMessage(title, text) Adds a Message widget, with the specified text. If not text is provided, the title will be used for the text. .addEmptyMessage(title) Adds an empty Message widget.","title":"Add Messages"},{"location":"pythonWidgets/#set-messages","text":".clearMessage(title) Clears the specified Message widget. .setMessage(title, text) Sets the contents of the specified Message widget, to the specified text.","title":"Set Messages"},{"location":"pythonWidgets/#textarea","text":"Similar to an Entry, but allows you to type text over multiple lines. from appJar import gui app=gui() app.addTextArea(\"t1\") app.go()","title":"TextArea"},{"location":"pythonWidgets/#add-textareas","text":".addTextArea(title) Adds an empty TextArea, with the specified title. .addScrolledTextArea(title) Adds a scrollable TextArea with the specified title.","title":"Add TextAreas"},{"location":"pythonWidgets/#set-textareas","text":".setTextArea(title, text, end=True, callFunction=True) Adds the supplied text to the specified TextArea. By default, the text is added to the end. Set end to be False if you want to add at the beginning. Set callFunction to be False, if you don't want to call any associated functions. .clearTextArea(title, callFunction=True) Clears the contents of the specified TextArea. Set callFunction to be False, if you don't want to call any associated functions. .clearAllTextAreas(callFunction=False) This will clear the contents of all TextAreas in the app. Set callFunction to be True, if you want to call any associated functions.","title":"Set TextAreas"},{"location":"pythonWidgets/#get-textareas","text":".getTextArea(title) Gets the contents of the specified TextArea. .getAllTextAreas() This will return the contents of all TextAreas in the app, as a dictionary. Advertisement why? (adsbygoogle = window.adsbygoogle || []).push({});","title":"Get TextAreas"},{"location":"pythonWidgets/#meter","text":"Various styles of progress meter:","title":"Meter"},{"location":"pythonWidgets/#meter_1","text":"A simple meter for showing progress from 0% to 100%.","title":"Meter"},{"location":"pythonWidgets/#splitmeter","text":"A possession style meter, showing percentages on either side.","title":"SplitMeter"},{"location":"pythonWidgets/#dualmeter","text":"Two separate meters, expanding out from the middle. from appJar import gui app=gui() app.addMeter(\"progress\") app.setMeterFill(\"progress\", \"blue\") app.go()","title":"DualMeter"},{"location":"pythonWidgets/#add-meters","text":".addMeter(name) & .addSplitMeter(name) & .addDualMeter(name) Adds a meter with the specified name, of the specified type.","title":"Add Meters"},{"location":"pythonWidgets/#set-meters","text":".setMeter(name, value, text=None) Changes the specified meter to the specified value. For Meter & SplitMeter should be a value between 0 and 100. For DualMeter should be a list of two values, each between 0 and 100. .setMeterFill(name, colour) Changes the fill colour of the specified meter. For SplitMeter & DualMeter should be a list of two colours.","title":"Set Meters"},{"location":"pythonWidgets/#get-meters","text":".getMeter(name) Gets the value of the specified meter. As meters convert their data to a value between 0 and 1, this will return a list of two values: (0.45, '45 %') .getAllMeters() This will return the contents of all Meters in the app, as a dictionary.","title":"Get Meters"},{"location":"pythonWidgets/#background-processing","text":"Meters are designed to show progress over time. One common solution is to register a function that is constantly updating a meter. This should then be monitoring/updating a global variable: def updateMeter(): app.setMeter(\"progress\", percentComplete) # schedule function to be called regularly app.registerEvent(updateMeter)","title":"Background Processing"},{"location":"pythonWidgets/#properties","text":"A compound widget that shows multiple CheckButtons linked to a dictionary. Note, dictionaries have no order, so when added as a dictionary, the items will be automatically sorted. from appJar import gui toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.addProperties(\"Toppings\", toppings) app.setProperty(\"Toppings\", \"Pepper\") app.go()","title":"Properties"},{"location":"pythonWidgets/#add-properties","text":".addProperties(title, values) Creates a new Properties widget, with the specified title. If values is populated, then the dictionary items will be added to the widget.","title":"Add Properties"},{"location":"pythonWidgets/#set-properties","text":".setPropertyText(title, prop, newText=None) Change the displayed text for the named property. If no value is provided, the original value will be used. .setProperties(title, props, callFunction=True) Adds the dictionary of properties to the widget. If any of them already exist, they will be updated. Set callFunction to be False, if you don't want to call any associated functions. .setProperty(title, prop, value=False, callFunction=True) Sets the named property to the specified value. If it doesn't exist, it will be added first, at the end of the widget. Set callFunction to be False, if you don't want to call any associated functions. .deleteProperty(title, prop) Deletes the named property from the widget. .resetProperties(title, callFunction=True) This will reset the specified Properties back to its original values. Set callFunction to be False, if you don't want to call any associated functions. .clearProperties(title, callFunction=True) This will set all values in the specified Properties to False. Set callFunction to be False, if you don't want to call any associated functions. .resetAllProperties(callFunction=False) This will reset all Properties in the app back to their original values. Set callFunction to be True, if you want to call any associated functions. .clearAllProperties(callFunction=False) This will set all values in all Properties in the app to False. Set callFunction to be True, if you want to call any associated functions.","title":"Set Properties"},{"location":"pythonWidgets/#get-properties","text":".getProperties(title) Gets a dictionary of the all items in the Properties widget. .getAllProperties() This will return the contents of all Properties in the app, as a dictionary. .getProperty(title, prop) Gets the value of the named property.","title":"Get Properties"},{"location":"pythonWidgets/#examples","text":"It's possible to put Properties into ToggleFrames, and also set a Function to listen for any changes. from appJar import gui def changed(props): print(\"Changed\", props) toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.startToggleFrame(\"Toppings\") app.addProperties(\"Toppings\", toppings) app.setPropertiesChangeFunction(\"Toppings\", changed) app.stopToggleFrame() app.go()","title":"Examples"},{"location":"pythonWidgets/#separator","text":"Useful for indicating separation between widgets. Will draw a horizontal/vertical line spanning the cell. from appJar import gui app=gui() app.setBg(\"lightBlue\") app.addHorizontalSeparator(0,0,4, colour=\"red\") app.addVerticalSeparator(1,0, colour=\"red\") app.addVerticalSeparator(1,1, colour=\"red\") app.addVerticalSeparator(1,2, colour=\"red\") app.addVerticalSeparator(1,3, colour=\"red\") app.addHorizontalSeparator(2,0,4, colour=\"red\") app.go()","title":"Separator"},{"location":"pythonWidgets/#add-seperators","text":".addHorizontalSeparator(colour=None) & .addVerticalSeparator(colour=None) Adds a separator (a horizontal or vertical line) spanning the cell. An optional colour can be passed in, to set a colour for the separator.","title":"Add Seperators"},{"location":"pythonWidgets/#linkweblink","text":"Clickable text to call a function or launch a URL from appJar import gui def press(link): app.infoBox(\"Info\", \"You clicked the link!\") app=gui() app.setFont(20) app.addLink(\"Click me\", press) app.addWebLink(\"appJar.info\", \"http://appJar.info\") app.go()","title":"Link/WebLink"},{"location":"pythonWidgets/#add-links","text":".addLink(title, func) Adds a hyperlink , that when clicked, will call the specified function. .addWebLink(title, page) Adds a hyperlink , that when clicked, will launch the default browser, and load the specified page. It must be a fully formed link, including http://","title":"Add Links"},{"location":"pythonWidgets/#grip","text":"Clickable icon to drag the window around. from appJar import gui app=gui() app.setFont(20) app.setBg(\"lightBlue\") app.addLabel(\"l1\", \"Move me around...\", 0, 0) app.addGrip(0,1) app.addSeparator(1,0,2, colour=\"red\") app.go()","title":"Grip"},{"location":"pythonWidgets/#add-grips","text":".addGrip() Adds a simple grip icon. The mouse pointer changes over the grip, and a ToolTip will be shown. The size and image can't be changed.","title":"Add Grips"},{"location":"pythonWidgets/#datepicker","text":"A widget to capture a date - will handle presenting accurate drop-downs, and return a date. from appJar import gui def showDate(btn): print(app.getDatePicker(\"dp\")) app=gui() app.addDatePicker(\"dp\") app.addButton(\"GET\", showDate) app.setDatePickerRange(\"dp\", 1900, 2100) app.setDatePicker(\"dp\") app.go()","title":"DatePicker"},{"location":"pythonWidgets/#add-datepickers","text":".addDatePicker(title) Create a DatePicker, with a range from 1/1/1970 to 31/12/2020","title":"Add DatePickers"},{"location":"pythonWidgets/#set-datepickers","text":".setDatePicker(title, date=None) Will set the specified DatePicker to the specified date, or current date if no date is supplied. .setDatePickerRange(title, startYear, endYear=None) Set the range for the named DatePicker. If endYear is None, the current Year will be used. .setDatePickerChangeFunction(title, function) Set a function to call when the DatePicker is changed. .clearDatePicker(title, callFunction=True) This will reset the specified DatePicker to the earliest available date. Set callFunction to be False, if you don't want to call any associated functions. .clearAllDatePickers(callFunction=False) This will reset all DatePickers in the app to their earliest available date. Set callFunction to be True, if you want to call any associated functions.","title":"Set DatePickers"},{"location":"pythonWidgets/#get-datepickers","text":".getDatePicker(title) Will return the currently selected date. .getAllDatePickers() This will return the contents of all DatePickers in the app, as a dictionary.","title":"Get DatePickers"},{"location":"releaseNotes/","text":"","title":"releaseNotes"},{"location":"simpleAppJar/","text":"v1.0 Naming One of the features we are working towards in the 1.0 release, is a simplified way of adding, setting & getting widgets. Each widget will have a single function that supports all three actions. If you combine this with the context manager feature, this becomes possible: from appJar import gui def press(btnName): app.popUp(\"INFO\", \"You pressed \" + btnName) def update(value): if value == \"list\": app.slider(\"slider\", app.listbox(value)[0]) elif value == \"slider\": app.listbox(\"list\", app.slider(value)) app.label(\"display\", app.listbox(\"list\")[0]) with gui(\"Version 1.0\", bg=\"teal\") as app: app.label(\"Version 1.0 Demo\", colspan=2, bg=\"red\") with app.labelFrame(\"Big Buttons\", colspan=2, sticky=\"news\", expand=\"both\"): app.button(\"BUTTON A\", press) app.button(\"BUTTON B\", press) app.button(\"BUTTON C\", press) app.listbox(\"list\", [1, 2, 3, 4, 5], rows=5, selected=0, submit=update) app.label(\"display\", \"1\", row=2, column=1, bg=\"yellow\", sticky=\"news\") app.slider(\"slider\", colspan=2, range=(1,5), change=update, interval=1) Operation As demonstrated above, each widget now has a single function - the name of the widget. Call this function passing one or both of the key parameters, to determine what should happen: app.label(\"title\", \"text\") # ADD a label if the title is new app.label(\"title\", \"text_2\") # SET a label if the title already exists print(app.label(\"title\")) # GET a label if no widget is being added or set Key Parameters The two key parameters are: Parameter Data type Description title string A unique identifier for that widget type. value string Any relevant information for the widget. The logic is as follows: If title doesn't exist - ADD the widget, using the value , or title if no value is specified. If title already exists and a value is specified - SET the widget (either the values or state). If title already exists and a value is not specified - GET the widget. Positional Parameters When adding a widget, it is positioned in the first column of a new row. If you want to change this, you can specify where it should go, either by naming the paramters: app.label(\"title\", \"text\", row=2, column=4, rowspan=3) # ADD a label Or by passing them as a tuple: app.label(\"Main Title\", pos=(1, 0)) # ADD a label in row 1, column 0 app.label(\"Sub Title\", pos=(2, 0, 2)) # ADD a label in row 2, column 0, spanning 2 columns Parameter Data type Default Description row integer <next row> The grid row to place the widget in. column integer 0 The grid column to place the widget in. rowspan integer 1 The number of grid rows to stretch the widget across. colspan integer 1 The number of grid columns to stretch the widget across. pos list/tuple () Position parameters for the widget, in the order: row, column, colspan, rowspan GUI Parameters There are two GUI parameters which affect how widgets are displayed sticky and stretch . These can be modified when adding a widget, just bear in mind they are GUI settings, and will affect all future widgets in the current container. app.label(\"Title\", sticky=\"\", stretch=\"none\") app.label(\"SubTitle\", sticky=\"ns\", stretch=\"row\") Parameter Data type Default Description sticky string <varies> Describes which sides the widget will stick to, one or more of: n , e , w , s in a single string. stretch string <varies> Describes how the widget will stretch to fill the row/column: none , row , column or all . Event Parameters Most of the widgets also have some support for events (see the events page for more information). submit & change will pass the name of the widget to the function, drop will pass the data to the function: NB. the parameter should only be the name of the function, don't include any brackets. def update(name): if name == \"size\": updateSize() elif name == \"toppings\": updateToppings() app.listbox(\"size\", [\"small\", \"medium\", \"large\"], change=update) app.listbox(\"toppings\", [\"corn\", \"cheese\", \"peppers\"], change=update) app.image(\"img1\", \"placeholder.gif\", drop=True) Parameter Data type Default Description change function None A function to call when the widget is changed . callFunction boolean True Set this to False, when setting the widget to stop the change function form being called. submit function None A function to call when the widget is submitted . over function (list) None A function to call when the mouse enters the widget, with an optional second function to call when the mouse leaves . drop boolean/function None Update the widget with dropped data if True, otherwise call the function. drag function (list) None A function to call call when the widget is dragged , with an optional second function to call when the widget is dropped . Other Parameters There are some other parameter that can be set on widgets. Parameter Data type Default Description label boolean/string False Adds a Label before the widget (only some input widgets), either the label's title or the the text of this parameter. right string None Specify a premade right-click menu to link to the widget. font integer/dict None Pass either a font size, or a dictionary of font properties to use for this widget's font. focus boolean False Give keyboard focus to the widget. tip string None Sets text to show in a mouse-over tooltip. Label A widget for displaying text in the GUI. .label(title, value=None) The value will be the text to show in the label. Labels can receive a submit parameter, making them clickable. Labels can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description kind string standard Set to selectable or flash to add different kinds of labels. Message A widget for displaying multi-line text in the GUI. Will automatically wrap the text, based on either the aspect or width settings, defaulting to 50% wider than tall. .message(title, value=None) The value will be the text to show in the message. Messages can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description aspect integer 150 Set the ratio between the width & height. width integer None Set the number of characters per line. If None, then the aspect is used to calculate the width. Entry An interactive widget, for capturing user input in the GUI. .entry(title, value=None) A value is not required, but if provided will populate the entry. Entries can receive a change parameter, and can link a submit parameter to pressing . Entries can receive a drop parameter, allowing them to receive drop events. Entries can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description kind string standard One of: standard , open , save , directory , numeric , auto or validation . secret boolean False Configures the entry box to show stars instead of characters. default string None Sets default text to display in an empty entry. rows integer 10 If the kind is auto this will set the number of rows to show. labBg string None Special parameter to change the BG of the validation label in a validaiton entry. text string None Special parameter to change the text of the file entry button. There are also some validation settings that can be applied: Parameter Data type Default Description limit integer None Sets a maximum limit on the number of characters that can be entered. case string None Set to upper to force uppercase or lower to force lowercase. Text An interactive widget, for capturing multi-line user input in the GUI. .text(title, value=None) A value is not required, but if provided will populate the text. Text boxes can receive a change parameter. Text boxes can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description scroll boolean False Will configure this as a scrollable text area. tags list [] A list of tags, where each tag contains a name and dictionary of values. end boolean True Whether to add the new text to the end (True) or beginning (False) replace boolean False Will replace any existing text in the text area when updating. Button A clickable button for triggering events. .button(title, value=None) The value should be a function to call when the button is pressed. Parameter Data type Default Description image string None A path to an image to show in the button. icon string None The name of an icon to show in the button. label string None Alternative text to display on the button. Link A clickable hyperlink to trigger events or launch webpages. .link(title, value=None) The value can be set to a function to call when the link is clicked, or a valid URL to open in a browser. Check A checkbox style widget, that can be checked/unchecked. .check(title, value=None) The value should be True or False, indicating if the check starts selected or not. Check boxes can receive a change parameter. Radio Radio buttons are used in groups, only one of them can be checked. By default, the first radio button added to a group will be selected. .radio(title, name=None) The title is the radio button's group. The name is the text to display next to this radio button. Radio buttons can receive a change parameter, it will be linked to all radio buttons of the same title . Parameter Data type Default Description kind string standard Set this to square to change the style of the radio buttons. Not supported in ttk or on Mac. selected boolean False Should this radio be selected? Option When clicked, displays a drop-down of items, one of which can be selected. Setting this widget won't change the values, but change which one is selected. .option(title, value=None) When adding, the value should contain a list of items to display in the drop-down. When setting, the value should contain the item to select, unless a differetn mode is set. Options can receive a change parameter. Options can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description kind string standard Set this to ticks if you want tickable options. selected string/integer None Start with the specified item/position selected. disabled string - Sets the character used to indicate disabled menu options. checked boolean True When setting the widget, this determines what to do to the specified value. None will delete the value. mode string select One of: select , change , rename . clear or delete - see below. Different modes can be used when setting the widget: select - the default, the specified value will be selected. clear - deselects all items in the option box. change - the contents of the list will be replaced with a new listi, with an optional index . rename - this will change the text of an item in the option box, to the newName . * delete - this will delete the specified option from the option box. Spin Shows a single value, with arrows to scroll up or down, allowing the user to change the value. Setting this widget won't change the values, but change which one is selected. .spin(title, value=None, endValue=None) If only the value is set, it should be a list of values to display in the spin box. If endValue is also set, then both parameters should be integers, and appJar will generate a range of whole numbers between the two values. When setting, the value will be selected. Spin boxes can receive a change parameter. Spin boxes can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description endValue integer None If specified, value & endValue should be integers, and will be used to generate a range. selected integer 0 The position of an item to select. item string None The name of an item to select. Listbox Displays a list of items, one (or more than one) of which can be selected. Setting this widget won't change the values, but change which one is selected. .listbox(title, value=None) When adding, the value should contain a list of items to display in the listbox. When setting, the value should contain the item(s) to select. Listboxes can receive a change parameter. Listboxes can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description rows integer None Specifies how many rows to display in the listbox. multi boolean False Set the listbox to be multi-selectable. group boolean False Set the listbox to be part of a group. selected int None The position to select when the listbox is added. mode string select One of: select , change , rename . clear or delete - see below. Different modes can be used when setting the widget: select - default, select the specified item(s) or all deselect - deselect the specified item(s), or all toggle - toggle the specified item(s), or all clear - clear any selected items rename - rename the specified item replace - replace all items add - add the specified item(s) delete - delete the specified item, or all Slider A draggable widget, where the user can select a number from a range. .slider(title, value=None) The value is optional - it will set the starting position of the slider. Sliders can receive a change parameter. Sliders can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description direction string horizontal Set the direction of the slider: vertical or horizontal . show boolean False Show the slider's value above the slider. increment integer 10 Configures how much the slider jumps, when the trough is clicked. interval integer None Configures the slider to show values, along its length, in steps of the value specified. range list/tuple () Sets a start value and end value for the slider. Meter Various styles of progress meter. .meter(title, value=None) For standard and split meters value should be a number between 0 and 100. For dual meters, value should be a list of two numbers, each between 0 and 100. Parameter Data type Default Description text string None Set text to show on the meter. kind string standard Choose the kind of meter: standard , split or dual . fill boolean None Set the fill colour(s) for the slider (a list of two colours for split & dual ). Grip Displays a draggable icon, which allows the GUI to be moved. .grip() Separator Displays a line, giving visual separation in the GUI. .separator() Parameter Data type Default Description direction string horizontal Set the orientation of the separator: horizontal or vertical . colour string None Set a colour for the separator. Image Displays a picture. .image(title, value=None) The value should be the image file, icon or data to show. Images can receive a submit parameter, making them clickable. Images can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description kind string standard The kind of image, one of: icon , data or standard . fmt string None If the kind is data this will be used to determine the file type. compound string None Can be set to a position to show the title as well ( top , bottom , left , right or center ). speed integer None If this is an animated image, the FPS to animate the image at. over string None The path to an alternative image to show, when the mouse goes over the image. map dictionary None A dictionary of name:coordinates to use as an image map. submit must also be set. Properties Displays a list of checkboxes, stored in a dictionary. .properties(title, value=None) The value should contain a dictionary of names and booleans. Properties can receive a change parameter. Date Displays a simple date picker widget. .date(title, value=None) The value should contain a date object. Date pickers can receive a change parameter. Canvas Displays a canvas widget. .canvas(title) Adds a canvas with the specified title. Parameter Data type Default Description map dictionary None A dictionary of name:coordinates to use as a canvas map. submit must also be set. PopUp Displays a popUp. .popUp(title, message=None, kind=\"info\", parent=None) This will show any of the available popUps. title will be displayed in the title bar. message will be displayed as the text of the popUp. If no message is set, message will be set to title and title will be set to kind kind defaults to info , but can be any of: error , warning , yesno , question , ok , retry , string , integer , float , text or number . parent allows you to link this popUp to a named SubWindow, instead of the main window. Statusbar .statusbar(**kwargs) Functions to show or update a statusbar. It will add a statusbar if none exists, with the following parameters: header this will set a piece of text to put before any messages. fields this will set the number of fields to show in the statusbar. side this will set whether to show the fields on the LEFT , RIGHT , or the default stretched . text text to put in the first field. .statusbar(**kwargs) Or, update the statusbar if one does exist: text text to put in the field. field the field numberis applicable. Toolbar Displays the toolbar. .toolbar(names, funcs, **kwargs) names should be the list of button names to display on the toolbar. funcs should contain either a single function, that all buttons will be linked to, or a list of functions for each button. Parameter Data type Default Description icons boolean/list False Determines if appJar should try to find icons for each menu item ( True ) or a list of icon names. status list [] The enabled status of each button ( False to disable). pinned boolean None If set, the toolbar will be pinnable. Setting to True wil start pinned, False not pinned. disabled boolean False Determines if the toolbar should start disabed or not. hidden boolean False Determines if the toolbar should start hidden or not. When hidden it is completley removed from the GUI. Menu Displays a menubar .menu(menu, name, func, **kwargs) menu the text of the menu to add the item to name the text of the item to add, if a list is provided then multiple items will be created func the function to call when the menu item is selected. If name is a list, this can be a corresponding list. Parameter Data type Default Description kind string button The type of item to add: button , sub , menu , sep , check , radio group string None Only used for radio buttons, the group to add the button to. It's not necessary to set kind if this is set. shortcut string None A keyboard shortcut, to associate with the menu item. underline int -1 Which letter in the item name to underline (not all platforms). tear boolean False Only used for toplevel menus, configures them to be tearable (not all platforms). state string \"enabled\" Whether the menu item should be enabled or disabled image string None The path to an image to put alongside the menu item. icon string None The name of an icon to put alongside the menu item. align string \"left\" If an image/icon is added, how to align it alongside the text. Tree Displays the tree widget. .tree(title, value, **kwargs) The value should either by an XML string, or XML Document object Parameter Data type Default Description click function None A function to call when a node is clicked. dbl function None A function to call when a node is double-clicked. edit function None A function to call when a node is edited. editable boolean None Determines if nodes are editable or not. attributes boolean None Determines if attributes should be shown in the tree. fg string None The foreground colour of the widget. bg string None The background colour of the widget. fgH string None The foreground colour of a selected node. bgH string None The background colour of a selected node. Plot Displays matplotlib widgets. .plot(title, **kwargs) Parameter Data type Default Description t list None The x values if required. s list None The y values if required. width int None A width for the plot. height int None A height for the plot. nav boolean false Whether to show a navigation bar or not.","title":"(v1.0 Naming)"},{"location":"simpleAppJar/#v10-naming","text":"One of the features we are working towards in the 1.0 release, is a simplified way of adding, setting & getting widgets. Each widget will have a single function that supports all three actions. If you combine this with the context manager feature, this becomes possible: from appJar import gui def press(btnName): app.popUp(\"INFO\", \"You pressed \" + btnName) def update(value): if value == \"list\": app.slider(\"slider\", app.listbox(value)[0]) elif value == \"slider\": app.listbox(\"list\", app.slider(value)) app.label(\"display\", app.listbox(\"list\")[0]) with gui(\"Version 1.0\", bg=\"teal\") as app: app.label(\"Version 1.0 Demo\", colspan=2, bg=\"red\") with app.labelFrame(\"Big Buttons\", colspan=2, sticky=\"news\", expand=\"both\"): app.button(\"BUTTON A\", press) app.button(\"BUTTON B\", press) app.button(\"BUTTON C\", press) app.listbox(\"list\", [1, 2, 3, 4, 5], rows=5, selected=0, submit=update) app.label(\"display\", \"1\", row=2, column=1, bg=\"yellow\", sticky=\"news\") app.slider(\"slider\", colspan=2, range=(1,5), change=update, interval=1)","title":"v1.0 Naming"},{"location":"simpleAppJar/#operation","text":"As demonstrated above, each widget now has a single function - the name of the widget. Call this function passing one or both of the key parameters, to determine what should happen: app.label(\"title\", \"text\") # ADD a label if the title is new app.label(\"title\", \"text_2\") # SET a label if the title already exists print(app.label(\"title\")) # GET a label if no widget is being added or set","title":"Operation"},{"location":"simpleAppJar/#key-parameters","text":"The two key parameters are: Parameter Data type Description title string A unique identifier for that widget type. value string Any relevant information for the widget. The logic is as follows: If title doesn't exist - ADD the widget, using the value , or title if no value is specified. If title already exists and a value is specified - SET the widget (either the values or state). If title already exists and a value is not specified - GET the widget.","title":"Key Parameters"},{"location":"simpleAppJar/#positional-parameters","text":"When adding a widget, it is positioned in the first column of a new row. If you want to change this, you can specify where it should go, either by naming the paramters: app.label(\"title\", \"text\", row=2, column=4, rowspan=3) # ADD a label Or by passing them as a tuple: app.label(\"Main Title\", pos=(1, 0)) # ADD a label in row 1, column 0 app.label(\"Sub Title\", pos=(2, 0, 2)) # ADD a label in row 2, column 0, spanning 2 columns Parameter Data type Default Description row integer <next row> The grid row to place the widget in. column integer 0 The grid column to place the widget in. rowspan integer 1 The number of grid rows to stretch the widget across. colspan integer 1 The number of grid columns to stretch the widget across. pos list/tuple () Position parameters for the widget, in the order: row, column, colspan, rowspan","title":"Positional Parameters"},{"location":"simpleAppJar/#gui-parameters","text":"There are two GUI parameters which affect how widgets are displayed sticky and stretch . These can be modified when adding a widget, just bear in mind they are GUI settings, and will affect all future widgets in the current container. app.label(\"Title\", sticky=\"\", stretch=\"none\") app.label(\"SubTitle\", sticky=\"ns\", stretch=\"row\") Parameter Data type Default Description sticky string <varies> Describes which sides the widget will stick to, one or more of: n , e , w , s in a single string. stretch string <varies> Describes how the widget will stretch to fill the row/column: none , row , column or all .","title":"GUI Parameters"},{"location":"simpleAppJar/#event-parameters","text":"Most of the widgets also have some support for events (see the events page for more information). submit & change will pass the name of the widget to the function, drop will pass the data to the function: NB. the parameter should only be the name of the function, don't include any brackets. def update(name): if name == \"size\": updateSize() elif name == \"toppings\": updateToppings() app.listbox(\"size\", [\"small\", \"medium\", \"large\"], change=update) app.listbox(\"toppings\", [\"corn\", \"cheese\", \"peppers\"], change=update) app.image(\"img1\", \"placeholder.gif\", drop=True) Parameter Data type Default Description change function None A function to call when the widget is changed . callFunction boolean True Set this to False, when setting the widget to stop the change function form being called. submit function None A function to call when the widget is submitted . over function (list) None A function to call when the mouse enters the widget, with an optional second function to call when the mouse leaves . drop boolean/function None Update the widget with dropped data if True, otherwise call the function. drag function (list) None A function to call call when the widget is dragged , with an optional second function to call when the widget is dropped .","title":"Event Parameters"},{"location":"simpleAppJar/#other-parameters","text":"There are some other parameter that can be set on widgets. Parameter Data type Default Description label boolean/string False Adds a Label before the widget (only some input widgets), either the label's title or the the text of this parameter. right string None Specify a premade right-click menu to link to the widget. font integer/dict None Pass either a font size, or a dictionary of font properties to use for this widget's font. focus boolean False Give keyboard focus to the widget. tip string None Sets text to show in a mouse-over tooltip.","title":"Other Parameters"},{"location":"simpleAppJar/#label","text":"A widget for displaying text in the GUI. .label(title, value=None) The value will be the text to show in the label. Labels can receive a submit parameter, making them clickable. Labels can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description kind string standard Set to selectable or flash to add different kinds of labels.","title":"Label"},{"location":"simpleAppJar/#message","text":"A widget for displaying multi-line text in the GUI. Will automatically wrap the text, based on either the aspect or width settings, defaulting to 50% wider than tall. .message(title, value=None) The value will be the text to show in the message. Messages can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description aspect integer 150 Set the ratio between the width & height. width integer None Set the number of characters per line. If None, then the aspect is used to calculate the width.","title":"Message"},{"location":"simpleAppJar/#entry","text":"An interactive widget, for capturing user input in the GUI. .entry(title, value=None) A value is not required, but if provided will populate the entry. Entries can receive a change parameter, and can link a submit parameter to pressing . Entries can receive a drop parameter, allowing them to receive drop events. Entries can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description kind string standard One of: standard , open , save , directory , numeric , auto or validation . secret boolean False Configures the entry box to show stars instead of characters. default string None Sets default text to display in an empty entry. rows integer 10 If the kind is auto this will set the number of rows to show. labBg string None Special parameter to change the BG of the validation label in a validaiton entry. text string None Special parameter to change the text of the file entry button. There are also some validation settings that can be applied: Parameter Data type Default Description limit integer None Sets a maximum limit on the number of characters that can be entered. case string None Set to upper to force uppercase or lower to force lowercase.","title":"Entry"},{"location":"simpleAppJar/#text","text":"An interactive widget, for capturing multi-line user input in the GUI. .text(title, value=None) A value is not required, but if provided will populate the text. Text boxes can receive a change parameter. Text boxes can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description scroll boolean False Will configure this as a scrollable text area. tags list [] A list of tags, where each tag contains a name and dictionary of values. end boolean True Whether to add the new text to the end (True) or beginning (False) replace boolean False Will replace any existing text in the text area when updating.","title":"Text"},{"location":"simpleAppJar/#button","text":"A clickable button for triggering events. .button(title, value=None) The value should be a function to call when the button is pressed. Parameter Data type Default Description image string None A path to an image to show in the button. icon string None The name of an icon to show in the button. label string None Alternative text to display on the button.","title":"Button"},{"location":"simpleAppJar/#link","text":"A clickable hyperlink to trigger events or launch webpages. .link(title, value=None) The value can be set to a function to call when the link is clicked, or a valid URL to open in a browser.","title":"Link"},{"location":"simpleAppJar/#check","text":"A checkbox style widget, that can be checked/unchecked. .check(title, value=None) The value should be True or False, indicating if the check starts selected or not. Check boxes can receive a change parameter.","title":"Check"},{"location":"simpleAppJar/#radio","text":"Radio buttons are used in groups, only one of them can be checked. By default, the first radio button added to a group will be selected. .radio(title, name=None) The title is the radio button's group. The name is the text to display next to this radio button. Radio buttons can receive a change parameter, it will be linked to all radio buttons of the same title . Parameter Data type Default Description kind string standard Set this to square to change the style of the radio buttons. Not supported in ttk or on Mac. selected boolean False Should this radio be selected?","title":"Radio"},{"location":"simpleAppJar/#option","text":"When clicked, displays a drop-down of items, one of which can be selected. Setting this widget won't change the values, but change which one is selected. .option(title, value=None) When adding, the value should contain a list of items to display in the drop-down. When setting, the value should contain the item to select, unless a differetn mode is set. Options can receive a change parameter. Options can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description kind string standard Set this to ticks if you want tickable options. selected string/integer None Start with the specified item/position selected. disabled string - Sets the character used to indicate disabled menu options. checked boolean True When setting the widget, this determines what to do to the specified value. None will delete the value. mode string select One of: select , change , rename . clear or delete - see below. Different modes can be used when setting the widget: select - the default, the specified value will be selected. clear - deselects all items in the option box. change - the contents of the list will be replaced with a new listi, with an optional index . rename - this will change the text of an item in the option box, to the newName . * delete - this will delete the specified option from the option box.","title":"Option"},{"location":"simpleAppJar/#spin","text":"Shows a single value, with arrows to scroll up or down, allowing the user to change the value. Setting this widget won't change the values, but change which one is selected. .spin(title, value=None, endValue=None) If only the value is set, it should be a list of values to display in the spin box. If endValue is also set, then both parameters should be integers, and appJar will generate a range of whole numbers between the two values. When setting, the value will be selected. Spin boxes can receive a change parameter. Spin boxes can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description endValue integer None If specified, value & endValue should be integers, and will be used to generate a range. selected integer 0 The position of an item to select. item string None The name of an item to select.","title":"Spin"},{"location":"simpleAppJar/#listbox","text":"Displays a list of items, one (or more than one) of which can be selected. Setting this widget won't change the values, but change which one is selected. .listbox(title, value=None) When adding, the value should contain a list of items to display in the listbox. When setting, the value should contain the item(s) to select. Listboxes can receive a change parameter. Listboxes can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description rows integer None Specifies how many rows to display in the listbox. multi boolean False Set the listbox to be multi-selectable. group boolean False Set the listbox to be part of a group. selected int None The position to select when the listbox is added. mode string select One of: select , change , rename . clear or delete - see below. Different modes can be used when setting the widget: select - default, select the specified item(s) or all deselect - deselect the specified item(s), or all toggle - toggle the specified item(s), or all clear - clear any selected items rename - rename the specified item replace - replace all items add - add the specified item(s) delete - delete the specified item, or all","title":"Listbox"},{"location":"simpleAppJar/#slider","text":"A draggable widget, where the user can select a number from a range. .slider(title, value=None) The value is optional - it will set the starting position of the slider. Sliders can receive a change parameter. Sliders can receive a label parameter - boolean to use the label's title or text to display. Parameter Data type Default Description direction string horizontal Set the direction of the slider: vertical or horizontal . show boolean False Show the slider's value above the slider. increment integer 10 Configures how much the slider jumps, when the trough is clicked. interval integer None Configures the slider to show values, along its length, in steps of the value specified. range list/tuple () Sets a start value and end value for the slider.","title":"Slider"},{"location":"simpleAppJar/#meter","text":"Various styles of progress meter. .meter(title, value=None) For standard and split meters value should be a number between 0 and 100. For dual meters, value should be a list of two numbers, each between 0 and 100. Parameter Data type Default Description text string None Set text to show on the meter. kind string standard Choose the kind of meter: standard , split or dual . fill boolean None Set the fill colour(s) for the slider (a list of two colours for split & dual ).","title":"Meter"},{"location":"simpleAppJar/#grip","text":"Displays a draggable icon, which allows the GUI to be moved. .grip()","title":"Grip"},{"location":"simpleAppJar/#separator","text":"Displays a line, giving visual separation in the GUI. .separator() Parameter Data type Default Description direction string horizontal Set the orientation of the separator: horizontal or vertical . colour string None Set a colour for the separator.","title":"Separator"},{"location":"simpleAppJar/#image","text":"Displays a picture. .image(title, value=None) The value should be the image file, icon or data to show. Images can receive a submit parameter, making them clickable. Images can receive a drop parameter, allowing them to receive drop events. Parameter Data type Default Description kind string standard The kind of image, one of: icon , data or standard . fmt string None If the kind is data this will be used to determine the file type. compound string None Can be set to a position to show the title as well ( top , bottom , left , right or center ). speed integer None If this is an animated image, the FPS to animate the image at. over string None The path to an alternative image to show, when the mouse goes over the image. map dictionary None A dictionary of name:coordinates to use as an image map. submit must also be set.","title":"Image"},{"location":"simpleAppJar/#properties","text":"Displays a list of checkboxes, stored in a dictionary. .properties(title, value=None) The value should contain a dictionary of names and booleans. Properties can receive a change parameter.","title":"Properties"},{"location":"simpleAppJar/#date","text":"Displays a simple date picker widget. .date(title, value=None) The value should contain a date object. Date pickers can receive a change parameter.","title":"Date"},{"location":"simpleAppJar/#canvas","text":"Displays a canvas widget. .canvas(title) Adds a canvas with the specified title. Parameter Data type Default Description map dictionary None A dictionary of name:coordinates to use as a canvas map. submit must also be set.","title":"Canvas"},{"location":"simpleAppJar/#popup","text":"Displays a popUp. .popUp(title, message=None, kind=\"info\", parent=None) This will show any of the available popUps. title will be displayed in the title bar. message will be displayed as the text of the popUp. If no message is set, message will be set to title and title will be set to kind kind defaults to info , but can be any of: error , warning , yesno , question , ok , retry , string , integer , float , text or number . parent allows you to link this popUp to a named SubWindow, instead of the main window.","title":"PopUp"},{"location":"simpleAppJar/#statusbar","text":".statusbar(**kwargs) Functions to show or update a statusbar. It will add a statusbar if none exists, with the following parameters: header this will set a piece of text to put before any messages. fields this will set the number of fields to show in the statusbar. side this will set whether to show the fields on the LEFT , RIGHT , or the default stretched . text text to put in the first field. .statusbar(**kwargs) Or, update the statusbar if one does exist: text text to put in the field. field the field numberis applicable.","title":"Statusbar"},{"location":"simpleAppJar/#toolbar","text":"Displays the toolbar. .toolbar(names, funcs, **kwargs) names should be the list of button names to display on the toolbar. funcs should contain either a single function, that all buttons will be linked to, or a list of functions for each button. Parameter Data type Default Description icons boolean/list False Determines if appJar should try to find icons for each menu item ( True ) or a list of icon names. status list [] The enabled status of each button ( False to disable). pinned boolean None If set, the toolbar will be pinnable. Setting to True wil start pinned, False not pinned. disabled boolean False Determines if the toolbar should start disabed or not. hidden boolean False Determines if the toolbar should start hidden or not. When hidden it is completley removed from the GUI.","title":"Toolbar"},{"location":"simpleAppJar/#menu","text":"Displays a menubar .menu(menu, name, func, **kwargs) menu the text of the menu to add the item to name the text of the item to add, if a list is provided then multiple items will be created func the function to call when the menu item is selected. If name is a list, this can be a corresponding list. Parameter Data type Default Description kind string button The type of item to add: button , sub , menu , sep , check , radio group string None Only used for radio buttons, the group to add the button to. It's not necessary to set kind if this is set. shortcut string None A keyboard shortcut, to associate with the menu item. underline int -1 Which letter in the item name to underline (not all platforms). tear boolean False Only used for toplevel menus, configures them to be tearable (not all platforms). state string \"enabled\" Whether the menu item should be enabled or disabled image string None The path to an image to put alongside the menu item. icon string None The name of an icon to put alongside the menu item. align string \"left\" If an image/icon is added, how to align it alongside the text.","title":"Menu"},{"location":"simpleAppJar/#tree","text":"Displays the tree widget. .tree(title, value, **kwargs) The value should either by an XML string, or XML Document object Parameter Data type Default Description click function None A function to call when a node is clicked. dbl function None A function to call when a node is double-clicked. edit function None A function to call when a node is edited. editable boolean None Determines if nodes are editable or not. attributes boolean None Determines if attributes should be shown in the tree. fg string None The foreground colour of the widget. bg string None The background colour of the widget. fgH string None The foreground colour of a selected node. bgH string None The background colour of a selected node.","title":"Tree"},{"location":"simpleAppJar/#plot","text":"Displays matplotlib widgets. .plot(title, **kwargs) Parameter Data type Default Description t list None The x values if required. s list None The y values if required. width int None A width for the plot. height int None A height for the plot. nav boolean false Whether to show a navigation bar or not.","title":"Plot"},{"location":"simpleProperties/","text":"v1.0 Properties appJar includes a number of properties that can be configured to change how the GUI looks/acts. These are exposed as properties , so can be set uing the assignment operator, = . app.title = \"Property Demo\" app.bg = \"red\" app.fg = \"yellow\" If you want to set multiple properties at once, there is a configure() function to support this: .configure(**kwargs) app.configure(bg='red', fg='yellow', font={'size':20, 'family':'Helvetica'}) Nearly all properties can be got in the same way: app.label('sizeLab', app.size) app.label('locLab', app.location) app.label('transLab', app.transparency) GUI Settings Property Data type Description title string Pass a string to display in the title bar of the GUI icon string Pass the path to an icon file, to display in the title bar - only works on Windows. transparency integer Pass a percentage (between 0 & 100) to set the transparency, of the GUI (not on Linux). visible boolean Pass a boolean to hide or show the GUI. top boolean Pass a boolean to keep the GUI on top or not. Padding Property Data type Description padding integer (list) Pass a tuple containing the x & y padding or a single integer for both x & y inPadding integer (list) Pass a tuple containing the x & y padding or a single integer for both x & y guiPadding integer (list) Pass a tuple containing the x & y padding or a single integer for both x & y Size & Location Property Data type Description size integer (list) Pass a tuple containing the width & height (or the string fullscreen ) location integer (list) Pass a tuple containing the x & y coordinates (or the string CENTER ) fullscreen boolean Pass either True or False , to enter/exit fullscreen. resizable boolean Pass either True or False , to set the GUI resizable or not. Grid Properties Property Data type Description sticky string Pass a string describing which sides widegts should stick to (news). stretch string Pass a string describing if rows/columns should stretch, to fill the entire GUI. row integer Gets or sets the next row number to be used. rowspan integer Gets or sets the rowspan for the current container. colspan integer Gets or sets the colspan for the current container. Looks Property Data type Description fg string Pass a colour to use for the text colour of all label style widgets. bg string Pass a colour to use for the background of all label style widgets. font integer/dict Pass either a font size, or a dictionary of font properties to use for all widgets. buttonFont integer/dict Pass either a font size, or dicitonary of font properties to use for all button style widgets. labelFont integer/dict Pass either a font size, or a dictionary of font properties to use for all label style widgets. statusFont integer/dict Pass either a font size, or a dictionary of font properties to use for the statusbar. ttkTheme string Only available in ttk mode - pass the name of the ttk theme you want to use. fonts string (list) (no SETTER) Returns a list of all available fonts. Other Property Data type Description editMenu Boolean Enables and disables the right-click edit menu for text based widgets. stopFunction function (no GETTER) Sets a function to call when the GUI is closed. startFunction function (no GETTER) Sets a function to call when the GUI starts up. fastStop Boolean Set this to True if you have a LOT of widgets, and stopping appJar has gotten slow (doesn't work from IDLE). enterKey function (no GETTER) Sets or disables (pass None) a function bound to the enter key. logLevel string Sets the logging level. logFile string Sets a file to log messages to. language string Sets the current language.","title":"(v1.0 Properties)"},{"location":"simpleProperties/#v10-properties","text":"appJar includes a number of properties that can be configured to change how the GUI looks/acts. These are exposed as properties , so can be set uing the assignment operator, = . app.title = \"Property Demo\" app.bg = \"red\" app.fg = \"yellow\" If you want to set multiple properties at once, there is a configure() function to support this: .configure(**kwargs) app.configure(bg='red', fg='yellow', font={'size':20, 'family':'Helvetica'}) Nearly all properties can be got in the same way: app.label('sizeLab', app.size) app.label('locLab', app.location) app.label('transLab', app.transparency)","title":"v1.0 Properties"},{"location":"simpleProperties/#gui-settings","text":"Property Data type Description title string Pass a string to display in the title bar of the GUI icon string Pass the path to an icon file, to display in the title bar - only works on Windows. transparency integer Pass a percentage (between 0 & 100) to set the transparency, of the GUI (not on Linux). visible boolean Pass a boolean to hide or show the GUI. top boolean Pass a boolean to keep the GUI on top or not.","title":"GUI Settings"},{"location":"simpleProperties/#padding","text":"Property Data type Description padding integer (list) Pass a tuple containing the x & y padding or a single integer for both x & y inPadding integer (list) Pass a tuple containing the x & y padding or a single integer for both x & y guiPadding integer (list) Pass a tuple containing the x & y padding or a single integer for both x & y","title":"Padding"},{"location":"simpleProperties/#size-location","text":"Property Data type Description size integer (list) Pass a tuple containing the width & height (or the string fullscreen ) location integer (list) Pass a tuple containing the x & y coordinates (or the string CENTER ) fullscreen boolean Pass either True or False , to enter/exit fullscreen. resizable boolean Pass either True or False , to set the GUI resizable or not.","title":"Size &amp; Location"},{"location":"simpleProperties/#grid-properties","text":"Property Data type Description sticky string Pass a string describing which sides widegts should stick to (news). stretch string Pass a string describing if rows/columns should stretch, to fill the entire GUI. row integer Gets or sets the next row number to be used. rowspan integer Gets or sets the rowspan for the current container. colspan integer Gets or sets the colspan for the current container.","title":"Grid Properties"},{"location":"simpleProperties/#looks","text":"Property Data type Description fg string Pass a colour to use for the text colour of all label style widgets. bg string Pass a colour to use for the background of all label style widgets. font integer/dict Pass either a font size, or a dictionary of font properties to use for all widgets. buttonFont integer/dict Pass either a font size, or dicitonary of font properties to use for all button style widgets. labelFont integer/dict Pass either a font size, or a dictionary of font properties to use for all label style widgets. statusFont integer/dict Pass either a font size, or a dictionary of font properties to use for the statusbar. ttkTheme string Only available in ttk mode - pass the name of the ttk theme you want to use. fonts string (list) (no SETTER) Returns a list of all available fonts.","title":"Looks"},{"location":"simpleProperties/#other","text":"Property Data type Description editMenu Boolean Enables and disables the right-click edit menu for text based widgets. stopFunction function (no GETTER) Sets a function to call when the GUI is closed. startFunction function (no GETTER) Sets a function to call when the GUI starts up. fastStop Boolean Set this to True if you have a LOT of widgets, and stopping appJar has gotten slow (doesn't work from IDLE). enterKey function (no GETTER) Sets or disables (pass None) a function bound to the enter key. logLevel string Sets the logging level. logFile string Sets a file to log messages to. language string Sets the current language.","title":"Other"},{"location":"specialCharacters/","text":"Special Characters If you've ever tried a ValidationEntry , you'll notice we use some special characters: Explanation You can't find these on the keyboard, so can't type them in your code. Instead, you need to use a special code ( unicode ), for the character you want. For example, Unicode for the tick is 2714 , and the cross is 2716 To represent these in Python, you need to use a special syntax: TICK=\"\\u2714\" CROSS=\"\\u2716\" app.addLabel(\"tick\", TICK) app.addLabel(\"cross\", CROSS) By putting \\u at the start of the String, you tell Python it is a Unicode character. This works well in Python 3.x, as it knows what unicode characters are. If you're still using python 2.x (not recommended), you'll need to use a little extra magic: TICK=u\"\\u2714\" CROSS=u\"\\u2716\" app.addLabel(\"tick\", TICK) app.addLabel(\"cross\", CROSS) By also putting a u before the string, you tell Python to expect a unicode character. (In fact, it calls the Unicode function, converting the string data into Unicode.) Example As demonstrated above, it's best to define any Unicode characters you want to use as constants, then you can use them in your code just like any other string. PLAY = \"\\u25B6\" # 23F5 should work... PAUSE = \"\\u23F8\" RWD = \"\\u23EA\" FWD = \"\\u23E9\" STOP = \"\\u23F9\" def music(btn): if btn == PLAY: # play music elif btn == PAUSE: # pause music app.setButtonFont(20) app.addButtons([PLAY, PAUSE, STOP, RWD, FWD], music) Unicode Search So, now you just need to find the right Unicode... Our favourite site is FileFormat.info : Simply type what you are looking for into the search box, and it will give you the best matches: Identify the one you want, and take a note of the Unicode: 263C (Note, these are hexadecimal codes, so the values will be between 0 and F) You can then use this code in your gui: FLOWER = \"\\u263C\" app.addButton(FLOWER, flowerPower) Important Different platforms will (potentially) display these characters in different ways... As you can see in the music example, for some reason, the PLAY character doesn't display like the other characters... There is also an issue with Python GUIs in general, where they can't actually (yet) display all of the different Unicode characters. If the character has more than 4 digits in its code, it probably won't work. You may even get an error similar to: character is above the range (U+0000-U+FFFF) allowed by Tcl So, make sure you test them! Compatability As you can see, it's hard to make your code work on all versions of Python. The switch from Python2 to Python3 caused lots of problems, as the u prefix was removed. That meant there were two different ways to get unicode to work: Python2: u'\\u23F9' , Python3: '\\u23F9' As of Python 3.3, the u prefix was brought back (although it doesn't do anything), but that still meant Python3.0 to Python3.2 didn't support it. So, the best solution, if you want your code to work on all versions of Python, is to not use the u prefix, and instead change the way Python2 works. If you include from __future__ import unicode_literals at the start of your code, you can include unicode characters in Python2, without using the u prefix - print('\\u23F9') will then work on every version of python. Easter Egg Try holding the <ALT> key and typing different codes on a Windows computer...","title":"Special Characters"},{"location":"specialCharacters/#special-characters","text":"If you've ever tried a ValidationEntry , you'll notice we use some special characters:","title":"Special Characters"},{"location":"specialCharacters/#explanation","text":"You can't find these on the keyboard, so can't type them in your code. Instead, you need to use a special code ( unicode ), for the character you want. For example, Unicode for the tick is 2714 , and the cross is 2716 To represent these in Python, you need to use a special syntax: TICK=\"\\u2714\" CROSS=\"\\u2716\" app.addLabel(\"tick\", TICK) app.addLabel(\"cross\", CROSS) By putting \\u at the start of the String, you tell Python it is a Unicode character. This works well in Python 3.x, as it knows what unicode characters are. If you're still using python 2.x (not recommended), you'll need to use a little extra magic: TICK=u\"\\u2714\" CROSS=u\"\\u2716\" app.addLabel(\"tick\", TICK) app.addLabel(\"cross\", CROSS) By also putting a u before the string, you tell Python to expect a unicode character. (In fact, it calls the Unicode function, converting the string data into Unicode.)","title":"Explanation"},{"location":"specialCharacters/#example","text":"As demonstrated above, it's best to define any Unicode characters you want to use as constants, then you can use them in your code just like any other string. PLAY = \"\\u25B6\" # 23F5 should work... PAUSE = \"\\u23F8\" RWD = \"\\u23EA\" FWD = \"\\u23E9\" STOP = \"\\u23F9\" def music(btn): if btn == PLAY: # play music elif btn == PAUSE: # pause music app.setButtonFont(20) app.addButtons([PLAY, PAUSE, STOP, RWD, FWD], music)","title":"Example"},{"location":"specialCharacters/#unicode-search","text":"So, now you just need to find the right Unicode... Our favourite site is FileFormat.info : Simply type what you are looking for into the search box, and it will give you the best matches: Identify the one you want, and take a note of the Unicode: 263C (Note, these are hexadecimal codes, so the values will be between 0 and F) You can then use this code in your gui: FLOWER = \"\\u263C\" app.addButton(FLOWER, flowerPower)","title":"Unicode Search"},{"location":"specialCharacters/#important","text":"Different platforms will (potentially) display these characters in different ways... As you can see in the music example, for some reason, the PLAY character doesn't display like the other characters... There is also an issue with Python GUIs in general, where they can't actually (yet) display all of the different Unicode characters. If the character has more than 4 digits in its code, it probably won't work. You may even get an error similar to: character is above the range (U+0000-U+FFFF) allowed by Tcl So, make sure you test them!","title":"Important"},{"location":"specialCharacters/#compatability","text":"As you can see, it's hard to make your code work on all versions of Python. The switch from Python2 to Python3 caused lots of problems, as the u prefix was removed. That meant there were two different ways to get unicode to work: Python2: u'\\u23F9' , Python3: '\\u23F9' As of Python 3.3, the u prefix was brought back (although it doesn't do anything), but that still meant Python3.0 to Python3.2 didn't support it. So, the best solution, if you want your code to work on all versions of Python, is to not use the u prefix, and instead change the way Python2 works. If you include from __future__ import unicode_literals at the start of your code, you can include unicode characters in Python2, without using the u prefix - print('\\u23F9') will then work on every version of python.","title":"Compatability"},{"location":"specialCharacters/#easter-egg","text":"Try holding the <ALT> key and typing different codes on a Windows computer...","title":"Easter Egg"},{"location":"splash/","text":"Splashscreen It's possible to show a very simple SplashScreen when your GUI starts up. It will fill the whole screen, and stay up for a couple of seconds, while your GUI loads. Simply call: .showSplash(text, fill='red', stripe='black', fg='white', font=44) Pass in the text you want to show, plus any colours (not required). text This should be a short message to show in the center of the screen. fill - this is the bg colour for the splashscreen. stripe - this is the bg colour of a stripe across the screen. fg - this is the colour of the writing to put in the stripe. font - the size of the text. This is only a very simple splashScreen, eventually, it will be possible to arrange labels and images in it, just as is possible in the main GUI layout...","title":"Splashscreen"},{"location":"splash/#splashscreen","text":"It's possible to show a very simple SplashScreen when your GUI starts up. It will fill the whole screen, and stay up for a couple of seconds, while your GUI loads. Simply call: .showSplash(text, fill='red', stripe='black', fg='white', font=44) Pass in the text you want to show, plus any colours (not required). text This should be a short message to show in the center of the screen. fill - this is the bg colour for the splashscreen. stripe - this is the bg colour of a stripe across the screen. fg - this is the colour of the writing to put in the stripe. font - the size of the text. This is only a very simple splashScreen, eventually, it will be possible to arrange labels and images in it, just as is possible in the main GUI layout...","title":"Splashscreen"},{"location":"whatsNew/","text":"Change-Log Version 0.94 New Example of how to create a stylesheet - #481 New Function to move widgets - #477 Added ability to change the text shown in a checkBox - #578 Added can now change the BG colour of toolbars - #577 Added Paned Frames support a change function - #561 Added All labels can be cleared with a single function call - #570 Added File Entry supports choosing a save file - #539 Added Option to display navigation bar in MatPlotLib - #529 Added Additional properties on Tables - #517 Added Can now configure the bg colour of check boxes in properties widgets - #514 Added Can now set the sash position on PanedFrames - #504 Added Multiple files allowed in open file boxes - #479 Added Option to add multiple action buttons and align horizontally/vertically in Tables - #475 Added Can now add tabs before/after existing tabs - #473 Added When updating a textArea you can now configure it to replace any existing text - #472 Added New property to change the statusbar font - #463 Added Can now create trees with xml objects and show attributes - #457 Added Option to set wrap parameter on Tables - #458 Added Introduced new container properties rowspan/colspan - #55 Improved removed references to rwbatools in example code - #569 Improved getAllInputs() now has a parameter includeEmptyInputs to include any empty input fields - #563 Improved Buttons now align images/icons correctly in ttk - #560 Improved Changed log level of setSize - #543 Improved Improved docs on widget positioning - #524 Improved Improved docs on stopping the GUI - #521 Improved Improved docs on pip installation - #519 Improved Resolved deprecated import on MatPlotLib - #518 Improved Removed imports from __init__.py file - #505 Improved Scales and other widgets can now have their state changed when in ttk mode - #465 Improved Better change log? - #219 Improved appJar now uses tkinter style config functions - #49 Fixed Setting size is now case insensitive: GUI Options - #580 Fixed Fixed typo in documentation page: advancedLoops - #564 Fixed python2.6 now runs, after removing dependency on argsparse - #547 Fixed Resolved issues sometimes changing bg/fg in ttk - #536 Fixed Resolved issues with changing radiobutton type in ttk - #534 Fixed Scrolling to the end of an entry in ttk - #538 Fixed All start container functions now return the container - #523 Fixed Menu check boxes now toggle using the keyboard shortcut, and also work properly on Mac - #512 Fixed Menu shortcuts improved, to handle more cases - #499 Fixed Issue where blocking subwindows wouldn't work - #491 Fixed Bug where Labelled widgets weren't destroyed properly - #489 Fixed Issue with deleting rows on tables - #482 Fixed Issue where opening containers was not returning the container - #478 Fixed Refactored Remove/Empty/Destroy containers - #75 , #339 , #462 Fixed Issue with setting parent of message boxes - #461 Removed Deprecated .panedFrameVertical() , you should now call .panedFrame(vertical=True) - #504 Version 0.93 NEW: #453 - SubWindows refactored #450 - Can now set the character used to disable options in OptionBoxes #449 - updateListBox now has a callFunction flag #447 - Canvases now support clickable maps #446 - Setting listboxes now has better error checking #445 - Ability to keep windows on top #442 - SpinBoxes now call changeFunction when changed manually #437 - Page discussing how to manage multiple pages #436 - TextAreas can now be programmatically cleared and set while disabled #435 - Messages have better documentation and a function to set the aspect ratio #429 - TabbedFrames & PagedWindows now use FrameStacks #425 - Updated docs on geometry #422 - TickOptionBoxes now return their name when changed #421 - SelectableLabels now allow alignment setting #415 - Disable Entry now disables all of a file/directory entry #402 - Now possible to register a function to call once the GUI starts up #377 - Auto-Labelled Widgets now have configurable labels #345 - New container: FrameStack #339 - Functions to remove toolbars and statusbars #333 - Can now fully hide/show/delete tabs #295 - New function to set the BG of the label in a validationEntry #69 - Basic functions for tagging , searching and changing fonts in text areas FIXED: #433 - Resolved issue with setting properties in Python2 Version 0.92 FIXED: #413 - Fixed issue with .refreshDbTable() in DB tables #410 - Fixed issue with button text when adding tables #409 - Fixed issue with topLevel binds on mouse down events #408 - Changed logLevel for some widget removal Version 0.91 NEW: Grids have been renamed to Tables! appJar logging now uses its own logLevel of TRACE #398 - Documented .pyw files #395 - Option to fast stop a GUI #391 - Updated error messages on _configWidget #390 - New simpleAppJar functions for statusbar #388 - Can now specify the cell style of tables #373 - Added function to get the BG colour of a widget #347 , #360 , 374 & #375 - Right Click Menu updates #369 - Hide scrollbars in ScollPane #367 - Update to logging - all appJar logging now done at a TRACE level, below DEBUG #366 - Better error reporting on AutoEntries #340 - appJar properties now fully documented & tested #335 - No longer necessary to receive a parameter in functions linked to appJar widgets #329 - Starting separator removed from Windows Right-click Menus #328 - New Accessibility Widget introduced to configure colours & fonts #301 - Updated layout parameters , can now pass previous & next for the row parameter, to make it easier to position widgets #29 - Updated sound documentation to discuss blocking sounds FIXED: #379 - PieChart % fix in Python 2.7 Version 0.9 Introduction of alternative widget access functions ( #235 ) - now possible to ADD , SET & GET widgets by just using their name Introduction of alternative GUI properties ( #340 ) - now possible to GET/SET properties with special property functions Introduction of appJar settings - can now save/load GUI state to/from file Big improvements to grids - can add/remove/replace rows/columns, can sort data, can access a right-click menu, can connect to an sqlite database More ttk improvements - grouped widgets now work, introduced external themes Issues Resolved: #356 - Updated documentation - widgets page split into input & output pages #344 - labels now display the title when no text is provided, instead of an empty label #343 - new parameter for appJar constructor: showIcon allows the icon to be ignored when running Windows #340 - introduced GUI properties for most settings #339 - new functions to remove toolbars and statusbars #335 - when setting functions for events, if no parameter is present in the function, no parameter will be passed by the event #333 - started work on hide/show/delete tabs #325 - fixed issue with right-click menus #324 - fixed issue with losing file/directory Entry values #317 - implemented fonts on tabbed frames #316 - can now display compound images and text in buttons #309 - cleaned up handling of fonts #303 - added functions to bind/unbind multiple keys to a function #298 - fixed issue in menubar shortcuts where numeric shortcuts didn't work #296 - two new widgets introduced turtle and canvas #294 & #292 - fixes on entries : better handle arrow key presses on mac, defaults work better on secret entries & file/directory entries #290 - fixed issue showing AutoEntries in subWindows #289 - new functions to change list in AutoEntries #288 - fixed issue showing dialogs in subWindows #286 - added new threaded callback , contributed by @mpmc #284 - new dialogs for strings, integers & floats #283 - questionBox now returns Booleans instead of yes/no #281 - resolved issues with threads #279 - tidied up remove all widgets - now leaves GUI looking better #271 , #266 , #255 & #232 - Grid improvements #242 , #259 , #267 - work on MatPLotLib now support multiple plot types, and retaining some settings #250 - Can now add compound images - images with a built in label #236 - appJar can now save GUI settings and load them again #233 - NumericEntries return None when empty #218 - Can no longer set NumericEntries to Strings Version 0.82.1 Issues Resolved: #275 - maps fix Version 0.82 Issues Resolved: #189 - some tweaks to ttk support Fixes to documentation Version 0.8 Changed versioning - PyPi difficulties, combined with close to a 1.0 release... Create a GUI in TWO lines using context managers - appJar now allows you to use with to create a GUI and containers Events , Threads , Loops & Sleeps have been improved. It's now possible to run background tasks (such as a download) and update the GUI safely Command line arguments : appJar now supports command line arguments for logging and internationalisation as well as help & version information Internationalisation is now greatly improved - nearly everything supports multiple languages ScrollPanes & Grids greatly improved Much more friendly license Issues Resolved: #249 - Can now set a parent for dialogs so that if they are launched from a SubWindow they behave properly #248 - Can now add icons and iconButtons using inbuilt icon set #246 - Can now hide titles on labelFrames #243 - Fixed bug in ToggleFrames #241 - Notes on installing on linux #234 - Support for ContextManagers throughout appJar #228 - appJar prevents you from creating more than one gui at a time #226 - fixed issues on file/directory entries #223 - fixed issues with sound import #217 - Fixed issues with removing BG images #216 - Improvements to integrated testing #215 - Changed licensing #213 - Validation entries improved in Internationalisation #212 - Creating an empty Tooltip now doesn't create anything #211 - Logging now logs line number & function name #209 - Additional testing for ScrollPanes & Grids #207 - Now possible to change the title and anchor of a LabelFrame #206 - New method for pausing functions when stopping infinite loops #205 - Now possible to select a disabled item in an OptionBox #204 - appJar now supports Command line arguments #203 - updated docs on LabelFrames #202 - functions now provided to get or clear all values of a selected widget type #200 - Switched Grid to use a ScrollPane & changed ScrollPane to use AutoScrollbars #196 - Resolved issue with configuring ScrolledTextAreas #189 - More work on ttk #177 - setLocation can now position windows in the center of the screen #162 - PhotoImage objects can now be passed directly when adding/setting ImageData #132 - Now possible to Delete and Rename OptionBox items. #120 - Improvements to events & introduction of threading #71 - More work on Internationalisation - now supports Images, LabelFrames, ToggleFrames, TabbedFrames, Properties, Grids, Toolbars, Tooltips, SubWindows, PagedWindows, SplashScreens & Titles #69 - Changes to TextAreas - now, lines wrap on spaces & setTextArea() now appends to the text Version 0.07 New widgets: GoogleMaps - a widget to show a GoogleMap tile & control widgets, ImageMaps - clickable ImageMap with linked functions, FileEntries - Entries linked with File/Directory dialogs Widget enhancements: Pinnable Toolbars , SelectableLabels , better Tooltips , NamedCheckBoxes & settable ListBoxes Update to event model and documentation - now clearer how to perform different actions, and function names updated Switched to Python's logging feature Issues Resolved: #192 - Fixed PNG image support in python 2.7 - specifically for toolbars #189 - VERY basic support for ttk #186 - Changes to Unicode support #185 - All add functions now return the widget #184 - Groupable List Boxes #182 - Added a link to source for GoogleMaps #181 - Disabling toolbars will also disable a pinned icon #180 - SlowActions #176 - Fixed issue with placing container in containers #173 - New functions to Set ListBoxes #161 - NamedCheckBoxes #148 - Improved support for MouseOver Events #151 & #158 - Some fixes to Grid Widget #138 - Can now register a Change Event on DatePicker #137 - File Entries #136 - Simple GoogleMaps widget #135 - A clickable Image Map #133 - Improvements to Tooltips #124 - Switched to Python's logging feature #101 - More work implementing Drag n'Drop #73 - Toolbars are now pinnable #59 - SelectableLabels #7 - Can now Set Foreground across the whole GUI Version 0.061 Issues Resolved: #154 - Fixed bug with AutoEntry not showing drop-down in right position, when placed in a container Version 0.06 New widgets: MicroBit , Validation Entries Widget enhancements: Can now set some rules for entries New documentation: packaging , special characters , events , drag'n drop Work on events: stopping event propagation , drag/over events , drag'n drop Issues Resolved: #143 - Fixed bug with setting defaults on AutoEntries #142 - Finished documentation for popups #130 - Documented how to use special characters #123 - New features for setting entries - max length, auto uppercase/lowercase, validation #119 - MicroBit widget added #118 - dynamic library imports #117 - introduced documentation on packaging #116 - configurable trough increments for a scale #115 - fixed transparency in python 2.7 #114 - ability to stop events being propagated #112 - now possible to start with a subWindow (specified in go()) as well as hide() & show() main window #110 - can now configure the number of rows to show in an AutoEntry #108 - Fixed issue with modal SubWindows #106 - Function to add an image button #102 - Updates to drag/over events #103 - Can now manage event calling when widgets change #101 - Drag n'Drop beta support for dnd between applications #92 - Function to get all entries #75 - Fix to destroySubWindow #46 - Added version details to about box #42 - Added functionality to change TickOptionBoxes #33 - Added convenience function to setTreeColours Version 0.052 Issues Resolved: #114 - ability to stop functions being called when a set method is activated Version 0.051 Issues Resolved: #109 - Labelled Auto Entry, contributed by jacobthetechy Version 0.05 Open Container - implemented issue #83 , can now reopen a container, perform operations on it, and close it Changed disable entry to readonly, allows entries to be copied ( #86 ) Images now support raw image data Setters now call any registered functions Rewrite of Meters , proper inheritance, all use gradated fill, Dual/Split Meter swapped ( #65 ) Rewrite of ScrollPane , multi-platform scrolling... Added functions to change the bg/fg of ListBox items ( #97 ) Issues Resolved: #101 & #103 - updates to documentation #99 - ability to create empty containers #97 - ability to set bg/fg colour of list items #94 - basic support for MatPlotLib #90 - raw image data #89 - minimum speed for animated image #88 - preload mouse over images #86 - disabled entry now readonly #85 - setters now call function (if available) #83 - can now reopen container #65 - Meter rewrite #34 / #35 - ScrollPane rewrite Version 0.042 Issues Resolved: #95 - fixed issue launching ShowCase under Python 2 (removed icons) #93 - fixed issue with numDialog/textDialog under python 2 Version 0.041 Continuous Integration - added landscape.io to monitor code quality Reload Image - function to force a reload of an image, bypassing the cache (issue #87 ) Minor fixes based off landscape report Issues Resolved: #87 - reloadImage() #84 - Removed requirement for appJar icon in Windows Version 0.04 Internationalisation - it's now possible to support multiple languages, by adding simple config files Splashscreen - a simple splashscreen is now available AutoCompletion EntryBox - added a new widget, giving autocompletion in EntryBoxes Function on change in ListBox - now possible to call a function each time a ListBox changes Python 3.6 Support - now supports python3.6 - fixed issue with renamed idelib files Continuous Integration - now uses Travis-CI and Coveralls to check for errors on each commit Updated documentation: Rearrangement of navigation bar, new pages for new features, minor modifications Issues Resolved: #81 - now allows negative numbers/decimals to be entered correctly in NumericEntries #80 - now support Python 3.6 #78 - fixed typo in documentation #74 - SplashScreen #72 - Unit testing #71 - Internationalisation #70 - AutoComplete EntryBox","title":"Change-Log"},{"location":"whatsNew/#change-log","text":"","title":"Change-Log"},{"location":"whatsNew/#version-094","text":"New Example of how to create a stylesheet - #481 New Function to move widgets - #477 Added ability to change the text shown in a checkBox - #578 Added can now change the BG colour of toolbars - #577 Added Paned Frames support a change function - #561 Added All labels can be cleared with a single function call - #570 Added File Entry supports choosing a save file - #539 Added Option to display navigation bar in MatPlotLib - #529 Added Additional properties on Tables - #517 Added Can now configure the bg colour of check boxes in properties widgets - #514 Added Can now set the sash position on PanedFrames - #504 Added Multiple files allowed in open file boxes - #479 Added Option to add multiple action buttons and align horizontally/vertically in Tables - #475 Added Can now add tabs before/after existing tabs - #473 Added When updating a textArea you can now configure it to replace any existing text - #472 Added New property to change the statusbar font - #463 Added Can now create trees with xml objects and show attributes - #457 Added Option to set wrap parameter on Tables - #458 Added Introduced new container properties rowspan/colspan - #55 Improved removed references to rwbatools in example code - #569 Improved getAllInputs() now has a parameter includeEmptyInputs to include any empty input fields - #563 Improved Buttons now align images/icons correctly in ttk - #560 Improved Changed log level of setSize - #543 Improved Improved docs on widget positioning - #524 Improved Improved docs on stopping the GUI - #521 Improved Improved docs on pip installation - #519 Improved Resolved deprecated import on MatPlotLib - #518 Improved Removed imports from __init__.py file - #505 Improved Scales and other widgets can now have their state changed when in ttk mode - #465 Improved Better change log? - #219 Improved appJar now uses tkinter style config functions - #49 Fixed Setting size is now case insensitive: GUI Options - #580 Fixed Fixed typo in documentation page: advancedLoops - #564 Fixed python2.6 now runs, after removing dependency on argsparse - #547 Fixed Resolved issues sometimes changing bg/fg in ttk - #536 Fixed Resolved issues with changing radiobutton type in ttk - #534 Fixed Scrolling to the end of an entry in ttk - #538 Fixed All start container functions now return the container - #523 Fixed Menu check boxes now toggle using the keyboard shortcut, and also work properly on Mac - #512 Fixed Menu shortcuts improved, to handle more cases - #499 Fixed Issue where blocking subwindows wouldn't work - #491 Fixed Bug where Labelled widgets weren't destroyed properly - #489 Fixed Issue with deleting rows on tables - #482 Fixed Issue where opening containers was not returning the container - #478 Fixed Refactored Remove/Empty/Destroy containers - #75 , #339 , #462 Fixed Issue with setting parent of message boxes - #461 Removed Deprecated .panedFrameVertical() , you should now call .panedFrame(vertical=True) - #504","title":"Version 0.94"},{"location":"whatsNew/#version-093","text":"NEW: #453 - SubWindows refactored #450 - Can now set the character used to disable options in OptionBoxes #449 - updateListBox now has a callFunction flag #447 - Canvases now support clickable maps #446 - Setting listboxes now has better error checking #445 - Ability to keep windows on top #442 - SpinBoxes now call changeFunction when changed manually #437 - Page discussing how to manage multiple pages #436 - TextAreas can now be programmatically cleared and set while disabled #435 - Messages have better documentation and a function to set the aspect ratio #429 - TabbedFrames & PagedWindows now use FrameStacks #425 - Updated docs on geometry #422 - TickOptionBoxes now return their name when changed #421 - SelectableLabels now allow alignment setting #415 - Disable Entry now disables all of a file/directory entry #402 - Now possible to register a function to call once the GUI starts up #377 - Auto-Labelled Widgets now have configurable labels #345 - New container: FrameStack #339 - Functions to remove toolbars and statusbars #333 - Can now fully hide/show/delete tabs #295 - New function to set the BG of the label in a validationEntry #69 - Basic functions for tagging , searching and changing fonts in text areas FIXED: #433 - Resolved issue with setting properties in Python2","title":"Version 0.93"},{"location":"whatsNew/#version-092","text":"FIXED: #413 - Fixed issue with .refreshDbTable() in DB tables #410 - Fixed issue with button text when adding tables #409 - Fixed issue with topLevel binds on mouse down events #408 - Changed logLevel for some widget removal","title":"Version 0.92"},{"location":"whatsNew/#version-091","text":"NEW: Grids have been renamed to Tables! appJar logging now uses its own logLevel of TRACE #398 - Documented .pyw files #395 - Option to fast stop a GUI #391 - Updated error messages on _configWidget #390 - New simpleAppJar functions for statusbar #388 - Can now specify the cell style of tables #373 - Added function to get the BG colour of a widget #347 , #360 , 374 & #375 - Right Click Menu updates #369 - Hide scrollbars in ScollPane #367 - Update to logging - all appJar logging now done at a TRACE level, below DEBUG #366 - Better error reporting on AutoEntries #340 - appJar properties now fully documented & tested #335 - No longer necessary to receive a parameter in functions linked to appJar widgets #329 - Starting separator removed from Windows Right-click Menus #328 - New Accessibility Widget introduced to configure colours & fonts #301 - Updated layout parameters , can now pass previous & next for the row parameter, to make it easier to position widgets #29 - Updated sound documentation to discuss blocking sounds FIXED: #379 - PieChart % fix in Python 2.7","title":"Version 0.91"},{"location":"whatsNew/#version-09","text":"Introduction of alternative widget access functions ( #235 ) - now possible to ADD , SET & GET widgets by just using their name Introduction of alternative GUI properties ( #340 ) - now possible to GET/SET properties with special property functions Introduction of appJar settings - can now save/load GUI state to/from file Big improvements to grids - can add/remove/replace rows/columns, can sort data, can access a right-click menu, can connect to an sqlite database More ttk improvements - grouped widgets now work, introduced external themes Issues Resolved: #356 - Updated documentation - widgets page split into input & output pages #344 - labels now display the title when no text is provided, instead of an empty label #343 - new parameter for appJar constructor: showIcon allows the icon to be ignored when running Windows #340 - introduced GUI properties for most settings #339 - new functions to remove toolbars and statusbars #335 - when setting functions for events, if no parameter is present in the function, no parameter will be passed by the event #333 - started work on hide/show/delete tabs #325 - fixed issue with right-click menus #324 - fixed issue with losing file/directory Entry values #317 - implemented fonts on tabbed frames #316 - can now display compound images and text in buttons #309 - cleaned up handling of fonts #303 - added functions to bind/unbind multiple keys to a function #298 - fixed issue in menubar shortcuts where numeric shortcuts didn't work #296 - two new widgets introduced turtle and canvas #294 & #292 - fixes on entries : better handle arrow key presses on mac, defaults work better on secret entries & file/directory entries #290 - fixed issue showing AutoEntries in subWindows #289 - new functions to change list in AutoEntries #288 - fixed issue showing dialogs in subWindows #286 - added new threaded callback , contributed by @mpmc #284 - new dialogs for strings, integers & floats #283 - questionBox now returns Booleans instead of yes/no #281 - resolved issues with threads #279 - tidied up remove all widgets - now leaves GUI looking better #271 , #266 , #255 & #232 - Grid improvements #242 , #259 , #267 - work on MatPLotLib now support multiple plot types, and retaining some settings #250 - Can now add compound images - images with a built in label #236 - appJar can now save GUI settings and load them again #233 - NumericEntries return None when empty #218 - Can no longer set NumericEntries to Strings","title":"Version 0.9"},{"location":"whatsNew/#version-0821","text":"Issues Resolved: #275 - maps fix","title":"Version 0.82.1"},{"location":"whatsNew/#version-082","text":"Issues Resolved: #189 - some tweaks to ttk support Fixes to documentation","title":"Version 0.82"},{"location":"whatsNew/#version-08","text":"Changed versioning - PyPi difficulties, combined with close to a 1.0 release... Create a GUI in TWO lines using context managers - appJar now allows you to use with to create a GUI and containers Events , Threads , Loops & Sleeps have been improved. It's now possible to run background tasks (such as a download) and update the GUI safely Command line arguments : appJar now supports command line arguments for logging and internationalisation as well as help & version information Internationalisation is now greatly improved - nearly everything supports multiple languages ScrollPanes & Grids greatly improved Much more friendly license Issues Resolved: #249 - Can now set a parent for dialogs so that if they are launched from a SubWindow they behave properly #248 - Can now add icons and iconButtons using inbuilt icon set #246 - Can now hide titles on labelFrames #243 - Fixed bug in ToggleFrames #241 - Notes on installing on linux #234 - Support for ContextManagers throughout appJar #228 - appJar prevents you from creating more than one gui at a time #226 - fixed issues on file/directory entries #223 - fixed issues with sound import #217 - Fixed issues with removing BG images #216 - Improvements to integrated testing #215 - Changed licensing #213 - Validation entries improved in Internationalisation #212 - Creating an empty Tooltip now doesn't create anything #211 - Logging now logs line number & function name #209 - Additional testing for ScrollPanes & Grids #207 - Now possible to change the title and anchor of a LabelFrame #206 - New method for pausing functions when stopping infinite loops #205 - Now possible to select a disabled item in an OptionBox #204 - appJar now supports Command line arguments #203 - updated docs on LabelFrames #202 - functions now provided to get or clear all values of a selected widget type #200 - Switched Grid to use a ScrollPane & changed ScrollPane to use AutoScrollbars #196 - Resolved issue with configuring ScrolledTextAreas #189 - More work on ttk #177 - setLocation can now position windows in the center of the screen #162 - PhotoImage objects can now be passed directly when adding/setting ImageData #132 - Now possible to Delete and Rename OptionBox items. #120 - Improvements to events & introduction of threading #71 - More work on Internationalisation - now supports Images, LabelFrames, ToggleFrames, TabbedFrames, Properties, Grids, Toolbars, Tooltips, SubWindows, PagedWindows, SplashScreens & Titles #69 - Changes to TextAreas - now, lines wrap on spaces & setTextArea() now appends to the text","title":"Version 0.8"},{"location":"whatsNew/#version-007","text":"New widgets: GoogleMaps - a widget to show a GoogleMap tile & control widgets, ImageMaps - clickable ImageMap with linked functions, FileEntries - Entries linked with File/Directory dialogs Widget enhancements: Pinnable Toolbars , SelectableLabels , better Tooltips , NamedCheckBoxes & settable ListBoxes Update to event model and documentation - now clearer how to perform different actions, and function names updated Switched to Python's logging feature Issues Resolved: #192 - Fixed PNG image support in python 2.7 - specifically for toolbars #189 - VERY basic support for ttk #186 - Changes to Unicode support #185 - All add functions now return the widget #184 - Groupable List Boxes #182 - Added a link to source for GoogleMaps #181 - Disabling toolbars will also disable a pinned icon #180 - SlowActions #176 - Fixed issue with placing container in containers #173 - New functions to Set ListBoxes #161 - NamedCheckBoxes #148 - Improved support for MouseOver Events #151 & #158 - Some fixes to Grid Widget #138 - Can now register a Change Event on DatePicker #137 - File Entries #136 - Simple GoogleMaps widget #135 - A clickable Image Map #133 - Improvements to Tooltips #124 - Switched to Python's logging feature #101 - More work implementing Drag n'Drop #73 - Toolbars are now pinnable #59 - SelectableLabels #7 - Can now Set Foreground across the whole GUI","title":"Version 0.07"},{"location":"whatsNew/#version-0061","text":"Issues Resolved: #154 - Fixed bug with AutoEntry not showing drop-down in right position, when placed in a container","title":"Version 0.061"},{"location":"whatsNew/#version-006","text":"New widgets: MicroBit , Validation Entries Widget enhancements: Can now set some rules for entries New documentation: packaging , special characters , events , drag'n drop Work on events: stopping event propagation , drag/over events , drag'n drop Issues Resolved: #143 - Fixed bug with setting defaults on AutoEntries #142 - Finished documentation for popups #130 - Documented how to use special characters #123 - New features for setting entries - max length, auto uppercase/lowercase, validation #119 - MicroBit widget added #118 - dynamic library imports #117 - introduced documentation on packaging #116 - configurable trough increments for a scale #115 - fixed transparency in python 2.7 #114 - ability to stop events being propagated #112 - now possible to start with a subWindow (specified in go()) as well as hide() & show() main window #110 - can now configure the number of rows to show in an AutoEntry #108 - Fixed issue with modal SubWindows #106 - Function to add an image button #102 - Updates to drag/over events #103 - Can now manage event calling when widgets change #101 - Drag n'Drop beta support for dnd between applications #92 - Function to get all entries #75 - Fix to destroySubWindow #46 - Added version details to about box #42 - Added functionality to change TickOptionBoxes #33 - Added convenience function to setTreeColours","title":"Version 0.06"},{"location":"whatsNew/#version-0052","text":"Issues Resolved: #114 - ability to stop functions being called when a set method is activated","title":"Version 0.052"},{"location":"whatsNew/#version-0051","text":"Issues Resolved: #109 - Labelled Auto Entry, contributed by jacobthetechy","title":"Version 0.051"},{"location":"whatsNew/#version-005","text":"Open Container - implemented issue #83 , can now reopen a container, perform operations on it, and close it Changed disable entry to readonly, allows entries to be copied ( #86 ) Images now support raw image data Setters now call any registered functions Rewrite of Meters , proper inheritance, all use gradated fill, Dual/Split Meter swapped ( #65 ) Rewrite of ScrollPane , multi-platform scrolling... Added functions to change the bg/fg of ListBox items ( #97 ) Issues Resolved: #101 & #103 - updates to documentation #99 - ability to create empty containers #97 - ability to set bg/fg colour of list items #94 - basic support for MatPlotLib #90 - raw image data #89 - minimum speed for animated image #88 - preload mouse over images #86 - disabled entry now readonly #85 - setters now call function (if available) #83 - can now reopen container #65 - Meter rewrite #34 / #35 - ScrollPane rewrite","title":"Version 0.05"},{"location":"whatsNew/#version-0042","text":"Issues Resolved: #95 - fixed issue launching ShowCase under Python 2 (removed icons) #93 - fixed issue with numDialog/textDialog under python 2","title":"Version 0.042"},{"location":"whatsNew/#version-0041","text":"Continuous Integration - added landscape.io to monitor code quality Reload Image - function to force a reload of an image, bypassing the cache (issue #87 ) Minor fixes based off landscape report Issues Resolved: #87 - reloadImage() #84 - Removed requirement for appJar icon in Windows","title":"Version 0.041"},{"location":"whatsNew/#version-004","text":"Internationalisation - it's now possible to support multiple languages, by adding simple config files Splashscreen - a simple splashscreen is now available AutoCompletion EntryBox - added a new widget, giving autocompletion in EntryBoxes Function on change in ListBox - now possible to call a function each time a ListBox changes Python 3.6 Support - now supports python3.6 - fixed issue with renamed idelib files Continuous Integration - now uses Travis-CI and Coveralls to check for errors on each commit Updated documentation: Rearrangement of navigation bar, new pages for new features, minor modifications Issues Resolved: #81 - now allows negative numbers/decimals to be entered correctly in NumericEntries #80 - now support Python 3.6 #78 - fixed typo in documentation #74 - SplashScreen #72 - Unit testing #71 - Internationalisation #70 - AutoComplete EntryBox","title":"Version 0.04"},{"location":"examples/kanban/","text":"Kanban Demo A common interface is a to-do list , made up of multiple columns, with the ability to add items to the first column, then move items across the columns. We can create something similar in appJar by laying out labels in columns. The Layout We'll start by creating the GUI with three labels across the top: from appJar import gui ttl = ('Backlog', 'In Progress', 'Done') with gui(\"Kanban Demo\", \"450x200\", bg='grey', sticky='new', font=20) as app: for pos in range(len(ttl)): app.label(ttl[pos], pos=(0, pos), bg='white', width=12, stretch='column') Then, we'll add three empty frames and a button, underneath: from appJar import gui from random import choice ttl = ('Backlog', 'In Progress', 'Done') def genNewLbl(): with app.frame(ttl[0]): text = ''.join(choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ') for c in range(8)) app.label(text, bg=app.getRandomColour()) with gui(\"Kanban Demo\", \"450x200\", bg='grey', sticky='new', font=20) as app: for pos in range(len(ttl)): app.label(ttl[pos], pos=(0, pos), bg='white', width=12, stretch='column') app.stretch = 'both' with app.frame(ttl[pos], row=1, column=pos, sticky='new'): pass app.button(\"NEW LABEL\", genNewLbl, colspan=3, sticky='s', stretch='column', font=16) Moving the Labels Next we need to make the labels interactive, so that when they are clicked, they are moved to the next column. We'll define a function to move a label to the named frame: def move(lName, fName): # move the label to the new frame with app.frame(fName): app.moveLabel(lName) Now, we just need some way for each label to know it's destination frame. We'll create three wrapper functions to do this: def move1(lName): move(lName, ttl[1]) def move2(lName): move(lName, ttl[2]) def trash(lName): app.removeLabel(lName) Then, we update the function that generates labels to give each one a submit function, that moves it to the next column: def genNewLbl(): with app.frame(ttl[0]): text = ''.join(choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ') for c in range(8)) app.label(text, bg=app.getRandomColour(), submit=move1) # add submit function And update the move function so that it changes a label's submit function when it is moved: def move(lName, fName): # move the label to the new frame with app.frame(fName): app.moveLabel(lName) # change the label's submit function if fName == ttl[1]: app.label(lName, submit=move2) else: app.label(lName, submit=trash) And that's it, we have a way of moving tasks from one column to the next...","title":"Kanban/To Do"},{"location":"examples/kanban/#kanban-demo","text":"A common interface is a to-do list , made up of multiple columns, with the ability to add items to the first column, then move items across the columns. We can create something similar in appJar by laying out labels in columns.","title":"Kanban Demo"},{"location":"examples/kanban/#the-layout","text":"We'll start by creating the GUI with three labels across the top: from appJar import gui ttl = ('Backlog', 'In Progress', 'Done') with gui(\"Kanban Demo\", \"450x200\", bg='grey', sticky='new', font=20) as app: for pos in range(len(ttl)): app.label(ttl[pos], pos=(0, pos), bg='white', width=12, stretch='column') Then, we'll add three empty frames and a button, underneath: from appJar import gui from random import choice ttl = ('Backlog', 'In Progress', 'Done') def genNewLbl(): with app.frame(ttl[0]): text = ''.join(choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ') for c in range(8)) app.label(text, bg=app.getRandomColour()) with gui(\"Kanban Demo\", \"450x200\", bg='grey', sticky='new', font=20) as app: for pos in range(len(ttl)): app.label(ttl[pos], pos=(0, pos), bg='white', width=12, stretch='column') app.stretch = 'both' with app.frame(ttl[pos], row=1, column=pos, sticky='new'): pass app.button(\"NEW LABEL\", genNewLbl, colspan=3, sticky='s', stretch='column', font=16)","title":"The Layout"},{"location":"examples/kanban/#moving-the-labels","text":"Next we need to make the labels interactive, so that when they are clicked, they are moved to the next column. We'll define a function to move a label to the named frame: def move(lName, fName): # move the label to the new frame with app.frame(fName): app.moveLabel(lName) Now, we just need some way for each label to know it's destination frame. We'll create three wrapper functions to do this: def move1(lName): move(lName, ttl[1]) def move2(lName): move(lName, ttl[2]) def trash(lName): app.removeLabel(lName) Then, we update the function that generates labels to give each one a submit function, that moves it to the next column: def genNewLbl(): with app.frame(ttl[0]): text = ''.join(choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ') for c in range(8)) app.label(text, bg=app.getRandomColour(), submit=move1) # add submit function And update the move function so that it changes a label's submit function when it is moved: def move(lName, fName): # move the label to the new frame with app.frame(fName): app.moveLabel(lName) # change the label's submit function if fName == ttl[1]: app.label(lName, submit=move2) else: app.label(lName, submit=trash) And that's it, we have a way of moving tasks from one column to the next...","title":"Moving the Labels"},{"location":"examples/minecraft/","text":"Minecraft You can now see a version of this article in print! Check out the MagPi, issue 58 . Linking appJar with Minecraft on the Raspberry Pi is super easy! Simply import the Minecraft library and appJar library and have appJar call Minecraft functions... Chat First, let's set up a simple chat entry box. from appJar import gui from mcpi.minecraft import Minecraft # function to send messages to minecraft server def sendMsg(btn): msg = app.getEntry(\"Chat\") mc.postToChat(msg) mc = Minecraft.create() # minecraft connection # main GUI block app = gui(\"Minecraft\") # GUI app.addLabelEntry(\"Chat\", 0, ) app.addButton(\"Send\", sendMsg, 0, 1) app.go() You can jazz this up a bit, by setting the focus and linking the key to submit chat messages, oh and set the location so it doesn't appear under the Minecraft window.. # put this in the main GUI block app.setEntryFocus(\"Chat\") app.setEntryFunction(\"Chat\", sendMsg) app.setLocation(100,100) Movement Next, let's add some movement controls... #function to move the minecraft character def move(btn): x,y,z = mc.player.getPos() if btn == \"LEFT\": x -= 1 elif btn == \"RIGHT\": x += 1 elif btn == \"FORWARD\": z -= 1 elif btn == \"BACKWARD\": z += 1 elif btn == \"JUMP\": y += 1 z -= 1 mc.player.setPos(x, y, z) # put this in the main GUI block app.startLabelFrame(\"Move Me\", colspan=2) app.setSticky(\"EW\") app.addButton(\"FORWARD\", move) app.addButtons([\"LEFT\", \"JUMP\", \"RIGHT\"], move) app.addButton(\"BACKWARD\", move) app.stopLabelFrame() You can jazz this up to, by linking keys up to the functions... # add this to the main GUI block app.bindKey(\"<Left>\", move) app.bindKey(\"<Right>\", move) app.bindKey(\"<Up>\", move) app.bindKey(\"<Down>\", move) app.bindKey(\"<Space>\", move) # then change the move function to register both events # if btn == \"LEFT\" or btn == \"<Left>\" ... and so on Status Another cool feature, is a status bar that tells us where we're at... #function to set the status bar def getLocation(): x,y,z = mc.player.getPos() app.setStatusbar(\"X: \"+ str(round(x,3)), 0) app.setStatusbar(\"Y: \"+ str(round(y,3)), 1) app.setStatusbar(\"Z: \"+ str(round(z,3)), 2) # put this in the main GUI block app.addStatusbar(fields=3) # call the update function every second app.registerEvent(getLocation) Dropping blocks Next, let's add the ability to drop blocks. # function to drop a block just in front def drop(btn): playerBlock = app.getOptionBox(\"Block\") blockId = BLOCKS[playerBlock] x,y,z = mc.player.getPos() mc.setBlock(x, y+1, z-1, blockId) # put this in the main GUI block app.addLabelOptionBox(\"Block\", blockNames, colspan=2) app.addButton(\"Drop\", drop, colspan=2) The issue we have is building a dictionary of block names linked to block IDs. You can try this one out, or make your own... # put this near the top of your code BLOCKS={ \"AIR\":0, \"STONE\":1, \"GRASS\":2, \"DIRT\":3, \"COBBLESTONE\":4, \"WOOD_PLANKS\":5, \"SAPLING\":6, \"BEDROCK\":7, \"WATER_FLOWING\":8, \"WATER\":8, \"WATER_STATIONARY\":9, \"LAVA_FLOWING\":10, \"LAVA\":10, \"LAVA_STATIONARY\":11, \"SAND\":12, \"GRAVEL\":13, \"GOLD_ORE\":14, \"IRON_ORE\":15, \"COAL_ORE\":16, \"WOOD\":17, \"LEAVES\":18, \"GLASS\":20, \"LAPIS_LAZULI_ORE\":21, \"LAPIS_LAZULI_BLOCK\":22, \"SANDSTONE\":24, \"BED\":26, \"COBWEB\":30, \"GRASS_TALL\":31, \"WOOL\":35, \"FLOWER_YELLOW\":37, \"FLOWER_CYAN\":38, \"MUSHROOM_BROWN\":39, \"MUSHROOM_RED\":40, \"GOLD_BLOCK\":41, \"IRON_BLOCK\":42, \"STONE_SLAB_DOUBLE\":43, \"STONE_SLAB\":44, \"BRICK_BLOCK\":45, \"TNT\":46, \"BOOKSHELF\":47, \"MOSS_STONE\":48, \"OBSIDIAN\":49, \"TORCH\":50, \"FIRE\":51, \"STAIRS_WOOD\":53, \"CHEST\":54, \"DIAMOND_ORE\":56, \"DIAMOND_BLOCK\":57, \"CRAFTING_TABLE\":58, \"FARMLAND\":60, \"FURNACE_INACTIVE\":61, \"FURNACE_ACTIVE\":62, \"DOOR_WOOD\":64, \"LADDER\":65, \"STAIRS_COBBLESTONE\":67, \"DOOR_IRON\":71, \"REDSTONE_ORE\":73, \"SNOW\":78, \"ICE\":79, \"SNOW_BLOCK\":80, \"CACTUS\":81, \"CLAY\":82, \"SUGAR_CANE\":83, \"FENCE\":85, \"GLOWSTONE_BLOCK\":89, \"BEDROCK_INVISIBLE\":95, \"STONE_BRICK\":98, \"GLASS_PANE\":102, \"MELON\":103, \"FENCE_GATE\":107, \"GLOWING_OBSIDIAN\":246, \"NETHER_REACTOR_CORE\":247 } blockNames=list(BLOCKS.keys()) blockNames.sort() Anything from the menu? Finally, let's add a menu. Menus work just like buttons - when you click them, they simply call a function. So, we're going to create a function for the menus, and have it operate the camera and create/restore checkpoints: # put this near the top of your code def clickMenu(choice): if choice == \"Create\": mc.saveCheckpoint() app.infoBox(\"Save\", \"Checkpoint saved.\") elif choice == \"Restore\": if app.yesNoBox(\"Restore\", \"Are you sure?\"): mc.restoreCheckpoint() elif choice == \"Normal\": mc.camera.setNormal() elif choice == \"Fixed\": mc.camera.setFixed() elif choice == \"Follow\": mc.camera.setFollow() Then we add the code to our main GUI block, to show the menus: # put this in the main GUI block app.addMenuList(\"Checkpoint\", [\"Create\", \"Restore\"], clickMenu) app.addMenuList(\"Camera\", [\"Normal\", \"Fixed\", \"Follow\"], clickMenu)","title":"Raspberry Pi Minecraft"},{"location":"examples/minecraft/#minecraft","text":"You can now see a version of this article in print! Check out the MagPi, issue 58 . Linking appJar with Minecraft on the Raspberry Pi is super easy! Simply import the Minecraft library and appJar library and have appJar call Minecraft functions...","title":"Minecraft"},{"location":"examples/minecraft/#chat","text":"First, let's set up a simple chat entry box. from appJar import gui from mcpi.minecraft import Minecraft # function to send messages to minecraft server def sendMsg(btn): msg = app.getEntry(\"Chat\") mc.postToChat(msg) mc = Minecraft.create() # minecraft connection # main GUI block app = gui(\"Minecraft\") # GUI app.addLabelEntry(\"Chat\", 0, ) app.addButton(\"Send\", sendMsg, 0, 1) app.go() You can jazz this up a bit, by setting the focus and linking the key to submit chat messages, oh and set the location so it doesn't appear under the Minecraft window.. # put this in the main GUI block app.setEntryFocus(\"Chat\") app.setEntryFunction(\"Chat\", sendMsg) app.setLocation(100,100)","title":"Chat"},{"location":"examples/minecraft/#movement","text":"Next, let's add some movement controls... #function to move the minecraft character def move(btn): x,y,z = mc.player.getPos() if btn == \"LEFT\": x -= 1 elif btn == \"RIGHT\": x += 1 elif btn == \"FORWARD\": z -= 1 elif btn == \"BACKWARD\": z += 1 elif btn == \"JUMP\": y += 1 z -= 1 mc.player.setPos(x, y, z) # put this in the main GUI block app.startLabelFrame(\"Move Me\", colspan=2) app.setSticky(\"EW\") app.addButton(\"FORWARD\", move) app.addButtons([\"LEFT\", \"JUMP\", \"RIGHT\"], move) app.addButton(\"BACKWARD\", move) app.stopLabelFrame() You can jazz this up to, by linking keys up to the functions... # add this to the main GUI block app.bindKey(\"<Left>\", move) app.bindKey(\"<Right>\", move) app.bindKey(\"<Up>\", move) app.bindKey(\"<Down>\", move) app.bindKey(\"<Space>\", move) # then change the move function to register both events # if btn == \"LEFT\" or btn == \"<Left>\" ... and so on","title":"Movement"},{"location":"examples/minecraft/#status","text":"Another cool feature, is a status bar that tells us where we're at... #function to set the status bar def getLocation(): x,y,z = mc.player.getPos() app.setStatusbar(\"X: \"+ str(round(x,3)), 0) app.setStatusbar(\"Y: \"+ str(round(y,3)), 1) app.setStatusbar(\"Z: \"+ str(round(z,3)), 2) # put this in the main GUI block app.addStatusbar(fields=3) # call the update function every second app.registerEvent(getLocation)","title":"Status"},{"location":"examples/minecraft/#dropping-blocks","text":"Next, let's add the ability to drop blocks. # function to drop a block just in front def drop(btn): playerBlock = app.getOptionBox(\"Block\") blockId = BLOCKS[playerBlock] x,y,z = mc.player.getPos() mc.setBlock(x, y+1, z-1, blockId) # put this in the main GUI block app.addLabelOptionBox(\"Block\", blockNames, colspan=2) app.addButton(\"Drop\", drop, colspan=2) The issue we have is building a dictionary of block names linked to block IDs. You can try this one out, or make your own... # put this near the top of your code BLOCKS={ \"AIR\":0, \"STONE\":1, \"GRASS\":2, \"DIRT\":3, \"COBBLESTONE\":4, \"WOOD_PLANKS\":5, \"SAPLING\":6, \"BEDROCK\":7, \"WATER_FLOWING\":8, \"WATER\":8, \"WATER_STATIONARY\":9, \"LAVA_FLOWING\":10, \"LAVA\":10, \"LAVA_STATIONARY\":11, \"SAND\":12, \"GRAVEL\":13, \"GOLD_ORE\":14, \"IRON_ORE\":15, \"COAL_ORE\":16, \"WOOD\":17, \"LEAVES\":18, \"GLASS\":20, \"LAPIS_LAZULI_ORE\":21, \"LAPIS_LAZULI_BLOCK\":22, \"SANDSTONE\":24, \"BED\":26, \"COBWEB\":30, \"GRASS_TALL\":31, \"WOOL\":35, \"FLOWER_YELLOW\":37, \"FLOWER_CYAN\":38, \"MUSHROOM_BROWN\":39, \"MUSHROOM_RED\":40, \"GOLD_BLOCK\":41, \"IRON_BLOCK\":42, \"STONE_SLAB_DOUBLE\":43, \"STONE_SLAB\":44, \"BRICK_BLOCK\":45, \"TNT\":46, \"BOOKSHELF\":47, \"MOSS_STONE\":48, \"OBSIDIAN\":49, \"TORCH\":50, \"FIRE\":51, \"STAIRS_WOOD\":53, \"CHEST\":54, \"DIAMOND_ORE\":56, \"DIAMOND_BLOCK\":57, \"CRAFTING_TABLE\":58, \"FARMLAND\":60, \"FURNACE_INACTIVE\":61, \"FURNACE_ACTIVE\":62, \"DOOR_WOOD\":64, \"LADDER\":65, \"STAIRS_COBBLESTONE\":67, \"DOOR_IRON\":71, \"REDSTONE_ORE\":73, \"SNOW\":78, \"ICE\":79, \"SNOW_BLOCK\":80, \"CACTUS\":81, \"CLAY\":82, \"SUGAR_CANE\":83, \"FENCE\":85, \"GLOWSTONE_BLOCK\":89, \"BEDROCK_INVISIBLE\":95, \"STONE_BRICK\":98, \"GLASS_PANE\":102, \"MELON\":103, \"FENCE_GATE\":107, \"GLOWING_OBSIDIAN\":246, \"NETHER_REACTOR_CORE\":247 } blockNames=list(BLOCKS.keys()) blockNames.sort()","title":"Dropping blocks"},{"location":"examples/minecraft/#anything-from-the-menu","text":"Finally, let's add a menu. Menus work just like buttons - when you click them, they simply call a function. So, we're going to create a function for the menus, and have it operate the camera and create/restore checkpoints: # put this near the top of your code def clickMenu(choice): if choice == \"Create\": mc.saveCheckpoint() app.infoBox(\"Save\", \"Checkpoint saved.\") elif choice == \"Restore\": if app.yesNoBox(\"Restore\", \"Are you sure?\"): mc.restoreCheckpoint() elif choice == \"Normal\": mc.camera.setNormal() elif choice == \"Fixed\": mc.camera.setFixed() elif choice == \"Follow\": mc.camera.setFollow() Then we add the code to our main GUI block, to show the menus: # put this in the main GUI block app.addMenuList(\"Checkpoint\", [\"Create\", \"Restore\"], clickMenu) app.addMenuList(\"Camera\", [\"Normal\", \"Fixed\", \"Follow\"], clickMenu)","title":"Anything from the menu?"},{"location":"examples/simple/","text":"Simple Examples Login Form Start off by importing the library and creating the gui from appJar import gui # create the GUI & set a title app = gui(\"Login Form\") # add labels & entries # in the correct row & column app.addLabel(\"userLab\", \"Username:\", 0, 0) app.addEntry(\"userEnt\", 0, 1) app.addLabel(\"passLab\", \"Password:\", 1, 0) app.addEntry(\"passEnt\", 1, 1) # start the GUI app.go() Next, add some buttons # these buttons call a *None* function - they don't do anything app.addButtons( [\"Submit\", \"Cancel\"], None, colspan=2) Then give the buttons a function to call # function to print out the name of the button pressed # followed by the contents of the two entry boxes def press(btnName): print(btnName) print app.getEntry(\"userEnt\") print app.getEntry(\"passEnt\") # changed this line to call a function app.addButtons( [\"Submit\", \"Cancel\"], press, colspan=2) Finally, program some logic into the function def press(btnName): if btnName == \"Cancel\": app.stop() if app.getEntry(\"userEnt\") == \"rjarvis\": if app.getEntry(\"passEnt\") == \"abc\": app.infoBox(\"Success\", \"Congratulations, you are logged in!\") else: app.errorBox(\"Failed login\", \"Invalid password\") else: app.errorBox(\"Failed login\", \"Invalid username\") Extension - add some enhancements app.addSecretEntry(\"passEnt\", 1, 1) app.setFocus(\"userEnt\") app.enableEnter(press) Full source code","title":"Simple Layout"},{"location":"examples/simple/#simple-examples","text":"","title":"Simple Examples"},{"location":"examples/simple/#login-form","text":"","title":"Login Form"},{"location":"examples/simple/#start-off-by-importing-the-library-and-creating-the-gui","text":"from appJar import gui # create the GUI & set a title app = gui(\"Login Form\") # add labels & entries # in the correct row & column app.addLabel(\"userLab\", \"Username:\", 0, 0) app.addEntry(\"userEnt\", 0, 1) app.addLabel(\"passLab\", \"Password:\", 1, 0) app.addEntry(\"passEnt\", 1, 1) # start the GUI app.go()","title":"Start off by importing the library and creating the gui"},{"location":"examples/simple/#next-add-some-buttons","text":"# these buttons call a *None* function - they don't do anything app.addButtons( [\"Submit\", \"Cancel\"], None, colspan=2)","title":"Next, add some buttons"},{"location":"examples/simple/#then-give-the-buttons-a-function-to-call","text":"# function to print out the name of the button pressed # followed by the contents of the two entry boxes def press(btnName): print(btnName) print app.getEntry(\"userEnt\") print app.getEntry(\"passEnt\") # changed this line to call a function app.addButtons( [\"Submit\", \"Cancel\"], press, colspan=2)","title":"Then give the buttons a function to call"},{"location":"examples/simple/#finally-program-some-logic-into-the-function","text":"def press(btnName): if btnName == \"Cancel\": app.stop() if app.getEntry(\"userEnt\") == \"rjarvis\": if app.getEntry(\"passEnt\") == \"abc\": app.infoBox(\"Success\", \"Congratulations, you are logged in!\") else: app.errorBox(\"Failed login\", \"Invalid password\") else: app.errorBox(\"Failed login\", \"Invalid username\")","title":"Finally, program some logic into the function"},{"location":"examples/simple/#extension-add-some-enhancements","text":"app.addSecretEntry(\"passEnt\", 1, 1) app.setFocus(\"userEnt\") app.enableEnter(press) Full source code","title":"Extension - add some enhancements"},{"location":"examples/stylesheets/","text":"Stylesheets One great idea we've seen recently is trying to replicate web page stylesheets in appJar. The basic concept behind stylesheets is that different parts of a webpage are given IDs, which are used to style that tag. The same can be acheived in appJar. Making the Stylesheet The stylesheet will consist of a number of dictionaries, each with the relevant style elements: body = { 'geom':'400x200', 'font':{'size':14, 'family':'helvetica', 'weight':'normal'}, 'bg':'blue', 'fg':'red' } heading = { 'font':{'size':20, 'family':'times', 'weight':'bold', 'underline':True, 'slant':'italic'}, 'bg':'red', 'fg':'yellow' } text = { 'font':{'size':16, 'family':'times', 'weight':'normal', 'slant':'roman'}, 'bg':'orange', 'fg':'red', 'width':300 # set the aspect for the message box } Save this with an appropriate name, eg. style.py Applying the Stylesheet To apply the stylesheet, you need to import it, and then set-up the IDs: from appJar import gui import style with gui('Demo Stylesheet', **style.body) as app: app.label(\"Stylesheet Demonstration\", **style.heading) app.message(\"This demonstration gives an example of how \" + \"stylesheets can be replicated in appJar.\", **style.text) app.label(\"Some other text, without style.\") The IDs are slightly more complicated than regular CSS, but they just mean get the named variable from the style file. ** is special python syntax which unpacks the variable (replaces it with the contents of the dictionary). Getting Fancy If you want to take things a bit further, and use a clever name for your stylesheet, you can either: import it as a simpler name: # stylesheet saved as: exampleStylesheet2.py import exampleStylesheet2 as style Or use the imp library to do a special import: import imp # stylesheet saved as: myAppJarStylesheet.css style = imp.load_source('style', 'myAppJarStylesheet.css')","title":"Stylesheets"},{"location":"examples/stylesheets/#stylesheets","text":"One great idea we've seen recently is trying to replicate web page stylesheets in appJar. The basic concept behind stylesheets is that different parts of a webpage are given IDs, which are used to style that tag. The same can be acheived in appJar.","title":"Stylesheets"},{"location":"examples/stylesheets/#making-the-stylesheet","text":"The stylesheet will consist of a number of dictionaries, each with the relevant style elements: body = { 'geom':'400x200', 'font':{'size':14, 'family':'helvetica', 'weight':'normal'}, 'bg':'blue', 'fg':'red' } heading = { 'font':{'size':20, 'family':'times', 'weight':'bold', 'underline':True, 'slant':'italic'}, 'bg':'red', 'fg':'yellow' } text = { 'font':{'size':16, 'family':'times', 'weight':'normal', 'slant':'roman'}, 'bg':'orange', 'fg':'red', 'width':300 # set the aspect for the message box } Save this with an appropriate name, eg. style.py","title":"Making the Stylesheet"},{"location":"examples/stylesheets/#applying-the-stylesheet","text":"To apply the stylesheet, you need to import it, and then set-up the IDs: from appJar import gui import style with gui('Demo Stylesheet', **style.body) as app: app.label(\"Stylesheet Demonstration\", **style.heading) app.message(\"This demonstration gives an example of how \" + \"stylesheets can be replicated in appJar.\", **style.text) app.label(\"Some other text, without style.\") The IDs are slightly more complicated than regular CSS, but they just mean get the named variable from the style file. ** is special python syntax which unpacks the variable (replaces it with the contents of the dictionary).","title":"Applying the Stylesheet"},{"location":"examples/stylesheets/#getting-fancy","text":"If you want to take things a bit further, and use a clever name for your stylesheet, you can either: import it as a simpler name: # stylesheet saved as: exampleStylesheet2.py import exampleStylesheet2 as style Or use the imp library to do a special import: import imp # stylesheet saved as: myAppJarStylesheet.css style = imp.load_source('style', 'myAppJarStylesheet.css')","title":"Getting Fancy"},{"location":"widgets/button/","text":"Button A clickable button, that will call a function. These are the key to starting an interactive application. The GUI is looping, waiting for something to happen. A button click is the classic way to start interacting with a GUI. Whenever any function is called by the GUI, the title of the widget that called it is passed as a parameter. That way, multiple widgets can use the same function, but different actions can be performed, depending on the name passed as a parameter. from appJar import gui # the title of the button will be received as a parameter def press(btn): print(btn) app=gui() # 3 buttons, each calling the same function app.addButton(\"One\", press) app.addButton(\"Two\", press) app.addButton(\"Three\", press) app.go() Add Buttons .addButton(title, function) Add a single button to the GUI, the text on the button will be the same as the button's title. A function should be specified, which will be called when the button is clicked, where the title is passed as a parameter to the function. Alternatively, the function can have no parameter, and appJar will not supply an argument. .addButtons(titles, functions) It's possible to add a list of buttons to the GUI. Pass a 1-dimensional or 2-dimensional list, and they will be rendered accordingly. A single function can be passed, to use for all buttons. Or a list of functions can be passed, which MUST correspond to the buttons. .addImageButton(title, function, imgFile, align=None) This creates the named button, as above, using the specified image. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addIconButton(title, function, iconName, align=None) This creates the named button, as above, using the specified icon. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addNamedButton(name, title, function) By default, it's not possible to have two buttons with the same text. If that's required, a named button should be used. This allows a name and title to be set for a button. The name will be displayed on the button, and the title passed to the function. Set Buttons .setButton(name, text) This will change the text displayed on a button, but NOT the value passed as a parameter to the function. .setButtonImage(title, image, align=None) This allows an image to be placed on a button, instead of the usual text. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text.","title":"Button"},{"location":"widgets/button/#button","text":"A clickable button, that will call a function. These are the key to starting an interactive application. The GUI is looping, waiting for something to happen. A button click is the classic way to start interacting with a GUI. Whenever any function is called by the GUI, the title of the widget that called it is passed as a parameter. That way, multiple widgets can use the same function, but different actions can be performed, depending on the name passed as a parameter. from appJar import gui # the title of the button will be received as a parameter def press(btn): print(btn) app=gui() # 3 buttons, each calling the same function app.addButton(\"One\", press) app.addButton(\"Two\", press) app.addButton(\"Three\", press) app.go()","title":"Button"},{"location":"widgets/button/#add-buttons","text":".addButton(title, function) Add a single button to the GUI, the text on the button will be the same as the button's title. A function should be specified, which will be called when the button is clicked, where the title is passed as a parameter to the function. Alternatively, the function can have no parameter, and appJar will not supply an argument. .addButtons(titles, functions) It's possible to add a list of buttons to the GUI. Pass a 1-dimensional or 2-dimensional list, and they will be rendered accordingly. A single function can be passed, to use for all buttons. Or a list of functions can be passed, which MUST correspond to the buttons. .addImageButton(title, function, imgFile, align=None) This creates the named button, as above, using the specified image. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addIconButton(title, function, iconName, align=None) This creates the named button, as above, using the specified icon. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text. .addNamedButton(name, title, function) By default, it's not possible to have two buttons with the same text. If that's required, a named button should be used. This allows a name and title to be set for a button. The name will be displayed on the button, and the title passed to the function.","title":"Add Buttons"},{"location":"widgets/button/#set-buttons","text":".setButton(name, text) This will change the text displayed on a button, but NOT the value passed as a parameter to the function. .setButtonImage(title, image, align=None) This allows an image to be placed on a button, instead of the usual text. If align is set, the image will be aligned relative to the text, otherwise the image will replace the text.","title":"Set Buttons"},{"location":"widgets/canvas/","text":"Canvas ( beta ) This lets you embed a canvas in appJar from appJar import gui app=gui() canvas = app.addCanvas(\"c1\") canvas.create_oval(10, 10, 100, 100, fill=\"red\", outline=\"blue\", width=3) canvas.create_line(0, 0, 255, 255, width=5) canvas.create_line(0, 255, 255, 0, dash=123) app.go() .addCanvas(title) Creates a canvas widget. .getCanvas(title) Gets the specified canvas widget. Drawing on a Canvas .addCanvasCircle(title, x, y, diameter, **kwargs) Draws a circle on the canvas. .addCanvasOval(title, x, y, xDiam, yDiam, **kwargs) Draws an oval on the canvas. .addCanvasRectangle(title, x, y, w, h, **kwargs) Draws a rectangle on the canvas. .addCanvasLine(title, x, y, x2, y2, **kwargs) Draws a line on the canvas. .addCanvasText(title, x, y, text, **kwargs) Draws text on the canvas. `.clearCanvas(title) Removes all drawings from the canvas.","title":"Canvas"},{"location":"widgets/canvas/#canvas-beta","text":"This lets you embed a canvas in appJar from appJar import gui app=gui() canvas = app.addCanvas(\"c1\") canvas.create_oval(10, 10, 100, 100, fill=\"red\", outline=\"blue\", width=3) canvas.create_line(0, 0, 255, 255, width=5) canvas.create_line(0, 255, 255, 0, dash=123) app.go() .addCanvas(title) Creates a canvas widget. .getCanvas(title) Gets the specified canvas widget.","title":"Canvas (beta)"},{"location":"widgets/canvas/#drawing-on-a-canvas","text":".addCanvasCircle(title, x, y, diameter, **kwargs) Draws a circle on the canvas. .addCanvasOval(title, x, y, xDiam, yDiam, **kwargs) Draws an oval on the canvas. .addCanvasRectangle(title, x, y, w, h, **kwargs) Draws a rectangle on the canvas. .addCanvasLine(title, x, y, x2, y2, **kwargs) Draws a line on the canvas. .addCanvasText(title, x, y, text, **kwargs) Draws text on the canvas. `.clearCanvas(title) Removes all drawings from the canvas.","title":"Drawing on a Canvas"},{"location":"widgets/chart/","text":"PieChart ( beta ) Widget to depict a Pie Chart. It will automatically calculate percentages, and draw a pie chart, given a dictionary of items and their amount. The PieChart is purely for display purposes, and is not interactive, other than a simple mouse-over effect with a tooltip. from appJar import gui app = gui() app.addPieChart(\"p1\", {\"apples\":50, \"oranges\":200, \"grapes\":75, \"beef\":300, \"turkey\":150}) app.go() Add PieCharts .addPieChart(title, values) Takes a dictionary of names and values, which will be converted to percentages, and plotted on the chart. The names will be used as part of tooltips that appear over each wedge of the PieChart. Set PieCharts .setPieChart(title, name, value) Will update the PieChart, by either changing an existing value, adding a new value, or removing a value if it's set to 0.","title":"Chart"},{"location":"widgets/chart/#piechart-beta","text":"Widget to depict a Pie Chart. It will automatically calculate percentages, and draw a pie chart, given a dictionary of items and their amount. The PieChart is purely for display purposes, and is not interactive, other than a simple mouse-over effect with a tooltip. from appJar import gui app = gui() app.addPieChart(\"p1\", {\"apples\":50, \"oranges\":200, \"grapes\":75, \"beef\":300, \"turkey\":150}) app.go()","title":"PieChart (beta)"},{"location":"widgets/chart/#add-piecharts","text":".addPieChart(title, values) Takes a dictionary of names and values, which will be converted to percentages, and plotted on the chart. The names will be used as part of tooltips that appear over each wedge of the PieChart.","title":"Add PieCharts"},{"location":"widgets/chart/#set-piecharts","text":".setPieChart(title, name, value) Will update the PieChart, by either changing an existing value, adding a new value, or removing a value if it's set to 0.","title":"Set PieCharts"},{"location":"widgets/check/","text":"CheckBox A simple tick-box, with a label, that can be either ON or OFF. from appJar import gui app=gui() app.setFont(20) app.addCheckBox(\"Apples\") app.addCheckBox(\"Pears\") app.addCheckBox(\"Oranges\") app.addCheckBox(\"Kiwis\") app.setCheckBox(\"Oranges\") app.go() Add CheckBoxes .addCheckBox(title) This creates a CheckBox, with the specified title. .addNamedCheckBox(name, title) By default, it's not possible to have two CheckBoxes with the same text. If that's required, a named CheckBox should be used. This creates a CheckBox, with the specified title. The name will be displayed next to the CheckBox, and the title passed to the function as a unique ID. Set CheckBoxes .setCheckBox(title, ticked=True, callFunction=True) This will tick the CheckBox, or untick it if ticked is set to False. Set callFunction to be False, if you don't want to call any associated functions. .clearAllCheckBoxes(callFunction=False) This will clear (untick) all CheckBoxes in the app. Set callFunction to be True, if you want to call any associated functions. Get CheckBoxes .getCheckBox(title) This will return True or False, depending on the state of the CheckBox. .getAllCheckBoxes() This will return the contents of all CheckBoxes in the app, as a dictionary.","title":"Check"},{"location":"widgets/check/#checkbox","text":"A simple tick-box, with a label, that can be either ON or OFF. from appJar import gui app=gui() app.setFont(20) app.addCheckBox(\"Apples\") app.addCheckBox(\"Pears\") app.addCheckBox(\"Oranges\") app.addCheckBox(\"Kiwis\") app.setCheckBox(\"Oranges\") app.go()","title":"CheckBox"},{"location":"widgets/check/#add-checkboxes","text":".addCheckBox(title) This creates a CheckBox, with the specified title. .addNamedCheckBox(name, title) By default, it's not possible to have two CheckBoxes with the same text. If that's required, a named CheckBox should be used. This creates a CheckBox, with the specified title. The name will be displayed next to the CheckBox, and the title passed to the function as a unique ID.","title":"Add CheckBoxes"},{"location":"widgets/check/#set-checkboxes","text":".setCheckBox(title, ticked=True, callFunction=True) This will tick the CheckBox, or untick it if ticked is set to False. Set callFunction to be False, if you don't want to call any associated functions. .clearAllCheckBoxes(callFunction=False) This will clear (untick) all CheckBoxes in the app. Set callFunction to be True, if you want to call any associated functions.","title":"Set CheckBoxes"},{"location":"widgets/check/#get-checkboxes","text":".getCheckBox(title) This will return True or False, depending on the state of the CheckBox. .getAllCheckBoxes() This will return the contents of all CheckBoxes in the app, as a dictionary.","title":"Get CheckBoxes"},{"location":"widgets/date/","text":"DatePicker A widget to capture a date - will handle presenting accurate drop-downs, and return a date. from appJar import gui def showDate(btn): print(app.getDatePicker(\"dp\")) app=gui() app.addDatePicker(\"dp\") app.addButton(\"GET\", showDate) app.setDatePickerRange(\"dp\", 1900, 2100) app.setDatePicker(\"dp\") app.go() Add DatePickers .addDatePicker(title) Create a DatePicker, with a range from 1/1/1970 to 31/12/2020 Set DatePickers .setDatePicker(title, date=None) Will set the specified DatePicker to the specified date, or current date if no date is supplied. .setDatePickerRange(title, startYear, endYear=None) Set the range for the named DatePicker. If endYear is None, the current Year will be used. .setDatePickerChangeFunction(title, function) Set a function to call when the DatePicker is changed. .clearDatePicker(title, callFunction=True) This will reset the specified DatePicker to the earliest available date. Set callFunction to be False, if you don't want to call any associated functions. .clearAllDatePickers(callFunction=False) This will reset all DatePickers in the app to their earliest available date. Set callFunction to be True, if you want to call any associated functions. Get DatePickers .getDatePicker(title) Will return the currently selected date. .getAllDatePickers() This will return the contents of all DatePickers in the app, as a dictionary.","title":"Date"},{"location":"widgets/date/#datepicker","text":"A widget to capture a date - will handle presenting accurate drop-downs, and return a date. from appJar import gui def showDate(btn): print(app.getDatePicker(\"dp\")) app=gui() app.addDatePicker(\"dp\") app.addButton(\"GET\", showDate) app.setDatePickerRange(\"dp\", 1900, 2100) app.setDatePicker(\"dp\") app.go()","title":"DatePicker"},{"location":"widgets/date/#add-datepickers","text":".addDatePicker(title) Create a DatePicker, with a range from 1/1/1970 to 31/12/2020","title":"Add DatePickers"},{"location":"widgets/date/#set-datepickers","text":".setDatePicker(title, date=None) Will set the specified DatePicker to the specified date, or current date if no date is supplied. .setDatePickerRange(title, startYear, endYear=None) Set the range for the named DatePicker. If endYear is None, the current Year will be used. .setDatePickerChangeFunction(title, function) Set a function to call when the DatePicker is changed. .clearDatePicker(title, callFunction=True) This will reset the specified DatePicker to the earliest available date. Set callFunction to be False, if you don't want to call any associated functions. .clearAllDatePickers(callFunction=False) This will reset all DatePickers in the app to their earliest available date. Set callFunction to be True, if you want to call any associated functions.","title":"Set DatePickers"},{"location":"widgets/date/#get-datepickers","text":".getDatePicker(title) Will return the currently selected date. .getAllDatePickers() This will return the contents of all DatePickers in the app, as a dictionary.","title":"Get DatePickers"},{"location":"widgets/entry/","text":"Entry Entries are used to capture input from the user. They take a single parameter - a title. There are five special-case Entries: NumericEntry - this only allows numbers to be typed in - always returns a float (None if empty). SecretEntry - this will show stars, instead of the letters typed - useful for capturing passwords. AutoEntry - this takes a list of words to provide auto-completion. ValidationEntry - can be set to valid/invalid/waiting - will colour the border green/red/black and show a \u2714/\u2716/\u2605 FileEntry/DirectoryEntry - provides a button to select a file/directory and auto-populates the Entry from appJar import gui app=gui() app.addEntry(\"e1\") app.addEntry(\"e2\") app.addEntry(\"e3\") app.addLabelEntry(\"Name\") app.addValidationEntry(\"v1\") app.addFileEntry(\"f1\") app.setEntryDefault(\"e2\", \"Age here\") app.setEntryValid(\"v1\") app.go() Add Entries .addEntry(title) .addNumericEntry(title) .addSecretEntry(title) .addAutoEntry(title, words) .addValidationEntry(title) .addFileEntry(title) .addDirectoryEntry(title) Each of these will add the specified type of Entry, using the title provided. Set Entries .setEntry(title, text, callFunction=True) This sets the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .setEntryDefault(title, text) This sets a default value to display in an Entry. Once the user starts typing, it will disappear. The text is centered, shown in a light gray font, and will not be returned by .getEntry(title) .setEntryUpperCase(title) & .setEntryLowerCase(title) This will force all text typed into the Entry to be uppercase/lowercase. .setEntryMaxLength(title, maxLength) This will set a maximum length for the specified Entry. Any additional characters typed will be discarded. .setEntryValid(title) & .setEntryInvalid(title) & .setEntryWaitingValidation(title) These will set the relevant status of a validation Entry. (Have a look here for help displaying special characters) .setValidationEntry(title, state=\"valid\") Same as above, set flag to one of valid , invalid or wait . .setAutoEntryNumRows(title, rows) This will set the number of rows to display in an AutoEntry. NB. this is limited to the depth of the GUI - if there is no space, then no rows will be displayed. .appendAutoEntry(title, value) This will add the value/list of values to the specified AutoEntry. .removeAutoEntry(title, value) This will remove the value from the specified AutoEntry. .changeAutoEntry(title, value) This will replace all items in the specified AutoEntry with a new list of values. .clearEntry(title, callFunction=True) This will clear the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .clearAllEntries(callFunction=False) This will clear all Entries in the GUI. Set callFunction to be True, if you want to call any associated functions. .setFocus(title) This will put the cursor in the specified Entry, so that the user can start typing without needing to click. Get Entries .getEntry(title) This will return the contents of the specified Entry. NB. numericEntries always return a float. .getAllEntries() This will return the contents of all Entries in the app, as a dictionary. NB. numericEntries always return a float.","title":"Entry"},{"location":"widgets/entry/#entry","text":"Entries are used to capture input from the user. They take a single parameter - a title. There are five special-case Entries: NumericEntry - this only allows numbers to be typed in - always returns a float (None if empty). SecretEntry - this will show stars, instead of the letters typed - useful for capturing passwords. AutoEntry - this takes a list of words to provide auto-completion. ValidationEntry - can be set to valid/invalid/waiting - will colour the border green/red/black and show a \u2714/\u2716/\u2605 FileEntry/DirectoryEntry - provides a button to select a file/directory and auto-populates the Entry from appJar import gui app=gui() app.addEntry(\"e1\") app.addEntry(\"e2\") app.addEntry(\"e3\") app.addLabelEntry(\"Name\") app.addValidationEntry(\"v1\") app.addFileEntry(\"f1\") app.setEntryDefault(\"e2\", \"Age here\") app.setEntryValid(\"v1\") app.go()","title":"Entry"},{"location":"widgets/entry/#add-entries","text":".addEntry(title) .addNumericEntry(title) .addSecretEntry(title) .addAutoEntry(title, words) .addValidationEntry(title) .addFileEntry(title) .addDirectoryEntry(title) Each of these will add the specified type of Entry, using the title provided.","title":"Add Entries"},{"location":"widgets/entry/#set-entries","text":".setEntry(title, text, callFunction=True) This sets the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .setEntryDefault(title, text) This sets a default value to display in an Entry. Once the user starts typing, it will disappear. The text is centered, shown in a light gray font, and will not be returned by .getEntry(title) .setEntryUpperCase(title) & .setEntryLowerCase(title) This will force all text typed into the Entry to be uppercase/lowercase. .setEntryMaxLength(title, maxLength) This will set a maximum length for the specified Entry. Any additional characters typed will be discarded. .setEntryValid(title) & .setEntryInvalid(title) & .setEntryWaitingValidation(title) These will set the relevant status of a validation Entry. (Have a look here for help displaying special characters) .setValidationEntry(title, state=\"valid\") Same as above, set flag to one of valid , invalid or wait . .setAutoEntryNumRows(title, rows) This will set the number of rows to display in an AutoEntry. NB. this is limited to the depth of the GUI - if there is no space, then no rows will be displayed. .appendAutoEntry(title, value) This will add the value/list of values to the specified AutoEntry. .removeAutoEntry(title, value) This will remove the value from the specified AutoEntry. .changeAutoEntry(title, value) This will replace all items in the specified AutoEntry with a new list of values. .clearEntry(title, callFunction=True) This will clear the contents of the specified Entry. Set callFunction to be False, if you don't want to call any associated functions. .clearAllEntries(callFunction=False) This will clear all Entries in the GUI. Set callFunction to be True, if you want to call any associated functions. .setFocus(title) This will put the cursor in the specified Entry, so that the user can start typing without needing to click.","title":"Set Entries"},{"location":"widgets/entry/#get-entries","text":".getEntry(title) This will return the contents of the specified Entry. NB. numericEntries always return a float. .getAllEntries() This will return the contents of all Entries in the app, as a dictionary. NB. numericEntries always return a float.","title":"Get Entries"},{"location":"widgets/grid/","text":"Grid ( beta ) Used to create a spreadsheet like interface. The grid has mouse interactivity, with mouse-over highlighting, and mouse-click highlighting. It is possible to include buttons at the end of each row, and an additional row of entry boxes, with their own button. from appJar import gui app = gui() app.setFont(20) app.addGrid(\"g1\", [[\"Name\", \"Age\", \"Gender\"], [\"Fred\", 45, \"Male\"], [\"Tina\", 37, \"Female\"], [\"Clive\", 28, \"Male\"], [\"Betty\", 51, \"Female\"]]) app.go() Add Grids .addGrid(title, data, action=None, addRow=None) Receives a (jagged) 2D list of values. The first list should be the headers for the grid, the rest will contain each row of values. If action is set, a button will be created, at the end of each row, calling the specified function. It will pass the row number (starting at 0). If addRow is set, then an additional row will appear at the end of the grid, with entry boxes and a button to call the specified function. The button will pass the string newRow to the specified function. If both parameters are set to a function, then both buttons at the end of each row and a row of Entry boxes will be shown: It's also possible to set the following parameters: * actionHeading - set the title of the right column * actionButton - set the button text for each row * addButton - set the button text for the Entry row * showMenu - boolean to show a right-click menu Connecting to Databases .addDbGrid(title, db, table) Will connect to the specified database, and show all rows in the specified table. appJar will query the table to detect the PrimaryKey, and use this as the key when selecting the row. .replaceDBGrid(title, db, table) Will replace the currently shown data in the grid, with the data found in the specified database/table. Get Grids .getGridRow(title, rowNumber) Returns a list of values representing the specified row. .getGridRowCount(title) Returns a count of how many rows are in the grid (not including the header row). .getGridSelectedCells(title) Gets a dictionary of booleans, indicating the status of each cell. True indicates the cell is selected, False indicates the cell is not selected. The name of each entry on the dictionary will be in the format ROW-COLUMN, eg. 0-2 .getGridEntries(title) If addRow was set when the Grid was created, this function will get the contents of the entry boxes. They will be returned as a list, in the same order as the entry boxes. Set Grids .addGridRow(title, data) Adds a new row of data to the end of the existing grid. It will be positioned at the bottom of the grid, above the entry boxes if present. To have the Press button on the entries row add a new row of data, try the following: def press(btn): if btn == \"addRow\": # the button on the entries row data = app.getGridEntries(\"g1\") app.addGridRow(\"g1\", data) .addGridRows(title, data) Adds the new rows of data to the end of the existing grid. .replaceGridRow(title, rowNum, data) Replace the values in the specified row with the new data. If the new data has fewer items, the remaining cells will be emptied. .replaceAllGridRows(title, rowNum, data) Removes all existing rows, before adding the new rows. .setGridHeaders(title, data) Replace the values in the header row. If the new data has fewer items, the remaining header cells will be emptied. .deleteGridRow(title, rowNum) Delete the specified row from the specified grid. .deleteAllGridRows(title) Delete all rows from the specified grid (except the header row). .addGridColumn(title, columnNumber, data) Add the column of data to the named grid, in the specified position. .deleteGridColumn(title, columnNumber) Delete the specified column from the named grid.","title":"Grid"},{"location":"widgets/grid/#grid-beta","text":"Used to create a spreadsheet like interface. The grid has mouse interactivity, with mouse-over highlighting, and mouse-click highlighting. It is possible to include buttons at the end of each row, and an additional row of entry boxes, with their own button. from appJar import gui app = gui() app.setFont(20) app.addGrid(\"g1\", [[\"Name\", \"Age\", \"Gender\"], [\"Fred\", 45, \"Male\"], [\"Tina\", 37, \"Female\"], [\"Clive\", 28, \"Male\"], [\"Betty\", 51, \"Female\"]]) app.go()","title":"Grid (beta)"},{"location":"widgets/grid/#add-grids","text":".addGrid(title, data, action=None, addRow=None) Receives a (jagged) 2D list of values. The first list should be the headers for the grid, the rest will contain each row of values. If action is set, a button will be created, at the end of each row, calling the specified function. It will pass the row number (starting at 0). If addRow is set, then an additional row will appear at the end of the grid, with entry boxes and a button to call the specified function. The button will pass the string newRow to the specified function. If both parameters are set to a function, then both buttons at the end of each row and a row of Entry boxes will be shown: It's also possible to set the following parameters: * actionHeading - set the title of the right column * actionButton - set the button text for each row * addButton - set the button text for the Entry row * showMenu - boolean to show a right-click menu","title":"Add Grids"},{"location":"widgets/grid/#connecting-to-databases","text":".addDbGrid(title, db, table) Will connect to the specified database, and show all rows in the specified table. appJar will query the table to detect the PrimaryKey, and use this as the key when selecting the row. .replaceDBGrid(title, db, table) Will replace the currently shown data in the grid, with the data found in the specified database/table.","title":"Connecting to Databases"},{"location":"widgets/grid/#get-grids","text":".getGridRow(title, rowNumber) Returns a list of values representing the specified row. .getGridRowCount(title) Returns a count of how many rows are in the grid (not including the header row). .getGridSelectedCells(title) Gets a dictionary of booleans, indicating the status of each cell. True indicates the cell is selected, False indicates the cell is not selected. The name of each entry on the dictionary will be in the format ROW-COLUMN, eg. 0-2 .getGridEntries(title) If addRow was set when the Grid was created, this function will get the contents of the entry boxes. They will be returned as a list, in the same order as the entry boxes.","title":"Get Grids"},{"location":"widgets/grid/#set-grids","text":".addGridRow(title, data) Adds a new row of data to the end of the existing grid. It will be positioned at the bottom of the grid, above the entry boxes if present. To have the Press button on the entries row add a new row of data, try the following: def press(btn): if btn == \"addRow\": # the button on the entries row data = app.getGridEntries(\"g1\") app.addGridRow(\"g1\", data) .addGridRows(title, data) Adds the new rows of data to the end of the existing grid. .replaceGridRow(title, rowNum, data) Replace the values in the specified row with the new data. If the new data has fewer items, the remaining cells will be emptied. .replaceAllGridRows(title, rowNum, data) Removes all existing rows, before adding the new rows. .setGridHeaders(title, data) Replace the values in the header row. If the new data has fewer items, the remaining header cells will be emptied. .deleteGridRow(title, rowNum) Delete the specified row from the specified grid. .deleteAllGridRows(title) Delete all rows from the specified grid (except the header row). .addGridColumn(title, columnNumber, data) Add the column of data to the named grid, in the specified position. .deleteGridColumn(title, columnNumber) Delete the specified column from the named grid.","title":"Set Grids"},{"location":"widgets/grip/","text":"Grip Clickable icon to drag the window around. from appJar import gui app=gui() app.setFont(20) app.setBg(\"lightBlue\") app.addLabel(\"l1\", \"Move me around...\", 0, 0) app.addGrip(0,1) app.addSeparator(1,0,2, colour=\"red\") app.go() Add Grips .addGrip() Adds a simple grip icon. The mouse pointer changes over the grip, and a ToolTip will be shown. The size and image can't be changed.","title":"Grip"},{"location":"widgets/grip/#grip","text":"Clickable icon to drag the window around. from appJar import gui app=gui() app.setFont(20) app.setBg(\"lightBlue\") app.addLabel(\"l1\", \"Move me around...\", 0, 0) app.addGrip(0,1) app.addSeparator(1,0,2, colour=\"red\") app.go()","title":"Grip"},{"location":"widgets/grip/#add-grips","text":".addGrip() Adds a simple grip icon. The mouse pointer changes over the grip, and a ToolTip will be shown. The size and image can't be changed.","title":"Add Grips"},{"location":"widgets/label/","text":"Label Labels are used for displaying text in the GUI. They are great for titles, at the top of the GUI, usually spanning multiple columns. They are really useful before Entries and Drop-downs to explain their purpose. And, they're very helpful at the bottom of the GUI, to show the results of an action. from appJar import gui app = gui() app.addLabel(\"l1\", \"Label 1\") app.addLabel(\"l2\", \"Label 2\") app.addLabel(\"l3\", \"Label 3\") app.addLabel(\"l4\", \"Label 4\") # common set functions app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"yellow\") app.setLabelBg(\"l3\", \"purple\") app.setLabelBg(\"l4\", \"orange\") app.go() Add Labels .addLabel(title, text=None) This will create a label widget to display text in the GUI. The title is used to uniquely identify the label, in case you want to change it later, and the text is what gets displayed. If text is set to None, or no text is provided, the title will be displayed in the label. .addEmptyLabel(title) Does the same as add a label , except there's no parameter to set any text. .addSelectableLabel(title, text=None) This adds a label whose text can be selected with the mouse. This is really just a read-only Entry, disguised to look like a label. But it seems to do the trick... .addFlashLabel(title, text=None) This adds a flashing label , that will alternate between the foreground and background colours. from appJar import gui app = gui() app.addFlashLabel(\"f1\", \"This is flashing\") app.addLabel(\"f2\", \"This is not flashing\") app.addFlashLabel(\"f3\", \"This is also flashing\") app.go() Set Labels .setLabel(title, text) Change the contents of the label . .clearLabel(title) Clear the contents of the label . Get Labels .getLabel(title) Get the contents of the label . Auto-Labelled Widgets It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does.","title":"Label"},{"location":"widgets/label/#label","text":"Labels are used for displaying text in the GUI. They are great for titles, at the top of the GUI, usually spanning multiple columns. They are really useful before Entries and Drop-downs to explain their purpose. And, they're very helpful at the bottom of the GUI, to show the results of an action. from appJar import gui app = gui() app.addLabel(\"l1\", \"Label 1\") app.addLabel(\"l2\", \"Label 2\") app.addLabel(\"l3\", \"Label 3\") app.addLabel(\"l4\", \"Label 4\") # common set functions app.setLabelBg(\"l1\", \"red\") app.setLabelBg(\"l2\", \"yellow\") app.setLabelBg(\"l3\", \"purple\") app.setLabelBg(\"l4\", \"orange\") app.go()","title":"Label"},{"location":"widgets/label/#add-labels","text":".addLabel(title, text=None) This will create a label widget to display text in the GUI. The title is used to uniquely identify the label, in case you want to change it later, and the text is what gets displayed. If text is set to None, or no text is provided, the title will be displayed in the label. .addEmptyLabel(title) Does the same as add a label , except there's no parameter to set any text. .addSelectableLabel(title, text=None) This adds a label whose text can be selected with the mouse. This is really just a read-only Entry, disguised to look like a label. But it seems to do the trick... .addFlashLabel(title, text=None) This adds a flashing label , that will alternate between the foreground and background colours. from appJar import gui app = gui() app.addFlashLabel(\"f1\", \"This is flashing\") app.addLabel(\"f2\", \"This is not flashing\") app.addFlashLabel(\"f3\", \"This is also flashing\") app.go()","title":"Add Labels"},{"location":"widgets/label/#set-labels","text":".setLabel(title, text) Change the contents of the label . .clearLabel(title) Clear the contents of the label .","title":"Set Labels"},{"location":"widgets/label/#get-labels","text":".getLabel(title) Get the contents of the label .","title":"Get Labels"},{"location":"widgets/label/#auto-labelled-widgets","text":"It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does.","title":"Auto-Labelled Widgets"},{"location":"widgets/link/","text":"Link/WebLink Clickable text to call a function or launch a URL from appJar import gui def press(link): app.infoBox(\"Info\", \"You clicked the link!\") app=gui() app.setFont(20) app.addLink(\"Click me\", press) app.addWebLink(\"appJar.info\", \"http://appJar.info\") app.go() Add Links .addLink(title, func) Adds a hyperlink , that when clicked, will call the specified function. .addWebLink(title, page) Adds a hyperlink , that when clicked, will launch the default browser, and load the specified page. It must be a fully formed link, including http://","title":"Link"},{"location":"widgets/link/#linkweblink","text":"Clickable text to call a function or launch a URL from appJar import gui def press(link): app.infoBox(\"Info\", \"You clicked the link!\") app=gui() app.setFont(20) app.addLink(\"Click me\", press) app.addWebLink(\"appJar.info\", \"http://appJar.info\") app.go()","title":"Link/WebLink"},{"location":"widgets/link/#add-links","text":".addLink(title, func) Adds a hyperlink , that when clicked, will call the specified function. .addWebLink(title, page) Adds a hyperlink , that when clicked, will launch the default browser, and load the specified page. It must be a fully formed link, including http://","title":"Add Links"},{"location":"widgets/listbox/","text":"ListBox A box containing a list of items, single or multi-select from appJar import gui app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.go() Add ListBoxes .addListBox(title, values) Creates a ListBox with the specified values. .addListItem(title, item) Adds a single item to the the end of the ListBox, and selects it. .addListItems(title, items) Adds a list of items to the end of the List Box, selecting the last one. Set ListBoxes .setListItem(title, item, newVal, first=False) .setListItemAtPos(title, pos, newVal) Changes the specified list item to the new value. If first is set to True, only the first item found will be changed. Otherwise, all occurrences of the specified value will be changed. .removeListItem(title, item) .removeListItemAtPos(title, pos) Remove the specified item from the specified ListBox. Will only remove the first item that matches the parameter. .clearListBox(title, callFunction=True) Removes all items from the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllListBoxes(callFunction=False) This will remove all items from all ListBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .updateListBox(title, items, select=False) Replace the contents of the specified ListBox with the new values. If you set select to be True, the last item in the list will be selected. from appJar import gui def press(btn): items = app.getListItems(\"list\") if len(items)> 0: app.removeListItem(\"list\", items[0]) app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.addButton(\"press\", press) app.go() .selectListItem(title, item, callFunction=True) .selectListItemAtPos(title, pos, callFunction=False) Selects the specified item in the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .setListBoxRows(title, rows) Sets how many rows to display in the specified ListBox. .setListBoxMulti(list, multi=True) Configures whether the specified ListBox is single or multi select. .setListBoxGroup(list, group=True) Adds the named ListBox to a group of selectable ListBoxes. All ListBoxes in the group can have items selected at the same time. .setListItemBg(title, item, colour) & .setListItemFg(title, item, colour) .setListItemAtPosBg(title, item, colour) & .setListItemAtPosFg(title, item, colour) Sets the background or foreground colours the specified ListBox item. Can either specify a named item (will update all with that name) or the position of an item. Get ListBoxes .getListBox(title) Gets all of the selected items from the specified ListBox. .getAllListBoxes() This will return the contents of all ListBoxes in the app, as a dictionary. .getAllListItems(title) Gets all of the items from the specified ListBox.","title":"Listbox"},{"location":"widgets/listbox/#listbox","text":"A box containing a list of items, single or multi-select from appJar import gui app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.go()","title":"ListBox"},{"location":"widgets/listbox/#add-listboxes","text":".addListBox(title, values) Creates a ListBox with the specified values. .addListItem(title, item) Adds a single item to the the end of the ListBox, and selects it. .addListItems(title, items) Adds a list of items to the end of the List Box, selecting the last one.","title":"Add ListBoxes"},{"location":"widgets/listbox/#set-listboxes","text":".setListItem(title, item, newVal, first=False) .setListItemAtPos(title, pos, newVal) Changes the specified list item to the new value. If first is set to True, only the first item found will be changed. Otherwise, all occurrences of the specified value will be changed. .removeListItem(title, item) .removeListItemAtPos(title, pos) Remove the specified item from the specified ListBox. Will only remove the first item that matches the parameter. .clearListBox(title, callFunction=True) Removes all items from the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllListBoxes(callFunction=False) This will remove all items from all ListBoxes in the app. Set callFunction to be True, if you want to call any associated functions. .updateListBox(title, items, select=False) Replace the contents of the specified ListBox with the new values. If you set select to be True, the last item in the list will be selected. from appJar import gui def press(btn): items = app.getListItems(\"list\") if len(items)> 0: app.removeListItem(\"list\", items[0]) app=gui() app.setFont(20) app.addListBox(\"list\", [\"apple\", \"orange\", \"pear\", \"kiwi\"]) app.addButton(\"press\", press) app.go() .selectListItem(title, item, callFunction=True) .selectListItemAtPos(title, pos, callFunction=False) Selects the specified item in the specified ListBox. Set callFunction to be False, if you don't want to call any associated functions. .setListBoxRows(title, rows) Sets how many rows to display in the specified ListBox. .setListBoxMulti(list, multi=True) Configures whether the specified ListBox is single or multi select. .setListBoxGroup(list, group=True) Adds the named ListBox to a group of selectable ListBoxes. All ListBoxes in the group can have items selected at the same time. .setListItemBg(title, item, colour) & .setListItemFg(title, item, colour) .setListItemAtPosBg(title, item, colour) & .setListItemAtPosFg(title, item, colour) Sets the background or foreground colours the specified ListBox item. Can either specify a named item (will update all with that name) or the position of an item.","title":"Set ListBoxes"},{"location":"widgets/listbox/#get-listboxes","text":".getListBox(title) Gets all of the selected items from the specified ListBox. .getAllListBoxes() This will return the contents of all ListBoxes in the app, as a dictionary. .getAllListItems(title) Gets all of the items from the specified ListBox.","title":"Get ListBoxes"},{"location":"widgets/maps/","text":"GoogleMaps ( beta ) A self-contained GoogleMaps widget. It provides useful functionality for finding somewhere on Earth. All requests for map data are performed in the background, so the UI shouldn't become unresponsive. from appjar import gui app = gui() app.addGoogleMap(\"m1\") app.setGoogleMapSize(\"m1\", \"300x500\") app.go() Add GoogleMaps .addGoogleMap(title) Creates a GoogleMap widget. Displays a map image, and provides functionality to search, zoom, and change terrain, as well as a link to the original image. Set GoogleMaps .searchGoogleMap(title, location) Update the named GoogleMap widget to show the specified location. .zoomGoogleMap(title, mod) Change the zoom level of the named GoogleMap. Providing a + or - will cause the map to zoom in or out one level. Otherwise, a digit between 0 and 22 should be provided, to set the zoom level. .setGoogleMapTerrain(title, terrain) .setGoogleMapSize(title, size) Set the size of the GoogleMap. Should be in the format \"300x300\" . Note, if you set it too small, the control widgets won't look good... .setGoogleMapMarker(title, location, size=None, colour=None, label=None, replace=False) Will drop a marker on the specified location. The marker will only be visible if the current location & zoom level permit. If an empty location is provided, all markers will be removed. colour can be set to any of (black, brown, green, purple, yellow, blue, gray, orange, red, white) or a hex value (starting '0x'). size can be set to any of (tiny, mid, small). label can be set to a single letter or digit. If replace is True this marker will replace the last one added. .removeGoogleMapMarker(title, label) Will remove the specified marker, if found. Get GoogleMaps .getGoogleMapLocation(title) Returns the current displayed location. Will return an empty String, if the user clicked the H button. .getGoogleMapZoom(title) Returns the current zoom level of the map tile. .getGoogleMapTerrain(title) Returns the current terrain setting for the map tile. .getGoogleMapSize(title) Returns the current size of the map tile. Save GoogleMaps .saveGoogleMap(title, fileName) Saves the currently displayed map to the named location. By default, all map tiles are GIFs.","title":"Maps"},{"location":"widgets/maps/#googlemaps-beta","text":"A self-contained GoogleMaps widget. It provides useful functionality for finding somewhere on Earth. All requests for map data are performed in the background, so the UI shouldn't become unresponsive. from appjar import gui app = gui() app.addGoogleMap(\"m1\") app.setGoogleMapSize(\"m1\", \"300x500\") app.go()","title":"GoogleMaps (beta)"},{"location":"widgets/maps/#add-googlemaps","text":".addGoogleMap(title) Creates a GoogleMap widget. Displays a map image, and provides functionality to search, zoom, and change terrain, as well as a link to the original image.","title":"Add GoogleMaps"},{"location":"widgets/maps/#set-googlemaps","text":".searchGoogleMap(title, location) Update the named GoogleMap widget to show the specified location. .zoomGoogleMap(title, mod) Change the zoom level of the named GoogleMap. Providing a + or - will cause the map to zoom in or out one level. Otherwise, a digit between 0 and 22 should be provided, to set the zoom level. .setGoogleMapTerrain(title, terrain) .setGoogleMapSize(title, size) Set the size of the GoogleMap. Should be in the format \"300x300\" . Note, if you set it too small, the control widgets won't look good... .setGoogleMapMarker(title, location, size=None, colour=None, label=None, replace=False) Will drop a marker on the specified location. The marker will only be visible if the current location & zoom level permit. If an empty location is provided, all markers will be removed. colour can be set to any of (black, brown, green, purple, yellow, blue, gray, orange, red, white) or a hex value (starting '0x'). size can be set to any of (tiny, mid, small). label can be set to a single letter or digit. If replace is True this marker will replace the last one added. .removeGoogleMapMarker(title, label) Will remove the specified marker, if found.","title":"Set GoogleMaps"},{"location":"widgets/maps/#get-googlemaps","text":".getGoogleMapLocation(title) Returns the current displayed location. Will return an empty String, if the user clicked the H button. .getGoogleMapZoom(title) Returns the current zoom level of the map tile. .getGoogleMapTerrain(title) Returns the current terrain setting for the map tile. .getGoogleMapSize(title) Returns the current size of the map tile.","title":"Get GoogleMaps"},{"location":"widgets/maps/#save-googlemaps","text":".saveGoogleMap(title, fileName) Saves the currently displayed map to the named location. By default, all map tiles are GIFs.","title":"Save GoogleMaps"},{"location":"widgets/message/","text":"Message Similar to a Label, except it will wrap the text over multiple lines. from appJar import gui app=gui() app.setFont(12) app.addMessage(\"mess\", \"\"\"You can put a lot of text in this widget. The text will be wrapped over multiple lines. It's not possible to apply different styles to different words.\"\"\") app.go() Add Messages .addMessage(title, text) Adds a Message widget, with the specified text. If not text is provided, the title will be used for the text. .addEmptyMessage(title) Adds an empty Message widget. Set Messages .clearMessage(title) Clears the specified Message widget. .setMessage(title, text) Sets the contents of the specified Message widget, to the specified text.","title":"Message"},{"location":"widgets/message/#message","text":"Similar to a Label, except it will wrap the text over multiple lines. from appJar import gui app=gui() app.setFont(12) app.addMessage(\"mess\", \"\"\"You can put a lot of text in this widget. The text will be wrapped over multiple lines. It's not possible to apply different styles to different words.\"\"\") app.go()","title":"Message"},{"location":"widgets/message/#add-messages","text":".addMessage(title, text) Adds a Message widget, with the specified text. If not text is provided, the title will be used for the text. .addEmptyMessage(title) Adds an empty Message widget.","title":"Add Messages"},{"location":"widgets/message/#set-messages","text":".clearMessage(title) Clears the specified Message widget. .setMessage(title, text) Sets the contents of the specified Message widget, to the specified text.","title":"Set Messages"},{"location":"widgets/meter/","text":"Meter Various styles of progress meter: Meter A simple meter for showing progress from 0% to 100%. SplitMeter A possession style meter, showing percentages on either side. DualMeter Two separate meters, expanding out from the middle. from appJar import gui app=gui() app.addMeter(\"progress\") app.setMeterFill(\"progress\", \"blue\") app.go() Add Meters .addMeter(name) & .addSplitMeter(name) & .addDualMeter(name) Adds a meter with the specified name, of the specified type.. Set Meters .setMeter(name, value, text=None) Changes the specified meter to the specified value. For Meter & SplitMeter should be a value between 0 and 100. For DualMeter should be a list of two values, each between 0 and 100. .setMeterFill(name, colour) Changes the fill colour of the specified meter. For SplitMeter & DualMeter should be a list of two colours. Get Meters .getMeter(name) Gets the value of the specified meter. As meters convert their data to a value between 0 and 1, this will return a list of two values: (0.45, '45 %') .getAllMeters() This will return the contents of all Meters in the app, as a dictionary. Background Processing Meters are designed to show progress over time. One common solution is to register a function that is constantly updating a meter. This should then be monitoring/updating a global variable: def updateMeter(): app.setMeter(\"progress\", percentComplete) # schedule function to be called regularly app.registerEvent(updateMeter)","title":"Meter"},{"location":"widgets/meter/#meter","text":"Various styles of progress meter:","title":"Meter"},{"location":"widgets/meter/#meter_1","text":"A simple meter for showing progress from 0% to 100%.","title":"Meter"},{"location":"widgets/meter/#splitmeter","text":"A possession style meter, showing percentages on either side.","title":"SplitMeter"},{"location":"widgets/meter/#dualmeter","text":"Two separate meters, expanding out from the middle. from appJar import gui app=gui() app.addMeter(\"progress\") app.setMeterFill(\"progress\", \"blue\") app.go()","title":"DualMeter"},{"location":"widgets/meter/#add-meters","text":".addMeter(name) & .addSplitMeter(name) & .addDualMeter(name) Adds a meter with the specified name, of the specified type..","title":"Add Meters"},{"location":"widgets/meter/#set-meters","text":".setMeter(name, value, text=None) Changes the specified meter to the specified value. For Meter & SplitMeter should be a value between 0 and 100. For DualMeter should be a list of two values, each between 0 and 100. .setMeterFill(name, colour) Changes the fill colour of the specified meter. For SplitMeter & DualMeter should be a list of two colours.","title":"Set Meters"},{"location":"widgets/meter/#get-meters","text":".getMeter(name) Gets the value of the specified meter. As meters convert their data to a value between 0 and 1, this will return a list of two values: (0.45, '45 %') .getAllMeters() This will return the contents of all Meters in the app, as a dictionary.","title":"Get Meters"},{"location":"widgets/meter/#background-processing","text":"Meters are designed to show progress over time. One common solution is to register a function that is constantly updating a meter. This should then be monitoring/updating a global variable: def updateMeter(): app.setMeter(\"progress\", percentComplete) # schedule function to be called regularly app.registerEvent(updateMeter)","title":"Background Processing"},{"location":"widgets/microbit/","text":"MicroBit Emulator ( beta ) Widget to emulate a MicroBit from appJar import gui app = gui() app.addMicroBit(\"mb1\") app.setMicroBitImage(\"mb1\", \"09090:90909:90009:09090:00900\") app.go() Add MicroBits .addMicroBit(title) Will create a 5x5 grid emulating the MicroBit LEDs. Set MicroBits .setMicroBitImage(title, image) This sets each pixel to the specified brightness (0 to 9). Each set of 5 digits represents a row of pixels, from top to bottom. .setMicroBitPixel(title, x, y, brightness) Will set the brightness of the specified pixel. x & y should be between 0 & 4. brightness should be a value between 0 & 9 to represent how bright to make the pixel. .clearMicroBit(title) Will turn off all of the pixels - setting their brightness to 0.","title":"Microbit"},{"location":"widgets/microbit/#microbit-emulator-beta","text":"Widget to emulate a MicroBit from appJar import gui app = gui() app.addMicroBit(\"mb1\") app.setMicroBitImage(\"mb1\", \"09090:90909:90009:09090:00900\") app.go()","title":"MicroBit Emulator (beta)"},{"location":"widgets/microbit/#add-microbits","text":".addMicroBit(title) Will create a 5x5 grid emulating the MicroBit LEDs.","title":"Add MicroBits"},{"location":"widgets/microbit/#set-microbits","text":".setMicroBitImage(title, image) This sets each pixel to the specified brightness (0 to 9). Each set of 5 digits represents a row of pixels, from top to bottom. .setMicroBitPixel(title, x, y, brightness) Will set the brightness of the specified pixel. x & y should be between 0 & 4. brightness should be a value between 0 & 9 to represent how bright to make the pixel. .clearMicroBit(title) Will turn off all of the pixels - setting their brightness to 0.","title":"Set MicroBits"},{"location":"widgets/option/","text":"OptionBox Creates a simple drop-down box. It is only possible to select one option from this drop-down. Pass in a list of values to show in the drop-down box. They will be added in the same order, with the first item shown. If the first item is empty, a simple title - options - will be created. Any other empty items will be removed. If an item starts with a dash (-), it will be treated as a separator, and can't be selected. from appJar import gui app=gui() app.setFont(20) app.addLabelOptionBox(\"Options\", [\"- Fruits -\", \"Apple\", \"Orange\", \"Pear\", \"kiwi\", \"- Pets -\", \"Dogs\", \"Cats\", \"Fish\", \"Hamsters\"]) app.go() Add OptionBoxes .addOptionBox(title, values) This will create an OptionBox, adding the contents of the values list, in the order specified. .addTickOptionBox(title, values) This will create an OptionBox made up of check boxes. The title will always be displayed as the selected entry in the OptionBox, event though it can't be selected/ticked. Instead of selecting a single item, you tick the ones you want. Calling .getOptionBox(title) will return a dictionary of the options along with a True/False value. from appJar import gui def get(btn): print(app.getOptionBox(\"Favourite Pets\")) app=gui() app.setFont(20) app.addTickOptionBox(\"Favourite Pets\", [\"Dogs\", \"Cats\", \"Hamsters\", \"Fish\"]) app.addButton(\"GET\", get) app.go() Set OptionBoxes .changeOptionBox(title, newOptions, index, callFunction=False) This will replace the contents of the OptionBox, with the new list provided. If specified, the indexed item will be selected - this can be a position or an item name. If setting a TickOptionBox, the old list will be replaced with the new list. None will be ticked. index will be ignored. Set callFunction to be True, if you want to call any associated change functions. .setOptionBox(title, position, value=True, callFunction=True, override=False) This will select the item in the list, at the position specified. Alternatively, the name of an item can be specified. If changing a TickOptionBox, the specified item will be set to the specified value. Set callFunction to be False, if you don't want to call any associated functions. By default, you can't select a disabled item. You can change this by setting override to be True. .renameOptionBoxItem(title, item, newName, callFunction=False) This will rename the specified item in the named OptionBox. Set callFunction to be True, if you want to call any associated change functions. .clearOptionBox(title, callFunction=True) This will set the named OptionBox back to its first value (even if it's disabled). Set callFunction to be False, if you don't want to call any associated functions. .clearAllOptionBoxes(callFunction=False) This will set all OptionBoxes in the app back to their first value (even if it's disabled). Set callFunction to be True, if you want to call any associated functions. .deleteOptionBox(title, position) This will delete the item in the list, at the position specified. Alternatively, the name of an item can be specified. Not available on TickOptionBoxes. Get OptionBoxes .getOptionBox(title) This will return the currently displayed value in an OptionBox. Or a dictionary of names, and their boolean value if a TickOptionBox. Will return None, if an invalid option is currently selected. .getAllOptionBoxes() This will return the contents of all OptionBoxes in the app, as a dictionary.","title":"Option"},{"location":"widgets/option/#optionbox","text":"Creates a simple drop-down box. It is only possible to select one option from this drop-down. Pass in a list of values to show in the drop-down box. They will be added in the same order, with the first item shown. If the first item is empty, a simple title - options - will be created. Any other empty items will be removed. If an item starts with a dash (-), it will be treated as a separator, and can't be selected. from appJar import gui app=gui() app.setFont(20) app.addLabelOptionBox(\"Options\", [\"- Fruits -\", \"Apple\", \"Orange\", \"Pear\", \"kiwi\", \"- Pets -\", \"Dogs\", \"Cats\", \"Fish\", \"Hamsters\"]) app.go()","title":"OptionBox"},{"location":"widgets/option/#add-optionboxes","text":".addOptionBox(title, values) This will create an OptionBox, adding the contents of the values list, in the order specified. .addTickOptionBox(title, values) This will create an OptionBox made up of check boxes. The title will always be displayed as the selected entry in the OptionBox, event though it can't be selected/ticked. Instead of selecting a single item, you tick the ones you want. Calling .getOptionBox(title) will return a dictionary of the options along with a True/False value. from appJar import gui def get(btn): print(app.getOptionBox(\"Favourite Pets\")) app=gui() app.setFont(20) app.addTickOptionBox(\"Favourite Pets\", [\"Dogs\", \"Cats\", \"Hamsters\", \"Fish\"]) app.addButton(\"GET\", get) app.go()","title":"Add OptionBoxes"},{"location":"widgets/option/#set-optionboxes","text":".changeOptionBox(title, newOptions, index, callFunction=False) This will replace the contents of the OptionBox, with the new list provided. If specified, the indexed item will be selected - this can be a position or an item name. If setting a TickOptionBox, the old list will be replaced with the new list. None will be ticked. index will be ignored. Set callFunction to be True, if you want to call any associated change functions. .setOptionBox(title, position, value=True, callFunction=True, override=False) This will select the item in the list, at the position specified. Alternatively, the name of an item can be specified. If changing a TickOptionBox, the specified item will be set to the specified value. Set callFunction to be False, if you don't want to call any associated functions. By default, you can't select a disabled item. You can change this by setting override to be True. .renameOptionBoxItem(title, item, newName, callFunction=False) This will rename the specified item in the named OptionBox. Set callFunction to be True, if you want to call any associated change functions. .clearOptionBox(title, callFunction=True) This will set the named OptionBox back to its first value (even if it's disabled). Set callFunction to be False, if you don't want to call any associated functions. .clearAllOptionBoxes(callFunction=False) This will set all OptionBoxes in the app back to their first value (even if it's disabled). Set callFunction to be True, if you want to call any associated functions. .deleteOptionBox(title, position) This will delete the item in the list, at the position specified. Alternatively, the name of an item can be specified. Not available on TickOptionBoxes.","title":"Set OptionBoxes"},{"location":"widgets/option/#get-optionboxes","text":".getOptionBox(title) This will return the currently displayed value in an OptionBox. Or a dictionary of names, and their boolean value if a TickOptionBox. Will return None, if an invalid option is currently selected. .getAllOptionBoxes() This will return the contents of all OptionBoxes in the app, as a dictionary.","title":"Get OptionBoxes"},{"location":"widgets/plot/","text":"MatPlotLib ( beta ) Support for embedding very basic MatPlotLib plots. from numpy import sin, pi, arange from appJar import gui import random def getXY(): x = arange(0.0, 3.0, 0.01) y = sin(random.randint(1,10) * pi * x) return x,y def generate(btn): # *getXY() will unpack the two return values # and pass them as separate parameters app.updatePlot(\"p1\", *getXY()) showLabels() def showLabels(): axes.legend(['The curve']) axes.set_xlabel(\"X Axes\") axes.set_ylabel(\"Y Axes\") app.refreshPlot(\"p1\") app = gui() axes = app.addPlot(\"p1\", *getXY()) showLabels() app.addButton(\"Generate\", generate) app.go() .addPlot(title, x, y) Create a plot with the specified x and y values. Returns the plot object, to allow further customisation. .addPlotFig(title) Create an empty Figure, so that you can add your own plots. Returns the figure object, to allow further customisation. from appJar import gui from mpl_toolkits.mplot3d import Axes3D with gui() as app: fig = app.addPlotFig(\"p1\") ax = fig.add_subplot(111, projection='3d') ax.scatter([1,2],[1,2],[1,2]) .updatePlot(title, x, y, keepLabels=False) Update the specified plot with the specified x and y values. NB. if you do this you will lose any customisations applied to the axes. If you set keepLabels to True, then the axis labels & title will be retained. Also, your app will crash, if you call this after .addPlotFig() .refreshPlot(title) Call this any time you modify the axes.","title":"Plot"},{"location":"widgets/plot/#matplotlib-beta","text":"Support for embedding very basic MatPlotLib plots. from numpy import sin, pi, arange from appJar import gui import random def getXY(): x = arange(0.0, 3.0, 0.01) y = sin(random.randint(1,10) * pi * x) return x,y def generate(btn): # *getXY() will unpack the two return values # and pass them as separate parameters app.updatePlot(\"p1\", *getXY()) showLabels() def showLabels(): axes.legend(['The curve']) axes.set_xlabel(\"X Axes\") axes.set_ylabel(\"Y Axes\") app.refreshPlot(\"p1\") app = gui() axes = app.addPlot(\"p1\", *getXY()) showLabels() app.addButton(\"Generate\", generate) app.go() .addPlot(title, x, y) Create a plot with the specified x and y values. Returns the plot object, to allow further customisation. .addPlotFig(title) Create an empty Figure, so that you can add your own plots. Returns the figure object, to allow further customisation. from appJar import gui from mpl_toolkits.mplot3d import Axes3D with gui() as app: fig = app.addPlotFig(\"p1\") ax = fig.add_subplot(111, projection='3d') ax.scatter([1,2],[1,2],[1,2]) .updatePlot(title, x, y, keepLabels=False) Update the specified plot with the specified x and y values. NB. if you do this you will lose any customisations applied to the axes. If you set keepLabels to True, then the axis labels & title will be retained. Also, your app will crash, if you call this after .addPlotFig() .refreshPlot(title) Call this any time you modify the axes.","title":"MatPlotLib (beta)"},{"location":"widgets/properties/","text":"Properties A compound widget that shows multiple CheckButtons linked to a dictionary. Note, dictionaries have no order, so when added as a dictionary, the items will be automatically sorted. from appJar import gui toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.addProperties(\"Toppings\", toppings) app.setProperty(\"Toppings\", \"Pepper\") app.go() Add Properties .addProperties(title, values) Creates a new Properties widget, with the specified title. If values is populated, then the dictionary items will be added to the widget. Set Properties .setPropertyText(title, prop, newText=None) Change the displayed text for the named property. If no value is provided, the original value will be used. .setProperties(title, props, callFunction=True) Adds the dictionary of properties to the widget. If any of them already exist, they will be updated. Set callFunction to be False, if you don't want to call any associated functions. .setProperty(title, prop, value=False, callFunction=True) Sets the named property to the specified value. If it doesn't exist, it will be added first, at the end of the widget. Set callFunction to be False, if you don't want to call any associated functions. .deleteProperty(title, prop) Deletes the named property from the widget. .resetProperties(title, callFunction=True) This will reset the specified Properties back to its original values. Set callFunction to be False, if you don't want to call any associated functions. .clearProperties(title, callFunction=True) This will set all values in the specified Properties to False. Set callFunction to be False, if you don't want to call any associated functions. .resetAllProperties(callFunction=False) This will reset all Properties in the app back to their original values. Set callFunction to be True, if you want to call any associated functions. .clearAllProperties(callFunction=False) This will set all values in all Properties in the app to False. Set callFunction to be True, if you want to call any associated functions. Get Properties .getProperties(title) Gets a dictionary of the all items in the Properties widget. .getAllProperties() This will return the contents of all Properties in the app, as a dictionary. .getProperty(title, prop) Gets the value of the named property. Examples It's possible to put Properties into ToggleFrames, and also set a Function to listen for any changes. from appJar import gui def changed(props): print(\"Changed\", props) toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.startToggleFrame(\"Toppings\") app.addProperties(\"Toppings\", toppings) app.setPropertiesChangeFunction(\"Toppings\", changed) app.stopToggleFrame() app.go()","title":"Properties"},{"location":"widgets/properties/#properties","text":"A compound widget that shows multiple CheckButtons linked to a dictionary. Note, dictionaries have no order, so when added as a dictionary, the items will be automatically sorted. from appJar import gui toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.addProperties(\"Toppings\", toppings) app.setProperty(\"Toppings\", \"Pepper\") app.go()","title":"Properties"},{"location":"widgets/properties/#add-properties","text":".addProperties(title, values) Creates a new Properties widget, with the specified title. If values is populated, then the dictionary items will be added to the widget.","title":"Add Properties"},{"location":"widgets/properties/#set-properties","text":".setPropertyText(title, prop, newText=None) Change the displayed text for the named property. If no value is provided, the original value will be used. .setProperties(title, props, callFunction=True) Adds the dictionary of properties to the widget. If any of them already exist, they will be updated. Set callFunction to be False, if you don't want to call any associated functions. .setProperty(title, prop, value=False, callFunction=True) Sets the named property to the specified value. If it doesn't exist, it will be added first, at the end of the widget. Set callFunction to be False, if you don't want to call any associated functions. .deleteProperty(title, prop) Deletes the named property from the widget. .resetProperties(title, callFunction=True) This will reset the specified Properties back to its original values. Set callFunction to be False, if you don't want to call any associated functions. .clearProperties(title, callFunction=True) This will set all values in the specified Properties to False. Set callFunction to be False, if you don't want to call any associated functions. .resetAllProperties(callFunction=False) This will reset all Properties in the app back to their original values. Set callFunction to be True, if you want to call any associated functions. .clearAllProperties(callFunction=False) This will set all values in all Properties in the app to False. Set callFunction to be True, if you want to call any associated functions.","title":"Set Properties"},{"location":"widgets/properties/#get-properties","text":".getProperties(title) Gets a dictionary of the all items in the Properties widget. .getAllProperties() This will return the contents of all Properties in the app, as a dictionary. .getProperty(title, prop) Gets the value of the named property.","title":"Get Properties"},{"location":"widgets/properties/#examples","text":"It's possible to put Properties into ToggleFrames, and also set a Function to listen for any changes. from appJar import gui def changed(props): print(\"Changed\", props) toppings={\"Cheese\":False, \"Tomato\":False, \"Bacon\":False, \"Corn\":False, \"Mushroom\":False} app=gui() app.setBg(\"lightBlue\") app.setFont(20) app.startToggleFrame(\"Toppings\") app.addProperties(\"Toppings\", toppings) app.setPropertiesChangeFunction(\"Toppings\", changed) app.stopToggleFrame() app.go()","title":"Examples"},{"location":"widgets/radio/","text":"RadioButton A group of round boxes, only one of which can be selected. These are great for getting a single value, for a multiple choice question. from appJar import gui app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.addRadioButton(\"song\", \"Parklife\") app.go() Add RadioButtons .addRadioButton(title, name) This will create a RadioButton grouped by the specified title. This button will have the value of name. Radio buttons are usually used in groups. Set RadioButtons .setRadioButton(title, value, callFunction=True) This will tick the specified RadioButton. Set callFunction to be False, if you don't want to call any associated functions. .setRadioTick(title, tick=True) It is possible to use tick-boxes instead of the classic circular radio-button. Setting tick to True will convert all the radio-buttons for this title to tick boxes. .clearAllRadioButtons(callFunction=False) This will reset all RadioButtons in the app to their first value. Set callFunction to be True, if you want to call any associated functions. Get RadioButtons .getRadioButton(title) Gets the value of the selected RadioButton, for the specified title. from appJar import gui def press(rb): print(app.getRadioButton(\"song\")) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") # call this function, when the RadioButton changes app.setRadioButtonChangeFunction(\"song\", press) app.addButton(\"PLAY\", press) app.go() .getAllRadioButtons() This will return the contents of all RadioButtons in the app, as a dictionary.","title":"Radio"},{"location":"widgets/radio/#radiobutton","text":"A group of round boxes, only one of which can be selected. These are great for getting a single value, for a multiple choice question. from appJar import gui app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") app.addRadioButton(\"song\", \"Parklife\") app.go()","title":"RadioButton"},{"location":"widgets/radio/#add-radiobuttons","text":".addRadioButton(title, name) This will create a RadioButton grouped by the specified title. This button will have the value of name. Radio buttons are usually used in groups.","title":"Add RadioButtons"},{"location":"widgets/radio/#set-radiobuttons","text":".setRadioButton(title, value, callFunction=True) This will tick the specified RadioButton. Set callFunction to be False, if you don't want to call any associated functions. .setRadioTick(title, tick=True) It is possible to use tick-boxes instead of the classic circular radio-button. Setting tick to True will convert all the radio-buttons for this title to tick boxes. .clearAllRadioButtons(callFunction=False) This will reset all RadioButtons in the app to their first value. Set callFunction to be True, if you want to call any associated functions.","title":"Set RadioButtons"},{"location":"widgets/radio/#get-radiobuttons","text":".getRadioButton(title) Gets the value of the selected RadioButton, for the specified title. from appJar import gui def press(rb): print(app.getRadioButton(\"song\")) app=gui() app.addRadioButton(\"song\", \"Killer Queen\") app.addRadioButton(\"song\", \"Paradise City\") # call this function, when the RadioButton changes app.setRadioButtonChangeFunction(\"song\", press) app.addButton(\"PLAY\", press) app.go() .getAllRadioButtons() This will return the contents of all RadioButtons in the app, as a dictionary.","title":"Get RadioButtons"},{"location":"widgets/scale/","text":"Scale A slider, that has a minimum & maximum value. from appJar import gui app=gui() app.setFont(20) app.addLabelScale(\"scale\") app.go() Add Scales .addScale(title) Adds a horizontal scale, with a default range between 0 and 100. Set Scales .setScale(title, pos, callFunction=True) Sets the selected pos for the specified Scale. Set callFunction to be False, if you don't want to call any associated functions. .setScaleRange(title from, to, curr=None) Allows you to change the range available in the Scale. If curr is provided, then the Scale will be set to that value. .setScaleIncrement(title, increment) Configures how much the scale jumps, when the trough is clicked. It defaults to 10%. .showScaleIntervals(title, intervals) Configures the Scale to show interval labels along its length. intervals should be how often to show a value, eg. 25 would show 0, 25, 50, and so on... .showScaleValue(title, show=True) Configures the Scale to show the currently selected value. .setScaleHorizontal(title) & .setScaleVertical(title) Changes the Scale's orientation to the specified value. .setScaleWidth(title, width) & .setScaleLength(title, length) Sets a width/length for the scale's slider. .setScaleChangeFunction(title, func) Sets a function to call, each time the scale is changed. The function must take one parameter, which will be populated with the scale's title. .clearAllScales(callFunction=False) This will set all Scales in the app to their minimum value. Set callFunction to be True, if you want to call any associated functions. Get Scales .getScale(title) Gets the currently selected value from the scale. .getAllScales() This will return the contents of all Scales in the app, as a dictionary.","title":"Scale"},{"location":"widgets/scale/#scale","text":"A slider, that has a minimum & maximum value. from appJar import gui app=gui() app.setFont(20) app.addLabelScale(\"scale\") app.go()","title":"Scale"},{"location":"widgets/scale/#add-scales","text":".addScale(title) Adds a horizontal scale, with a default range between 0 and 100.","title":"Add Scales"},{"location":"widgets/scale/#set-scales","text":".setScale(title, pos, callFunction=True) Sets the selected pos for the specified Scale. Set callFunction to be False, if you don't want to call any associated functions. .setScaleRange(title from, to, curr=None) Allows you to change the range available in the Scale. If curr is provided, then the Scale will be set to that value. .setScaleIncrement(title, increment) Configures how much the scale jumps, when the trough is clicked. It defaults to 10%. .showScaleIntervals(title, intervals) Configures the Scale to show interval labels along its length. intervals should be how often to show a value, eg. 25 would show 0, 25, 50, and so on... .showScaleValue(title, show=True) Configures the Scale to show the currently selected value. .setScaleHorizontal(title) & .setScaleVertical(title) Changes the Scale's orientation to the specified value. .setScaleWidth(title, width) & .setScaleLength(title, length) Sets a width/length for the scale's slider. .setScaleChangeFunction(title, func) Sets a function to call, each time the scale is changed. The function must take one parameter, which will be populated with the scale's title. .clearAllScales(callFunction=False) This will set all Scales in the app to their minimum value. Set callFunction to be True, if you want to call any associated functions.","title":"Set Scales"},{"location":"widgets/scale/#get-scales","text":".getScale(title) Gets the currently selected value from the scale. .getAllScales() This will return the contents of all Scales in the app, as a dictionary.","title":"Get Scales"},{"location":"widgets/separator/","text":"Separator Useful for indicating separation between widgets. Will draw a horizontal/vertical line spanning the cell. from appJar import gui app=gui() app.setBg(\"lightBlue\") app.addHorizontalSeparator(0,0,4, colour=\"red\") app.addVerticalSeparator(1,0, colour=\"red\") app.addVerticalSeparator(1,1, colour=\"red\") app.addVerticalSeparator(1,2, colour=\"red\") app.addVerticalSeparator(1,3, colour=\"red\") app.addHorizontalSeparator(2,0,4, colour=\"red\") app.go() Add Seperators .addHorizontalSeparator(colour=None) & .addVerticalSeparator(colour=None) Adds a separator (a horizontal or vertical line) spanning the cell. An optional colour can be passed in, to set a colour for the separator.","title":"Separator"},{"location":"widgets/separator/#separator","text":"Useful for indicating separation between widgets. Will draw a horizontal/vertical line spanning the cell. from appJar import gui app=gui() app.setBg(\"lightBlue\") app.addHorizontalSeparator(0,0,4, colour=\"red\") app.addVerticalSeparator(1,0, colour=\"red\") app.addVerticalSeparator(1,1, colour=\"red\") app.addVerticalSeparator(1,2, colour=\"red\") app.addVerticalSeparator(1,3, colour=\"red\") app.addHorizontalSeparator(2,0,4, colour=\"red\") app.go()","title":"Separator"},{"location":"widgets/separator/#add-seperators","text":".addHorizontalSeparator(colour=None) & .addVerticalSeparator(colour=None) Adds a separator (a horizontal or vertical line) spanning the cell. An optional colour can be passed in, to set a colour for the separator.","title":"Add Seperators"},{"location":"widgets/spin/","text":"SpinBox A scrollable list of options. Up and down buttons are provided to scroll from one item to the next. Unlike the OptionBox, you do not get a drop-down of choices, instead it spins to the next/previous option. from appJar import gui app=gui() app.setFont(20) app.addLabelSpinBox(\"options\", [\"Apple\", \"Orange\", \"Pear\", \"kiwi\"]) app.go() Add SpinBoxes .addSpinBox(title, values) This will create a SpinBox, adding the contents of the values list, in the order specified. .addSpinBoxRange(title, from, to) This will create a SpinBox, with a numeric range of items. from appJar import gui app=gui() app.setFont(20) app.addSpinBoxRange(\"Numbers\", 1, 12) app.go() Set SpinBoxes .setSpinBox(title, value, callFunction=True) This will select the specified value in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .setSpinBoxPos(title, pos, callFunction=True) This will select the value at the specified position in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllSpinBoxes(callFunction=False) This will set all SpinBoxes in the app to their first value. Set callFunction to be True, if you want to call any associated functions. Get SpinBoxes .getSpinBox(title) This will get the selected value from the specified SpinBox. .getAllSpinBoxes() This will return the contents of all SpinBoxes in the app, as a dictionary.","title":"Spin"},{"location":"widgets/spin/#spinbox","text":"A scrollable list of options. Up and down buttons are provided to scroll from one item to the next. Unlike the OptionBox, you do not get a drop-down of choices, instead it spins to the next/previous option. from appJar import gui app=gui() app.setFont(20) app.addLabelSpinBox(\"options\", [\"Apple\", \"Orange\", \"Pear\", \"kiwi\"]) app.go()","title":"SpinBox"},{"location":"widgets/spin/#add-spinboxes","text":".addSpinBox(title, values) This will create a SpinBox, adding the contents of the values list, in the order specified. .addSpinBoxRange(title, from, to) This will create a SpinBox, with a numeric range of items. from appJar import gui app=gui() app.setFont(20) app.addSpinBoxRange(\"Numbers\", 1, 12) app.go()","title":"Add SpinBoxes"},{"location":"widgets/spin/#set-spinboxes","text":".setSpinBox(title, value, callFunction=True) This will select the specified value in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .setSpinBoxPos(title, pos, callFunction=True) This will select the value at the specified position in the SpinBox. Set callFunction to be False, if you don't want to call any associated functions. .clearAllSpinBoxes(callFunction=False) This will set all SpinBoxes in the app to their first value. Set callFunction to be True, if you want to call any associated functions.","title":"Set SpinBoxes"},{"location":"widgets/spin/#get-spinboxes","text":".getSpinBox(title) This will get the selected value from the specified SpinBox. .getAllSpinBoxes() This will return the contents of all SpinBoxes in the app, as a dictionary.","title":"Get SpinBoxes"},{"location":"widgets/text/","text":"TextArea Similar to an Entry, but allows you to type text over multiple lines. from appJar import gui app=gui() app.addTextArea(\"t1\") app.go() Add TextAreas .addTextArea(title) Adds an empty TextArea, with the specified title. .addScrolledTextArea(title) Adds a scrollable TextArea with the specified title. Set TextAreas .setTextArea(title, text, end=True, callFunction=True) Adds the supplied text to the specified TextArea. By default, the text is added to the end. Set end to be False if you want to add at the beginning. Set callFunction to be False, if you don't want to call any associated functions. .clearTextArea(title, callFunction=True) Clears the contents of the specified TextArea. Set callFunction to be False, if you don't want to call any associated functions. .clearAllTextAreas(callFunction=False) This will clear the contents of all TextAreas in the app. Set callFunction to be True, if you want to call any associated functions. Get TextAreas .getTextArea(title) Gets the contents of the specified TextArea. .getAllTextAreas() This will return the contents of all TextAreas in the app, as a dictionary.","title":"Text"},{"location":"widgets/text/#textarea","text":"Similar to an Entry, but allows you to type text over multiple lines. from appJar import gui app=gui() app.addTextArea(\"t1\") app.go()","title":"TextArea"},{"location":"widgets/text/#add-textareas","text":".addTextArea(title) Adds an empty TextArea, with the specified title. .addScrolledTextArea(title) Adds a scrollable TextArea with the specified title.","title":"Add TextAreas"},{"location":"widgets/text/#set-textareas","text":".setTextArea(title, text, end=True, callFunction=True) Adds the supplied text to the specified TextArea. By default, the text is added to the end. Set end to be False if you want to add at the beginning. Set callFunction to be False, if you don't want to call any associated functions. .clearTextArea(title, callFunction=True) Clears the contents of the specified TextArea. Set callFunction to be False, if you don't want to call any associated functions. .clearAllTextAreas(callFunction=False) This will clear the contents of all TextAreas in the app. Set callFunction to be True, if you want to call any associated functions.","title":"Set TextAreas"},{"location":"widgets/text/#get-textareas","text":".getTextArea(title) Gets the contents of the specified TextArea. .getAllTextAreas() This will return the contents of all TextAreas in the app, as a dictionary.","title":"Get TextAreas"},{"location":"widgets/tree/","text":"Tree ( beta ) Takes an arbitrary XML string, and converts it into a tree structure. from appJar import gui app = gui() app.addTree(\"t1\", \"\"\"<people> <person><name>Fred</name><age>45</age><gender>Male</gender></person> <person><name>Tina</name><age>37</age><gender>Female</gender></person> <person><name>CLive</name><age>28</age><gender>Male</gender></person> <person><name>Betty</name><age>51</age><gender>Female</gender></person> </people>\"\"\") app.go() Add Trees .addTree(title, xml_data) Create a tree from the specified XML data Set Trees .setTreeDoubleClickFunction(title, func) Register a function to call when an item is double-clicked .setTreeEditFunction(title, func) Register a function to call when an item is edited .setTreeEditable(title, value) Set whether the tree can be edited .setTreeColours(title, fg, bg, fgH, bgH) Set the fg/bg/fg highlight/bg highlight colours of the tree .setTreeBg(title, colour) Set the background colour of the tree .setTreeFg(title, colour) Set the foreground colour of the tree .setTreeHighlightBg(title, colour) Set the background colour of the highlighted node .setTreeHighlightFg(title, colour) Set the foreground colour of the highlighted node Get Trees .getTreeXML(title) Return the tree as XML .getTreeSelected(title) Return the selected node as a String .getTreeSelectedXML(title) Return the selected node (and any children) as XML","title":"Tree"},{"location":"widgets/tree/#tree-beta","text":"Takes an arbitrary XML string, and converts it into a tree structure. from appJar import gui app = gui() app.addTree(\"t1\", \"\"\"<people> <person><name>Fred</name><age>45</age><gender>Male</gender></person> <person><name>Tina</name><age>37</age><gender>Female</gender></person> <person><name>CLive</name><age>28</age><gender>Male</gender></person> <person><name>Betty</name><age>51</age><gender>Female</gender></person> </people>\"\"\") app.go()","title":"Tree (beta)"},{"location":"widgets/tree/#add-trees","text":".addTree(title, xml_data) Create a tree from the specified XML data","title":"Add Trees"},{"location":"widgets/tree/#set-trees","text":".setTreeDoubleClickFunction(title, func) Register a function to call when an item is double-clicked .setTreeEditFunction(title, func) Register a function to call when an item is edited .setTreeEditable(title, value) Set whether the tree can be edited .setTreeColours(title, fg, bg, fgH, bgH) Set the fg/bg/fg highlight/bg highlight colours of the tree .setTreeBg(title, colour) Set the background colour of the tree .setTreeFg(title, colour) Set the foreground colour of the tree .setTreeHighlightBg(title, colour) Set the background colour of the highlighted node .setTreeHighlightFg(title, colour) Set the foreground colour of the highlighted node","title":"Set Trees"},{"location":"widgets/tree/#get-trees","text":".getTreeXML(title) Return the tree as XML .getTreeSelected(title) Return the selected node as a String .getTreeSelectedXML(title) Return the selected node (and any children) as XML","title":"Get Trees"},{"location":"widgets/turtle/","text":"Turtle ( beta ) This lets you embed a turtle widget in appJar. from appJar import gui def press(b): s = app.getTurtleScreen(\"t1\") t = app.getTurtle(\"t1\") s.bgcolor(\"blue\") t.pencolor(\"white\") for i in range(20): t.forward(i * 10) t.right(144) app=gui() app.addTurtle(\"t1\") app.addButton(\"DRAW\", press) app.go() .addTurtle(title) Creates a turtle widget. .getTurtle(title) Gets the specified turtle widget. .getTurtleScreen(title) Gets the screen behind the turtle widget.","title":"Turtle"},{"location":"widgets/turtle/#turtle-beta","text":"This lets you embed a turtle widget in appJar. from appJar import gui def press(b): s = app.getTurtleScreen(\"t1\") t = app.getTurtle(\"t1\") s.bgcolor(\"blue\") t.pencolor(\"white\") for i in range(20): t.forward(i * 10) t.right(144) app=gui() app.addTurtle(\"t1\") app.addButton(\"DRAW\", press) app.go() .addTurtle(title) Creates a turtle widget. .getTurtle(title) Gets the specified turtle widget. .getTurtleScreen(title) Gets the screen behind the turtle widget.","title":"Turtle (beta)"},{"location":"widgets/widgets/","text":"Widgets In a GUI, the fillings are known as widgets . There are lots of different widgets to choose from, each suited to a specific task. Nearly every widget needs a TITLE . This is a unique name for the widget, so that later you can get information from that widget, or change it. Nearly all widgets in appJar provide the same three functions: (Always) - ADD a widget (with a unique title) - this creates the widget (Often) - GET the widget (using its unique title) - this gets the contents of the widget (usually done in a function) (Sometimes) - SET the widget (using its unique title) - this changes what's in the widget On top of these, there is a common set of functions for changing widgets . As well as some specialist functions, unique to each widget (see below). Auto-Labelled Widgets It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does.","title":"Widgets"},{"location":"widgets/widgets/#widgets","text":"In a GUI, the fillings are known as widgets . There are lots of different widgets to choose from, each suited to a specific task. Nearly every widget needs a TITLE . This is a unique name for the widget, so that later you can get information from that widget, or change it. Nearly all widgets in appJar provide the same three functions: (Always) - ADD a widget (with a unique title) - this creates the widget (Often) - GET the widget (using its unique title) - this gets the contents of the widget (usually done in a function) (Sometimes) - SET the widget (using its unique title) - this changes what's in the widget On top of these, there is a common set of functions for changing widgets . As well as some specialist functions, unique to each widget (see below).","title":"Widgets"},{"location":"widgets/widgets/#auto-labelled-widgets","text":"It's possible to automatically include a label alongside a lot of the widgets. Both the label and widget will be placed in the same grid space. Simply add the word Label to the command when adding the widget: .addLabelEntry(title) .addLabelNumericEntry(title) .addLabelSecretEntry(title) .addLabelAutoEntry(title, words) .addLabelScale(title) .addLabelOptionBox(title, values) .addLabelTickOptionBox(title, values) .addLabelSpinBox(title, values) .addLabelSpinBoxRange(title, from, to) See the relevant section for a description of what the widget does.","title":"Auto-Labelled Widgets"}]}